[{"title":"动态路由加载","date":"2022-05-30T02:03:38.000Z","path":"2022/05/30/动态路由加载/","text":"重置初始路由逻辑： 123456789101112131415const routes = [ &#123; path, name, component &#125;, ...]const createRouter = () =&gt; new VueRouter(&#123; routes &#125;)const router = createRouter()function resetRouter() &#123; const newRouter = createRouter() router.matcher = newRouter.matcher&#125;export &#123; router, resetRouter &#125; 动态加载逻辑： 1234567891011121314151617resetRouter() // 重置路由const addRoutes = [..., &#123; path, name, component &#125;]// 404页面必须最后加addRoutes.push(&#123; path: &#x27;*&#x27;, name: &#x27;__any__&#x27;, redirect: to =&gt; &#123; return &#123; name: &#x27;ErrorPage&#x27;, &#125; &#125;,&#125;)for (const route of addRoutes) &#123; router.addRoute(route)&#125; 一般是需要在router.beforeEach进行动态路由添加，且next必须使用以下方法进行 1234router.beforeEach(async (to, from, next) =&gt; &#123; // ...动态添加路由操作 next(&#123; ...to, replace: true &#125;) // hack方法 确保addRoute已完成&#125;)","tags":[{"name":"Vue","slug":"Vue","permalink":"https://sellenite.github.io/tags/Vue/"}]},{"title":"transition折叠效果，重写transition","date":"2022-05-30T01:36:01.000Z","path":"2022/05/30/transition折叠效果，重写transition/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const elTransition = &#x27;0.3s all ease&#x27;;const Transition = &#123; beforeEnter(el) &#123; el.style.transition = elTransition; if (!el.dataset) el.dataset = &#123;&#125;; el.style.height = 0; el.style.opacity = 0; &#125;, enter(el) &#123; if (el.scrollHeight !== 0) &#123; el.style.height = `$&#123;el.scrollHeight&#125;px`; el.style.opacity = 1 &#125; else &#123; el.style.height = &#x27;&#x27;; el.style.opacity = &#x27;&#x27; &#125; el.style.overflow = &#x27;hidden&#x27;; &#125;, afterEnter(el) &#123; el.style.transition = &#x27;&#x27;; el.style.height = &#x27;&#x27;; el.style.opacity = &#x27;&#x27; &#125;, beforeLeave(el) &#123; if (!el.dataset) el.dataset = &#123;&#125;; el.style.display = &#x27;block&#x27;; el.style.height = `$&#123;el.scrollHeight&#125;px`; el.style.overflow = &#x27;hidden&#x27;; el.style.opacity = 1 &#125;, leave(el) &#123; if (el.scrollHeight !== 0) &#123; el.style.transition = elTransition; el.style.height = 0; el.style.opacity = 0; &#125; &#125;, afterLeave(el) &#123; el.style.transition = &#x27;&#x27;; el.style.height = &#x27;&#x27;; el.style.opacity = &#x27;&#x27; &#125;,&#125;;export default &#123; name: &#x27;CollapseTransition&#x27;, functional: true, render(h, &#123; children &#125;) &#123; const data = &#123; on: Transition, &#125;; return h(&#x27;transition&#x27;, data, children); &#125;,&#125;; 应用：左边导航栏树型组件动画 12345678910&lt;template&gt; &lt;div class=&quot;level-1&quot;&gt; &lt;div class=&quot;label&quot;&gt;&lt;/div&gt; &lt;collapse-transition&gt; &lt;div class=&quot;level-2-menu&quot; v-show=&quot;levelOne.expand&quot;&gt; ... &lt;/div&gt; &lt;/collapse-transition&gt; &lt;/div&gt;&lt;/template&gt;","tags":[{"name":"Vue","slug":"Vue","permalink":"https://sellenite.github.io/tags/Vue/"}]},{"title":"关于html2canvasc生成图片的注意事项","date":"2021-12-22T07:07:59.000Z","path":"2021/12/22/关于html2canvasc生成图片的注意事项/","text":"“html2canvas”: “^1.3.2”，最新版已经支持scale，网上搜索的图片模糊解决方案均已过时 一般使用： 12345678910111213141516171819202122232425262728// &quot;html2canvas&quot;: &quot;^1.3.2&quot;import html2canvas from &#x27;html2canvas&#x27;const options = &#123; scale: window.devicePixelRatio, // 添加的scale参数 useCORS: true, // 【重要】开启跨域配置，否则iOS会报【DOM Exception 18: The operation is insecure】 backgroundColor: &#x27;#FFF&#x27;, // null&#125;// 保证在最顶层，不然出现了滚动条后，不在最顶层截图时会出现截图空白html2canvas(document.querySelector(&#x27;.container&#x27;), options) .then(canvas =&gt; &#123; // base64渲染方法 const base64Url = canvas.toDataURL(&#x27;image/jpeg&#x27;, 0.9) // 图片转换成文件提交方法 // 不能大于1m，否则报错，所以使用jpg并且压缩0.9 canvas.toBlob((blob) =&gt; &#123; const formData = new FormData(); // 钉钉的消息通知只认png和jpg结尾的文件为图片，不能使用jpeg作为后缀，否则推送不成功 formData.append(&#x27;uploadFile&#x27;, blob, `test.jpg`); // 发送formData类型到后端 request(formData) &#125;, &#x27;image/jpeg&#x27;, 0.9); &#125;) .catch(err =&gt; &#123; &#125;) 元素里面的图片渲染不清晰问题 有两点需要特别注意，这关系到生成图片的质量 1、img元素不要使用object-fit，html2canvas生成的图片不支持object-fit 2、不要使用background或background-image来渲染图片，会导致html2canvas生成的图片background区域内的图片很模糊，必须使用img 有以下场景：图片大小不固定，需要自适应显示，对应object-fit的contain和background-size的contain，如今html2canvas对object-fit不支持，且使用background会使图片模糊，只能额外借助js解决 不使用object-fit和background-size模拟contain的效果，但只能一个方向，要判断两个方向需要额外判断图片的渲染大小，写在行内样式里 12345678910.image-wrapper &#123; display: flex; justify-content: center; align-items: center;&#125;.image-wrapper image &#123; // width: 100%; 宽比高长时可以垂直居中显示并具有contain效果，width和height只能设置其中一个为100% // height: 100%; 宽比高长时可以水平居中显示并具有contain效果，width和height只能设置其中一个为100%&#125; 配合js实现图片contain自适应，vue解决方案 template 123&lt;div class=&quot;image-wrapper&quot;&gt; &lt;img :src=&quot;image&quot; :style=&quot;imgComputedStyle&quot;&gt;&lt;/img&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829&#123; data() &#123; return &#123; imgComputedStyle: &#123;&#125; &#125; &#125;, watch: &#123; image: &#123; handler(v) &#123; this.$nextTick(() =&gt; &#123; const img = new Image() let imgComputedStyle = &#123;&#125; img.onload = () =&gt; &#123; const width = img.width const height = img.height if (width &gt;= height) &#123; imgComputedStyle.width = &#x27;100%&#x27; &#125; else &#123; imgComputedStyle.height = &#x27;100%&#x27; &#125; this.imgComputedStyle = imgComputedStyle &#125; img.src = v &#125;) &#125;, immediate: true &#125; &#125;&#125; 这样的html2canvas渲染出来里面的图片具有自适应contain的效果且清晰 渲染文字错位渲染不全的问题有时候渲染的容器需要有预留空位，不要使用margin作为预留左右空位，且overflow:hidden的手段，使用padding代替，这样就不会出现错误渲染字体的情况 非视野区域截图opacity为0，或者visibility为hidden，display：none，这样都无法解决非视野区域截图的问题 使用top: -9999px，这样也是无法解决的 只有使用层级最低的手段下才能做到非视野区域的截图 12top: 0px;z-index: -1;","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"}]},{"title":"h5拖拽功能","date":"2021-07-14T09:23:54.000Z","path":"2021/07/14/h5拖拽功能/","text":"直接上html例子，分为任意悬停和磁吸悬停 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .draggable &#123; position: fixed; bottom: 20px; right: 20px; background-color: gold; width: 40px; height: 60px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;draggable&quot;&gt;&lt;/div&gt; &lt;script&gt; function isAndroid() &#123; var u = navigator.userAgent return u.indexOf(&#x27;Android&#x27;) &gt; -1 || u.indexOf(&#x27;Adr&#x27;) &gt; -1 &#125; const raf = window.requestAnimationFrame; /** * 封装拖拽函数 * @param $ele 需要拖拽的元素 * @param isAnywhere 是否可以任意位置悬停，false的话则表现为松手就贴边 * @param adsorb &#123; x = 20, y = 80 &#125; 上下左右吸附的边距 * @return Function 返回移除监听器的函数 */ function draggable($ele, isAnywhere = false, adsorb = &#123; x: 20, y: 20 &#125;) &#123; if (!$ele) &#123; throw new Error(&quot;必须是可拖拽元素&quot;); &#125; // 开始时候的位置 let startX = 0; let startY = 0; // 移动过程中的 left 和 top，其实通过这俩参数，就能确定元素位置 let left = 0; let top = 0; // 屏幕的宽高 const cw = document.documentElement.clientWidth; const ch = document.documentElement.clientHeight; // 获取到元素自身的宽高 const &#123; width, height &#125; = $ele.getBoundingClientRect(); function touchStart(event) &#123; startX = event.targetTouches[0].pageX; startY = event.targetTouches[0].pageY; top = $ele.offsetTop; left = $ele.offsetLeft; event.preventDefault(); &#125; function touchMove(event) &#123; // 偏移距离 const offsetX = event.targetTouches[0].pageX - startX; const offsetY = event.targetTouches[0].pageY - startY; $ele.style.top = `$&#123;top + offsetY&#125;px`; $ele.style.left = `$&#123;left + offsetX&#125;px`; $ele.style.right = &quot;auto&quot;; $ele.style.bottom = &quot;auto&quot;; event.preventDefault(); &#125; function touchDone(event) &#123; const dx = event.changedTouches[0].pageX - startX; const dy = event.changedTouches[0].pageY - startY; const ty = top + dy; const tx = left + dx; $ele.style.top = `$&#123;ty&#125;px`; $ele.style.left = `$&#123;tx&#125;px`; $ele.style.right = &quot;auto&quot;; $ele.style.bottom = &quot;auto&quot;; const adsorb_safe_x = cw - width - adsorb.x; const adsorb_safe_y = ch - height - adsorb.y; raf(() =&gt; &#123; let nx = tx; let ny = ty; // 处理不同的悬停方式 if (isAnywhere) &#123; if (tx &lt; adsorb.x) &#123; nx = adsorb.x; &#125; else if (tx &gt; (cw - width - adsorb.x)) &#123; nx = adsorb_safe_x; &#125; if (ty &lt; adsorb.y) &#123; ny = adsorb.y; &#125; else if (ty &gt; (ch - height - adsorb.y)) &#123; ny = adsorb_safe_y; &#125; &#125; else &#123; if (tx + width / 2 &lt; cw / 2) &#123; nx = adsorb.x; &#125; else &#123; nx = adsorb_safe_x; &#125; if (ty &lt; adsorb.y) &#123; ny = adsorb.y; &#125; else if (ty &gt; adsorb_safe_y) &#123; ny = adsorb_safe_y; &#125; &#125; // 无需移动，并且认为进行了一次点击 // click兼容处理 if (Math.abs(dx) &lt; 5 &amp;&amp; Math.abs(dy) &lt; 5) &#123; $ele.click(); return; &#125; const MOVE_ANIM_INTER = isAndroid() ? Math.abs(((250 * (tx - nx)) / 800) | 0) : 200; $ele.style.webkitTransition = `left $&#123;MOVE_ANIM_INTER&#125;ms linear, top $&#123;MOVE_ANIM_INTER&#125;ms linear`; $ele.style.transition = `left $&#123;MOVE_ANIM_INTER&#125;ms linear, top $&#123;MOVE_ANIM_INTER&#125;ms linear`; const onAnimationDone = () =&gt; &#123; $ele.style.webkitTransition = $ele.style.transition = &quot;none&quot;; $ele.removeEventListener(&quot;webkitTransitionEnd&quot;, onAnimationDone, false); $ele.removeEventListener(&quot;transitionend&quot;, onAnimationDone, false); &#125;; $ele.addEventListener(&quot;webkitTransitionEnd&quot;, onAnimationDone, false); $ele.addEventListener(&quot;transitionend&quot;, onAnimationDone, false); $ele.style.top = `$&#123;ny&#125;px`; $ele.style.left = `$&#123;nx&#125;px`; &#125;); &#125; $ele.addEventListener(&quot;touchstart&quot;, touchStart, false); $ele.addEventListener(&quot;touchmove&quot;, touchMove, false); $ele.addEventListener(&quot;touchend&quot;, touchDone, true); $ele.addEventListener(&quot;touchcancel&quot;, touchDone, true); return function() &#123; $ele.removeEventListener(&quot;touchstart&quot;, touchStart, false); $ele.removeEventListener(&quot;touchmove&quot;, touchMove, false); $ele.removeEventListener(&quot;touchend&quot;, touchDone, true); $ele.removeEventListener(&quot;touchcancel&quot;, touchDone, true); &#125; &#125; window.onload = function() &#123; const dragDom = document.querySelector(&#x27;.draggable&#x27;); // touch和click互不冲突，里面已经做了click的兼容处理 window.addEventListener(&#x27;click&#x27;, () =&gt; &#123; alert(&#x27;click event&#x27;); &#125;) draggable(dragDom, true); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"}]},{"title":"APP适配iPhoneX安全区域","date":"2021-06-30T09:22:06.000Z","path":"2021/06/30/APP适配iPhoneX安全区域/","text":"iPhoneX 取消了物理按键，改成底部小黑条，这一改动导致网页出现了比较尴尬的屏幕适配问题。对于网页而言，顶部（刘海部位）的适配问题浏览器已经做了处理，所以我们只需要关注底部与小黑条的适配问题即可（即常见的吸底导航、返回顶部等各种相对底部 fixed 定位的元素）。 适配之前需要了解的几个新知识安全区域安全区域指的是一个可视窗口范围，处于安全区域的内容不受圆角（corners）、齐刘海（sensor housing）、小黑条（Home Indicator）影响 设计标准：所有组件尺寸均按 iphone6 375pt x 667pt (@1x) 进行设计。适配 iphone X 时，HomeIndicator 预留的高度为 34pt；顶部刘海区域预留高度为 44pt (官方建议预留高度)。 也就是说，我们要做好适配，必须保证页面可视、可操作区域是在安全区域内。 更详细说明，参考文档： Human Interface Guidelines - iPhoneX viewport-fitiOS11 新增特性，苹果公司为了适配 iPhoneX 对现有 viewport meta 标签的一个扩展，用于设置网页在可视窗口的布局方式，可设置三个值： contain: 可视窗口完全包含网页内容 cover：网页内容完全覆盖可视窗口 auto：默认值，跟 contain 表现一致 注意：网页默认不添加扩展的表现是 viewport-fit&#x3D;contain，需要适配 iPhoneX 必须设置 viewport-fit&#x3D;cover，这是适配的关键步骤。 更详细说明，参考文档： viewport-fit-descriptor env() 和 constant()iOS11 新增特性，Webkit 的一个 CSS 函数，用于设定安全区域与边界的距离，有四个预定义的变量： safe-area-inset-left：安全区域距离左边边界距离 safe-area-inset-right：安全区域距离右边边界距离 safe-area-inset-top：安全区域距离顶部边界距离 safe-area-inset-bottom：安全区域距离底部边界距离 这里我们只需要关注 safe-area-inset-bottom 这个变量，因为它对应的就是小黑条的高度（横竖屏时值不一样）。 注意：当 viewport-fit&#x3D;contain 时 env() 是不起作用的，必须要配合 viewport-fit&#x3D;cover 使用。对于不支持env() 的浏览器，浏览器将会忽略它。 在这之前，笔者使用的是 constant()，后来，官方文档加了这么一段注释（坑）： The env() function shipped in iOS 11 with the name constant(). Beginning with Safari Technology Preview 41 and the iOS 11.2 beta, constant() has been removed and replaced with env(). You can use the CSS fallback mechanism to support both versions, if necessary, but should prefer env() going forward. 这就意味着，之前使用的 constant() 在 iOS11.2 之后就不能使用的，但我们还是需要做向后兼容，像这样： 12padding-bottom: constant(safe-area-inset-bottom); /* 兼容 iOS &lt; 11.2 */padding-bottom: env(safe-area-inset-bottom); /* 兼容 iOS &gt;= 11.2 */ 注意：env() 跟 constant() 需要同时存在，而且顺序不能换。 更详细说明，参考文档： Designing Websites for iPhone X 如何适配了解了以上所说的几个知识点，接下来我们适配的思路就很清晰了。 第一步：设置网页在可视窗口的布局方式新增 viweport-fit 属性，使得页面内容完全覆盖整个窗口： 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, viewport-fit=cover&quot;&gt; 前面也有提到过，只有设置了 viewport-fit&#x3D;cover，才能使用 env()。 第二步：页面主体内容限定在安全区域内这一步根据实际页面场景选择，如果不设置这个值，可能存在小黑条遮挡页面最底部内容的情况。 1234body &#123; padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom);&#125; 第三步：fixed 元素的适配类型一：fixed 完全吸底元素（bottom &#x3D; 0）可以通过加内边距 padding 扩展高度： 1234&#123; padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom);&#125; 或者通过计算函数 calc 覆盖原来高度： 1234&#123; height: calc(60px(假设值) + constant(safe-area-inset-bottom)); height: calc(60px(假设值) + env(safe-area-inset-bottom));&#125; 注意，这个方案需要吸底条必须是有背景色的，因为扩展的部分背景是跟随外容器的，否则出现镂空情况。 还有一种方案就是，可以通过新增一个新的元素（空的颜色块，主要用于小黑条高度的占位），然后吸底元素可以不改变高度只需要调整位置，像这样： 1234&#123; margin-bottom: constant(safe-area-inset-bottom); margin-bottom: env(safe-area-inset-bottom);&#125; 空的颜色块： 12345678&#123; position: fixed; bottom: 0; width: 100%; height: constant(safe-area-inset-bottom); height: env(safe-area-inset-bottom); background-color: #fff;&#125; 类型二：fixed 非完全吸底元素（bottom ≠ 0），比如 “返回顶部”、“侧边广告” 等像这种只是位置需要对应向上调整，可以仅通过外边距 margin 来处理： 1234&#123; margin-bottom: constant(safe-area-inset-bottom); margin-bottom: env(safe-area-inset-bottom);&#125; 或者，你也可以通过计算函数 calc 覆盖原来 bottom 值： 1234&#123; bottom: calc(50px(假设值) + constant(safe-area-inset-bottom)); bottom: calc(50px(假设值) + env(safe-area-inset-bottom));&#125; 你也可以使用 @supports 隔离兼容样式写到这里，我们常见的两种类型的 fixed 元素适配方案已经了解了吧。如果我们只希望 iPhoneX 才需要新增适配样式，我们可以配合 @supports 来隔离兼容样式，当然这个处理对页面展示实际不会有任何影响： 123456@supports (bottom: constant(safe-area-inset-bottom)) or (bottom: env(safe-area-inset-bottom)) &#123; div &#123; margin-bottom: constant(safe-area-inset-bottom); margin-bottom: env(safe-area-inset-bottom); &#125;&#125; 项目使用过的方法1234567891011121314151617181920212223242526.app &#123; background: #eee; overflow: hidden; position: fixed; top: 0; right: 0; bottom: 0; left: 0;&#125;@supports (bottom: constant(safe-area-inset-bottom)) or (bottom: env(safe-area-inset-bottom)) &#123; .app &#123; bottom: constant(safe-area-inset-bottom); bottom: env(safe-area-inset-bottom); &#125;&#125;.view-page &#123; position: absolute; overflow: auto; -webkit-overflow-scrolling: touch; top: 0; right: 0; bottom: 0; left: 0;&#125;","tags":[{"name":"CSS","slug":"CSS","permalink":"https://sellenite.github.io/tags/CSS/"}]},{"title":"Hexo部署问题","date":"2021-06-30T09:16:22.000Z","path":"2021/06/30/Hexo部署问题/","text":"如果使用了最新版的node安装hexo-cli，然后项目安装hexo，会出现打包的文件为空的问题。这个是node的版本问题，使用nvm切换至node版本为13.14.0，然后重新全局安装hexo-cli和项目安装hexo，此时就会恢复正常","tags":[]},{"title":"vue-router前进刷新，后退缓存方案；路由动画","date":"2021-06-29T09:25:30.000Z","path":"2021/06/29/vue-router前进刷新，后退缓存方案；路由动画/","text":"原理进入页面后添加该页面至缓存。如果是replace进入的则不进行缓存操作； 退出页面的时候移除该页面的缓存； 添加缓存必须是进入页面后再加，这样下次进入才是缓存，而不是进入前加入缓存，进入后立刻获取上一个状态的缓存 重新定义路由跳转的函数由于全局需要监听函数是否前进&#x2F;后退，需要重新编写路由的跳转函数，利用store，存储进入前的路由状态routerPushStatus，然后在全局路由守卫中获取这个值，以判断进入的是前进还是后退等： 加上全局datetime的query的目的是使$route的fullPath每次都不同，绑在了router-view组件的key上，这样可以保证每下一个页面都能被缓存，即使push的是相同name的页面 .&#x2F;store&#x2F;index.js 123456789101112import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)const state = &#123; routerPushStatus: &#x27;push&#x27;, // 路由进入前的状态push, replace, back，用于判断动画和缓存的机制&#125;export default new Vuex.Store(&#123; state,&#125;) .&#x2F;router.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import store from &#x27;./store/index.js&#x27;import VueRouter from &#x27;vue-router&#x27;import Vue from &#x27;vue&#x27;export const useRouter = VueRouter =&gt; &#123; const routerPush = VueRouter.prototype.push const routerReplace = VueRouter.prototype.replace const routerGo = VueRouter.prototype.go const routerBack = VueRouter.prototype.back const routerForward = VueRouter.prototype.forward VueRouter.prototype.push = function push(location, onComplete, onAbort) &#123; store.state.routerPushStatus = &#x27;push&#x27; if (typeof location === &#x27;object&#x27;) &#123; if (location.hasOwnProperty(&#x27;query&#x27;)) &#123; location.query.__datetime = +new Date() &#125; else &#123; location.query = &#123; __datetime: +new Date() &#125; &#125; &#125; return routerPush.apply(this, [location, onComplete, onAbort]) &#125; VueRouter.prototype.replace = function replace(location, onComplete, onAbort) &#123; store.state.routerPushStatus = &#x27;replace&#x27; if (typeof location === &#x27;object&#x27;) &#123; if (location.hasOwnProperty(&#x27;query&#x27;)) &#123; location.query.__datetime = +new Date() &#125; else &#123; location.query = &#123; __datetime: +new Date() &#125; &#125; &#125; return routerReplace.apply(this, [location, onComplete, onAbort]) &#125; VueRouter.prototype.go = function go(n) &#123; if (n &lt; 0) &#123; store.state.routerPushStatus = &#x27;back&#x27; &#125; else &#123; store.state.routerPushStatus = &#x27;push&#x27; &#125; return routerGo.apply(this, [n]) &#125; VueRouter.prototype.back = function back() &#123; store.state.routerPushStatus = &#x27;back&#x27; return routerBack.apply(this, []) &#125; VueRouter.prototype.forward = function forward() &#123; store.state.routerPushStatus = &#x27;push&#x27; return routerForward.apply(this, []) &#125;&#125;useRouter(VueRouter);Vue.use(VueRouter) 手机端的后退有一个问题，就是如果使用原生的后退，是不会触发router的back()或go(-1)方法的，结果就是如果使用了浏览器原生的后退进行后退，就不会经过自定义的路由函数，无法得知他是后退状态，这时候需要监听popstate来解决这个问题 main.js 12345import store from &#x27;./store/index.js&#x27;window.addEventListener(&#x27;popstate&#x27;, function (e) &#123; store.state.routerPushStatus = &#x27;back&#x27;&#125;, false) 在vuex中定义router缓存的相关module .&#x2F;router-cache.js 12345678910111213141516171819202122232425262728const state = &#123; includedComponents: [], excludedComponents: []&#125;const mutations = &#123; removeInclude(state, str) &#123; state.includedComponents.splice(state.includedComponents.indexOf(str), 1); &#125;, addToInclude(state, str) &#123; if (str &amp;&amp; state.includedComponents.indexOf(str) === -1) &#123; state.includedComponents.push(str); &#125; &#125;, removeExclude(state, str) &#123; state.excludedComponents.splice(state.excludedComponents.indexOf(str), 1); &#125;, addToExclude(state, str) &#123; if (str &amp;&amp; state.excludedComponents.indexOf(str) === -1) &#123; state.excludedComponents.push(str); &#125; &#125;&#125;export default &#123; state, mutations&#125; .&#x2F;store&#x2F;index.js 123456789import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;import routerCache from &#x27;./modules/router-cache.js&#x27;export default new Vuex.Store(&#123; modules: &#123; routerCache, &#125;,&#125;) 定义好进行缓存&#x2F;移除缓存的函数 .&#x2F;util.js 1234567891011import store from &#x27;./store/index.js&#x27;const addRouterCache = routeName =&gt; &#123; store.commit(&#x27;addToInclude&#x27;, routeName) store.commit(&#x27;removeExclude&#x27;, routeName)&#125;const removeRouterCache = routeName =&gt; &#123; store.commit(&#x27;removeInclude&#x27;, routeName) store.commit(&#x27;addToExclude&#x27;, routeName)&#125; 路由要定义好name属性，引用的组件同样要定义相同的name .&#x2F;router.js 12345678910111213import VueRouter from &#x27;vue-router&#x27;const routers = [&#123; path: &#x27;/&#x27;, name: &#x27;Home&#x27;, component: () =&gt; import(&#x27;./views/Home.vue&#x27;),&#125;] const router = new VueRouter(&#123; routes,&#125;)export default router keep-alive的include和exclude实际需要的是组件内的name，设置为一样可以方便使用route的name进行管理 .&#x2F;views&#x2F;Home.vue 123export default &#123; name: &#x27;Home&#x27;&#125; 在全局定义路由守卫，执行缓存相关函数 .&#x2F;main.js 123456789101112131415161718192021222324252627282930313233import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;import VueRouter from &#x27;vue-router&#x27;import &#123; addRouterCache, removeRouterCache &#125; from &#x27;./utils.js&#x27;function _handleRouterCacheFn(to, from) &#123; const routerPushStatus = store.state.routerPushStatus if (routerPushStatus === &#x27;back&#x27;) &#123; store.state.routerAnimate = &#x27;slide-right&#x27; removeRouterCache(from.name) addRouterCache(to.name) &#125; else &#123; store.state.routerAnimate = &#x27;slide-left&#x27; addRouterCache(to.name) // replace模式下将from不进行缓存 if (routerPushStatus === &#x27;replace&#x27;) &#123; removeRouterCache(from.name) &#125; &#125;&#125;// 处理前进刷新，后退缓存的逻辑，beforeEach也可以，不限router.afterEach((to, from) =&gt; &#123; _handleRouterCacheFn(to, from)&#125;)new Vue(&#123; router, store, render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 处理keep-alive的逻辑router-view结构： 注意要将router-view的样式使用定位对齐到同一水平线，mode使用同时进出的动画 .&#x2F;App.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;transition :name=&quot;routerAnimate&quot;&gt; &lt;keep-alive :include=&quot;includedComponents&quot; :exclude=&quot;excludedComponents&quot;&gt; &lt;router-view class=&quot;view-page&quot; :key=&quot;$route.fullPath&quot; /&gt; &lt;/keep-alive&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; computed: &#123; ...mapState(&#123; includedComponents: state =&gt; state.routerCache.includedComponents, excludedComponents: state =&gt; state.routerCache.excludedComponents, &#125;), &#125;,&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.app &#123; overflow: hidden; position: fixed; top: 0; right: 0; bottom: 0; left: 0;&#125;.view-page &#123; position: absolute; overflow: auto; -webkit-overflow-scrolling: touch; top: 0; right: 0; bottom: 0; left: 0; overflow-x: hidden;&#125;.slide-left-enter,.slide-right-leave-to &#123; opacity: 0; transform: translate3d(100%, 0, 0);&#125;.slide-left-leave-to,.slide-right-enter &#123; opacity: 0; transform: translate3d(-100%, 0, 0);&#125;.slide-left-enter-active,.slide-left-leave-active,.slide-right-enter-active,.slide-right-leave-active &#123; transition: 0.4s;&#125;&lt;/style&gt; 自此为止完成了通用的APP使用vue&amp;vue-router&amp;vuex进行的前进刷新，后退缓存的方案，且切换路由对应动画。如果在提交某些订单返回后要删除缓存，使用utils.js里的removeRouterCache函数即可","tags":[{"name":"Vue","slug":"Vue","permalink":"https://sellenite.github.io/tags/Vue/"}]},{"title":"node导出json的key值到excel","date":"2021-05-29T12:38:20.000Z","path":"2021/05/29/node导出json的key值到excel/","text":"进行多语言设定的时候，有时会有导出json的key值到excel，然后在excel进行语言配置，然后再使用excel导出多个国际语言的需求 以下的代码是进行第一步的代码，csv后缀改为xlsx即可 123456/* 此文件用于导出需要做国际化翻译的语句 */const fs = require(&#x27;fs&#x27;);const json = require(&#x27;./lang-en.json&#x27;);const array = Object.keys(json);fs.writeFile(&#x27;need-translate.csv&#x27;, array.join(&#x27;\\r\\n&#x27;), () =&gt; console.log(&#x27;写入完毕&#x27;));","tags":[{"name":"Node","slug":"Node","permalink":"https://sellenite.github.io/tags/Node/"}]},{"title":"下拉放大图片实现","date":"2021-05-29T09:53:12.000Z","path":"2021/05/29/下拉放大图片实现/","text":"先说核心的代码： 12var scale = 1 + Math.abs(scrollY / imgHeight);imgRef.style.transform = `scale($&#123;scale&#125;)` scrollY是监听滚动的垂直距离，向上滑动scrollY为正，向下拉scrollY为负，推荐配合better-scroll插件进行开发 利用scall，进行scrollY和heigth的占比加上1的值，即可平滑放大 以下为demo代码（配合等比图片实现）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;下拉放大图片&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .container &#123; height: 300vh; overflow: hidden; &#125; .img-wrapper &#123; width: 100%; position: relative; padding-top: 56.25%; font-size: 0; background-image: url(&#x27;./157b6e43fbf2b2110279cbfcdd8065380dd78ef4.jpg&#x27;); background-size: cover; transform-origin: top; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;img&quot; class=&quot;img-wrapper&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var imgRef = document.getElementById(&#x27;img&#x27;); document.addEventListener(&#x27;scroll&#x27;, (e) =&gt; &#123; var imgHeight = imgRef.clientHeight; var scrollY = document.documentElement.scrollTop; var scale = 1 + Math.abs(scrollY / imgHeight); scale = Math.min(scale, 1.5) imgRef.style.transform = `scale($&#123;scale&#125;)` &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"}]},{"title":"CSS实现等比图片","date":"2021-05-29T09:39:51.000Z","path":"2021/05/29/CSS实现等比图片/","text":"先说核心的代码： 1padding-top: 222%; // 高比宽长，百分比就是大于100%的 比如要实现一个长宽为580x1289的等比图片展示（等比图片大多数要求在移动端，一些列表或顶部图片的需求），这时候需要使用一个容器包着img，容器的长度为100%，如果要控制长度，需要在容器的外层再包一层，用于长度控制。 最主要的等比是使用padding-top属性。比如我的图片是580x1289，那就要设置padding-top为（1289&#x2F;580*100%）的百分比，就是222%。 以下为demo代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;CSS实现等比图片&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .container &#123; width: 60%; margin: 0 auto; &#125; .img-wrapper &#123; width: 100%; padding-top: 222%; position: relative; &#125; img &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;img-wrapper&quot;&gt; &lt;img src=&quot;./f92fe7014a90f6033bd07f2c2e12b31bb151eda3.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"CSS","slug":"CSS","permalink":"https://sellenite.github.io/tags/CSS/"}]},{"title":"36个JS手写题","date":"2021-05-23T08:58:43.000Z","path":"2021/05/23/36个JS手写题/","text":"该文章为转载，仅用于记录学习 死磕 36 个 JS 手写题（搞懂后，提升真的大）为什么要写这类文章 作为一个程序员，代码能力毋庸置疑是非常非常重要的，就像现在为什么大厂面试基本都问什么 API 怎么实现可见其重要性。我想说的是居然手写这么重要，那我们就必须掌握它，所以文章标题用了死磕，一点也不过分，也希望不被认为是标题党。 作为一个普通前端，我是真的写不出 Promise A+ 规范，但是没关系，我们可以站在巨人的肩膀上，要相信我们现在要走的路，前人都走过，所以可以找找现在社区已经存在的那些优秀的文章，比如工业聚大佬写的 100 行代码实现 Promises&#x2F;A+ 规范，找到这些文章后不是收藏夹吃灰，得找个时间踏踏实实的学，一行一行的磨，直到搞懂为止。我现在就是这么干的。 能收获什么 这篇文章总体上分为 2 类手写题，前半部分可以归纳为是常见需求，后半部分则是对现有技术的实现； 对常用的需求进行手写实现，比如数据类型判断函数、深拷贝等可以直接用于往后的项目中，提高了项目开发效率； 对现有关键字和 API 的实现，可能需要用到别的知识或 API，比如在写 forEach 的时候用到了无符号位右移的操作，平时都不怎么能够接触到这玩意，现在遇到了就可以顺手把它掌握了。所以手写这些实现能够潜移默化的扩展并巩固自己的 JS 基础； 通过写各种测试用例，你会知道各种 API 的边界情况，比如 Promise.all， 你得考虑到传入参数的各种情况，从而加深了对它们的理解及使用； 阅读的时候需要做什么 阅读的时候，你需要把每行代码都看懂，知道它在干什么，为什么要这么写，能写得更好嘛？比如在写图片懒加载的时候，一般我们都是根据当前元素的位置和视口进行判断是否要加载这张图片，普通程序员写到这就差不多完成了。而大佬程序员则是会多考虑一些细节的东西，比如性能如何更优？代码如何更精简？比如 yeyan1996 写的图片懒加载就多考虑了 2 点：比如图片全部加载完成的时候得把事件监听给移除；比如加载完一张图片的时候，得把当前 img 从 imgList 里移除，起到优化内存的作用。 除了读通代码之外，还可以打开 Chrome 的 Script snippet 去写测试用例跑跑代码，做到更好的理解以及使用。 在看了几篇以及写了很多测试用例的前提下，尝试自己手写实现，看看自己到底掌握了多少。条条大路通罗马，你还能有别的方式实现嘛？或者你能写得比别人更好嘛？ 好了，还楞着干啥，开始干活。 数据类型判断typeof 可以正确识别：Undefined、Boolean、Number、String、Symbol、Function 等类型的数据，但是对于其他的都会认为是 object，比如 Null、Date 等，所以通过 typeof 来判断数据类型会不准确。但是可以使用 Object.prototype.toString 实现。 1234567891011function typeOf(obj) &#123;- let res = Object.prototype.toString.call(obj).split(&#x27; &#x27;)[1]- res = res.substring(0, res.length - 1).toLowerCase()- return res// 评论区里提到的更好的写法+ return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()&#125;typeOf([]) // &#x27;array&#x27;typeOf(&#123;&#125;) // &#x27;object&#x27;typeOf(new Date) // &#x27;date&#x27;复制代码 继承原型链继承1234567891011121314function Animal() &#123; this.colors = [&#x27;black&#x27;, &#x27;white&#x27;]&#125;Animal.prototype.getColor = function() &#123; return this.colors&#125;function Dog() &#123;&#125;Dog.prototype = new Animal()let dog1 = new Dog()dog1.colors.push(&#x27;brown&#x27;)let dog2 = new Dog()console.log(dog2.colors) // [&#x27;black&#x27;, &#x27;white&#x27;, &#x27;brown&#x27;]复制代码 原型链继承存在的问题： 问题1：原型中包含的引用类型属性将被所有实例共享； 问题2：子类在实例化的时候不能给父类构造函数传参； 借用构造函数实现继承1234567891011function Animal(name) &#123; this.name = name this.getName = function() &#123; return this.name &#125;&#125;function Dog(name) &#123; Animal.call(this, name)&#125;Dog.prototype = new Animal()复制代码 借用构造函数实现继承解决了原型链继承的 2 个问题：引用类型共享问题以及传参问题。但是由于方法必须定义在构造函数中，所以会导致每次创建子类实例都会创建一遍方法。 组合继承组合继承结合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。 1234567891011121314151617181920function Animal(name) &#123; this.name = name this.colors = [&#x27;black&#x27;, &#x27;white&#x27;]&#125;Animal.prototype.getName = function() &#123; return this.name&#125;function Dog(name, age) &#123; Animal.call(this, name) this.age = age&#125;Dog.prototype = new Animal()Dog.prototype.constructor = Doglet dog1 = new Dog(&#x27;奶昔&#x27;, 2)dog1.colors.push(&#x27;brown&#x27;)let dog2 = new Dog(&#x27;哈赤&#x27;, 1)console.log(dog2) // &#123; name: &quot;哈赤&quot;, colors: [&quot;black&quot;, &quot;white&quot;], age: 1 &#125;复制代码 寄生式组合继承组合继承已经相对完善了，但还是存在问题，它的问题就是调用了 2 次父类构造函数，第一次是在 new Animal()，第二次是在 Animal.call() 这里。 所以解决方案就是不直接调用父类构造函数给子类原型赋值，而是通过创建空函数 F 获取父类原型的副本。 寄生式组合继承写法上和组合继承基本类似，区别是如下这里： 123456789- Dog.prototype = new Animal()- Dog.prototype.constructor = Dog+ function F() &#123;&#125;+ F.prototype = Animal.prototype+ let f = new F()+ f.constructor = Dog+ Dog.prototype = f复制代码 稍微封装下上面添加的代码后： 123456789101112function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;function inheritPrototype(child, parent) &#123; let prototype = object(parent.prototype) prototype.constructor = child child.prototype = prototype&#125;inheritPrototype(Dog, Animal)复制代码 如果你嫌弃上面的代码太多了，还可以基于组合继承的代码改成最简单的寄生式组合继承： 123456- Dog.prototype = new Animal()- Dog.prototype.constructor = Dog+ Dog.prototype = Object.create(Animal.prototype)+ Dog.prototype.constructor = Dog复制代码 class 实现继承123456789101112131415class Animal &#123; constructor(name) &#123; this.name = name &#125; getName() &#123; return this.name &#125;&#125;class Dog extends Animal &#123; constructor(name, age) &#123; super(name) this.age = age &#125;&#125;复制代码 数组去重ES5 实现： 1function unique(arr) &#123; var res = arr.filter(function(item, index, array) &#123; return array.indexOf(item) === index &#125;) return res&#125;复制代码 ES6 实现： 1var unique = arr =&gt; [...new Set(arr)]复制代码 数组扁平化数组扁平化就是将 [1, [2, [3]]] 这种多层的数组拍平成一层 [1, 2, 3]。使用 Array.prototype.flat 可以直接将多层数组拍平成一层： 12[1, [2, [3]]].flat(2) // [1, 2, 3]复制代码 现在就是要实现 flat 这种效果。 ES5 实现：递归。 123456789101112function flatten(arr) &#123; var result = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; if (Array.isArray(arr[i])) &#123; result = result.concat(flatten(arr[i])) &#125; else &#123; result.push(arr[i]) &#125; &#125; return result;&#125;复制代码 ES6 实现： 1234567function flatten(arr) &#123; while (arr.some(item =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr); &#125; return arr;&#125;复制代码 深浅拷贝浅拷贝：只考虑对象类型。 123456789101112function shallowCopy(obj) &#123; if (typeof obj !== &#x27;object&#x27;) return let newObj = obj instanceof Array ? [] : &#123;&#125; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = obj[key] &#125; &#125; return newObj&#125;复制代码 简单版深拷贝：只考虑普通对象属性，不考虑内置对象和函数。 1234567891011function deepClone(obj) &#123; if (typeof obj !== &#x27;object&#x27;) return; var newObj = obj instanceof Array ? [] : &#123;&#125;; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = typeof obj[key] === &#x27;object&#x27; ? deepClone(obj[key]) : obj[key]; &#125; &#125; return newObj;&#125;复制代码 复杂版深克隆：基于简单版的基础上，还考虑了内置对象比如 Date、RegExp 等对象和函数以及解决了循环引用的问题。 123456789101112131415161718192021222324252627const isObject = (target) =&gt; (typeof target === &quot;object&quot; || typeof target === &quot;function&quot;) &amp;&amp; target !== null;function deepClone(target, map = new WeakMap()) &#123; if (map.get(target)) &#123; return target; &#125; // 获取当前值的构造函数：获取它的类型 let constructor = target.constructor; // 检测当前对象target是否与正则、日期格式对象匹配 if (/^(RegExp|Date)$/i.test(constructor.name)) &#123; // 创建一个新的特殊对象(正则类/日期类)的实例 return new constructor(target); &#125; if (isObject(target)) &#123; map.set(target, true); // 为循环引用的对象做标记 const cloneTarget = Array.isArray(target) ? [] : &#123;&#125;; for (let prop in target) &#123; if (target.hasOwnProperty(prop)) &#123; cloneTarget[prop] = deepClone(target[prop], map); &#125; &#125; return cloneTarget; &#125; else &#123; return target; &#125;&#125;复制代码 事件总线（发布订阅模式）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class EventEmitter &#123; constructor() &#123; this.cache = &#123;&#125; &#125; on(name, fn) &#123; if (this.cache[name]) &#123; this.cache[name].push(fn) &#125; else &#123; this.cache[name] = [fn] &#125; &#125; off(name, fn) &#123; let tasks = this.cache[name] if (tasks) &#123; const index = tasks.findIndex(f =&gt; f === fn || f.callback === fn) if (index &gt;= 0) &#123; tasks.splice(index, 1) &#125; &#125; &#125; emit(name, once = false, ...args) &#123; if (this.cache[name]) &#123; // 创建副本，如果回调函数内继续注册相同事件，会造成死循环 let tasks = this.cache[name].slice() for (let fn of tasks) &#123; fn(...args) &#125; if (once) &#123; delete this.cache[name] &#125; &#125; &#125;&#125;// 测试let eventBus = new EventEmitter()let fn1 = function(name, age) &#123; console.log(`$&#123;name&#125; $&#123;age&#125;`)&#125;let fn2 = function(name, age) &#123; console.log(`hello, $&#123;name&#125; $&#123;age&#125;`)&#125;eventBus.on(&#x27;aaa&#x27;, fn1)eventBus.on(&#x27;aaa&#x27;, fn2)eventBus.emit(&#x27;aaa&#x27;, false, &#x27;布兰&#x27;, 12)// &#x27;布兰 12&#x27;// &#x27;hello, 布兰 12&#x27;复制代码 解析 URL 参数为对象123456789101112131415161718192021222324function parseParam(url) &#123; const paramsStr = /.+\\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来 const paramsArr = paramsStr.split(&#x27;&amp;&#x27;); // 将字符串以 &amp; 分割后存到数组中 let paramsObj = &#123;&#125;; // 将 params 存到对象中 paramsArr.forEach(param =&gt; &#123; if (/=/.test(param)) &#123; // 处理有 value 的参数 let [key, val] = param.split(&#x27;=&#x27;); // 分割 key 和 value val = decodeURIComponent(val); // 解码 val = /^\\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字 if (paramsObj.hasOwnProperty(key)) &#123; // 如果对象有 key，则添加一个值 paramsObj[key] = [].concat(paramsObj[key], val); &#125; else &#123; // 如果对象没有这个 key，创建 key 并设置值 paramsObj[key] = val; &#125; &#125; else &#123; // 处理没有 value 的参数 paramsObj[param] = true; &#125; &#125;) return paramsObj;&#125;复制代码 字符串模板12345678910function render(template, data) &#123; const reg = /\\&#123;\\&#123;(\\w+)\\&#125;\\&#125;/; // 模板字符串正则 if (reg.test(template)) &#123; // 判断模板里是否有模板字符串 const name = reg.exec(template)[1]; // 查找当前模板里第一个模板字符串的字段 template = template.replace(reg, data[name]); // 将第一个模板字符串渲染 return render(template, data); // 递归的渲染并返回渲染后的结构 &#125; return template; // 如果模板没有模板字符串直接返回&#125;复制代码 测试： 1234567let template = &#x27;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&#x27;;let person = &#123; name: &#x27;布兰&#x27;, age: 12&#125;render(template, person); // 我是布兰，年龄12，性别undefined复制代码 图片懒加载与普通的图片懒加载不同，如下这个多做了 2 个精心处理： 图片全部加载完成后移除事件监听； 加载完的图片，从 imgList 移除； 1234567891011121314151617181920212223242526272829let imgList = [...document.querySelectorAll(&#x27;img&#x27;)]let length = imgList.length// 修正错误，需要加上自执行- const imgLazyLoad = function() &#123;+ const imgLazyLoad = (function() &#123; let count = 0 return function() &#123; let deleteIndexList = [] imgList.forEach((img, index) =&gt; &#123; let rect = img.getBoundingClientRect() if (rect.top &lt; window.innerHeight) &#123; img.src = img.dataset.src deleteIndexList.push(index) count++ if (count === length) &#123; document.removeEventListener(&#x27;scroll&#x27;, imgLazyLoad) &#125; &#125; &#125;) imgList = imgList.filter((img, index) =&gt; !deleteIndexList.includes(index)) &#125;- &#125;+ &#125;)()// 这里最好加上防抖处理document.addEventListener(&#x27;scroll&#x27;, imgLazyLoad)复制代码 参考：图片懒加载 函数防抖触发高频事件 N 秒后只会执行一次，如果 N 秒内事件再次触发，则会重新计时。 简单版：函数内部支持使用 this 和 event 对象； 123456789101112function debounce(func, wait) &#123; var timeout; return function () &#123; var context = this; var args = arguments; clearTimeout(timeout) timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125;&#125;复制代码 使用： 1234567var node = document.getElementById(&#x27;layout&#x27;)function getUserAction(e) &#123; console.log(this, e) // 分别打印：node 这个节点 和 MouseEvent node.innerHTML = count++;&#125;;node.onmousemove = debounce(getUserAction, 1000)复制代码 最终版：除了支持 this 和 event 外，还支持以下功能： 支持立即执行； 函数可能有返回值； 支持取消功能； 12345678910111213141516171819202122232425262728293031function debounce(func, wait, immediate) &#123; var timeout, result; var debounced = function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; // 如果已经执行过，不再执行 var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) result = func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; return result; &#125;; debounced.cancel = function() &#123; clearTimeout(timeout); timeout = null; &#125;; return debounced;&#125;复制代码 使用： 1234567var setUseAction = debounce(getUserAction, 10000, true);// 使用防抖node.onmousemove = setUseAction// 取消防抖setUseAction.cancel()复制代码 参考：JavaScript专题之跟着underscore学防抖 函数节流触发高频事件，且 N 秒内只执行一次。 简单版：使用时间戳来实现，立即执行一次，然后每 N 秒执行一次。 123456789101112131415function throttle(func, wait) &#123; var context, args; var previous = 0; return function() &#123; var now = +new Date(); context = this; args = arguments; if (now - previous &gt; wait) &#123; func.apply(context, args); previous = now; &#125; &#125;&#125;复制代码 最终版：支持取消节流；另外通过传入第三个参数，options.leading 来表示是否可以立即执行一次，opitons.trailing 表示结束调用的时候是否还要执行一次，默认都是 true。 注意设置的时候不能同时将 leading 或 trailing 设置为 false。 123456789101112131415161718192021222324252627282930313233343536373839function throttle(func, wait, options) &#123; var timeout, context, args, result; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; previous = options.leading === false ? 0 : new Date().getTime(); timeout = null; func.apply(context, args); if (!timeout) context = args = null; &#125;; var throttled = function() &#123; var now = new Date().getTime(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; &#125;; throttled.cancel = function() &#123; clearTimeout(timeout); previous = 0; timeout = null; &#125; return throttled;&#125;复制代码 节流的使用就不拿代码举例了，参考防抖的写就行。 参考：JavaScript专题之跟着 underscore 学节流 函数柯里化什么叫函数柯里化？其实就是将使用多个参数的函数转换成一系列使用一个参数的函数的技术。还不懂？来举个例子。 1234567function add(a, b, c) &#123; return a + b + c&#125;add(1, 2, 3)let addCurry = curry(add)addCurry(1)(2)(3)复制代码 现在就是要实现 curry 这个函数，使函数从一次调用传入多个参数变成多次调用每次传一个参数。 12345678function curry(fn) &#123; let judge = (...args) =&gt; &#123; if (args.length == fn.length) return fn(...args) return (...arg) =&gt; judge(...args, ...arg) &#125; return judge&#125;复制代码 偏函数什么是偏函数？偏函数就是将一个 n 参的函数转换成固定 x 参的函数，剩余参数（n - x）将在下次调用全部传入。举个例子： 1function add(a, b, c) &#123; return a + b + c&#125;let partialAdd = partial(add, 1)partialAdd(2, 3)复制代码 发现没有，其实偏函数和函数柯里化有点像，所以根据函数柯里化的实现，能够能很快写出偏函数的实现： 1function partial(fn, ...args) &#123; return (...arg) =&gt; &#123; return fn(...args, ...arg) &#125;&#125;复制代码 如上这个功能比较简单，现在我们希望偏函数能和柯里化一样能实现占位功能，比如： 123456function clg(a, b, c) &#123; console.log(a, b, c)&#125;let partialClg = partial(clg, &#x27;_&#x27;, 2)partialClg(1, 3) // 依次打印：1, 2, 3复制代码 _ 占的位其实就是 1 的位置。相当于：partial(clg, 1, 2)，然后 partialClg(3)。明白了原理，我们就来写实现： 1234567function partial(fn, ...args) &#123; return (...arg) =&gt; &#123; args[index] = return fn(...args, ...arg) &#125;&#125;复制代码 JSONPJSONP 核心原理：script 标签不受同源策略约束，所以可以用来进行跨域请求，优点是兼容性好，但是只能用于 GET 请求； 12345678910111213141516171819202122const jsonp = (&#123; url, params, callbackName &#125;) =&gt; &#123; const generateUrl = () =&gt; &#123; let dataSrc = &#x27;&#x27; for (let key in params) &#123; if (params.hasOwnProperty(key)) &#123; dataSrc += `$&#123;key&#125;=$&#123;params[key]&#125;&amp;` &#125; &#125; dataSrc += `callback=$&#123;callbackName&#125;` return `$&#123;url&#125;?$&#123;dataSrc&#125;` &#125; return new Promise((resolve, reject) =&gt; &#123; const scriptEle = document.createElement(&#x27;script&#x27;) scriptEle.src = generateUrl() document.body.appendChild(scriptEle) window[callbackName] = data =&gt; &#123; resolve(data) document.removeChild(scriptEle) &#125; &#125;)&#125;复制代码 AJAX1const getJSON = function(url) &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&#x27;Mscrosoft.XMLHttp&#x27;); xhr.open(&#x27;GET&#x27;, url, false); xhr.setRequestHeader(&#x27;Accept&#x27;, &#x27;application/json&#x27;); xhr.onreadystatechange = function() &#123; if (xhr.readyState !== 4) return; if (xhr.status === 200 || xhr.status === 304) &#123; resolve(xhr.responseText); &#125; else &#123; reject(new Error(xhr.responseText)); &#125; &#125; xhr.send(); &#125;)&#125;复制代码 实现数组原型方法forEach123456789101112131415161718Array.prototype.forEach2 = function(callback, thisArg) &#123; if (this == null) &#123; throw new TypeError(&#x27;this is null or not defined&#x27;) &#125; if (typeof callback !== &quot;function&quot;) &#123; throw new TypeError(callback + &#x27; is not a function&#x27;) &#125; const O = Object(this) // this 就是当前的数组 const len = O.length &gt;&gt;&gt; 0 // 后面有解释 let k = 0 while (k &lt; len) &#123; if (k in O) &#123; callback.call(thisArg, O[k], k, O); &#125; k++; &#125;&#125;复制代码 参考：forEach#polyfill O.length &gt;&gt;&gt; 0 是什么操作？就是无符号右移 0 位，那有什么意义嘛？就是为了保证转换后的值为正整数。其实底层做了 2 层转换，第一是非 number 转成 number 类型，第二是将 number 转成 Uint32 类型。感兴趣可以阅读 something &gt;&gt;&gt; 0是什么意思?。 map基于 forEach 的实现能够很容易写出 map 的实现： 12345678910111213141516171819202122- Array.prototype.forEach2 = function(callback, thisArg) &#123;+ Array.prototype.map2 = function(callback, thisArg) &#123; if (this == null) &#123; throw new TypeError(&#x27;this is null or not defined&#x27;) &#125; if (typeof callback !== &quot;function&quot;) &#123; throw new TypeError(callback + &#x27; is not a function&#x27;) &#125; const O = Object(this) const len = O.length &gt;&gt;&gt; 0- let k = 0+ let k = 0, res = [] while (k &lt; len) &#123; if (k in O) &#123;- callback.call(thisArg, O[k], k, O);+ res[k] = callback.call(thisArg, O[k], k, O); &#125; k++; &#125;+ return res&#125;复制代码 filter同样，基于 forEach 的实现能够很容易写出 filter 的实现： 123456789101112131415161718192021222324- Array.prototype.forEach2 = function(callback, thisArg) &#123;+ Array.prototype.filter2 = function(callback, thisArg) &#123; if (this == null) &#123; throw new TypeError(&#x27;this is null or not defined&#x27;) &#125; if (typeof callback !== &quot;function&quot;) &#123; throw new TypeError(callback + &#x27; is not a function&#x27;) &#125; const O = Object(this) const len = O.length &gt;&gt;&gt; 0- let k = 0+ let k = 0, res = [] while (k &lt; len) &#123; if (k in O) &#123;- callback.call(thisArg, O[k], k, O);+ if (callback.call(thisArg, O[k], k, O)) &#123;+ res.push(O[k]) + &#125; &#125; k++; &#125;+ return res&#125;复制代码 some同样，基于 forEach 的实现能够很容易写出 some 的实现： 1234567891011121314151617181920212223- Array.prototype.forEach2 = function(callback, thisArg) &#123;+ Array.prototype.some2 = function(callback, thisArg) &#123; if (this == null) &#123; throw new TypeError(&#x27;this is null or not defined&#x27;) &#125; if (typeof callback !== &quot;function&quot;) &#123; throw new TypeError(callback + &#x27; is not a function&#x27;) &#125; const O = Object(this) const len = O.length &gt;&gt;&gt; 0 let k = 0 while (k &lt; len) &#123; if (k in O) &#123;- callback.call(thisArg, O[k], k, O);+ if (callback.call(thisArg, O[k], k, O)) &#123;+ return true+ &#125; &#125; k++; &#125;+ return false&#125;复制代码 reduce1234567891011121314151617181920212223242526272829303132Array.prototype.reduce2 = function(callback, initialValue) &#123; if (this == null) &#123; throw new TypeError(&#x27;this is null or not defined&#x27;) &#125; if (typeof callback !== &quot;function&quot;) &#123; throw new TypeError(callback + &#x27; is not a function&#x27;) &#125; const O = Object(this) const len = O.length &gt;&gt;&gt; 0 let k = 0, acc if (arguments.length &gt; 1) &#123; acc = initialValue &#125; else &#123; // 没传入初始值的时候，取数组中第一个非 empty 的值为初始值 while (k &lt; len &amp;&amp; !(k in O)) &#123; k++ &#125; if (k &gt; len) &#123; throw new TypeError( &#x27;Reduce of empty array with no initial value&#x27; ); &#125; acc = O[k++] &#125; while (k &lt; len) &#123; if (k in O) &#123; acc = callback(acc, O[k], k, O) &#125; k++ &#125; return acc&#125;复制代码 实现函数原型方法call使用一个指定的 this 值和一个或多个参数来调用一个函数。 实现要点： this 可能传入 null； 传入不固定个数的参数； 函数可能有返回值； 1Function.prototype.call2 = function (context) &#123; var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push(&#x27;arguments[&#x27; + i + &#x27;]&#x27;); &#125; var result = eval(&#x27;context.fn(&#x27; + args +&#x27;)&#x27;); delete context.fn return result;&#125;复制代码 applyapply 和 call 一样，唯一的区别就是 call 是传入不固定个数的参数，而 apply 是传入一个数组。 实现要点： this 可能传入 null； 传入一个数组； 函数可能有返回值； 1Function.prototype.apply2 = function (context, arr) &#123; var context = context || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push(&#x27;arr[&#x27; + i + &#x27;]&#x27;); &#125; result = eval(&#x27;context.fn(&#x27; + args + &#x27;)&#x27;) &#125; delete context.fn return result;&#125;复制代码 bindbind 方法会创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 实现要点： bind() 除了 this 外，还可传入多个参数； bing 创建的新函数可能传入多个参数； 新函数可能被当做构造函数调用； 函数可能有返回值； 1Function.prototype.bind2 = function (context) &#123; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () &#123;&#125;; var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); &#125; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125;复制代码 实现 new 关键字new 运算符用来创建用户自定义的对象类型的实例或者具有构造函数的内置对象的实例。 实现要点： new 会产生一个新对象； 新对象需要能够访问到构造函数的属性，所以需要重新指定它的原型； 构造函数可能会显示返回； 1function objectFactory() &#123; var obj = new Object() Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; var ret = Constructor.apply(obj, arguments); // ret || obj 这里这么写考虑了构造函数显示返回 null 的情况 return typeof ret === &#x27;object&#x27; ? ret || obj : obj;&#125;;复制代码 使用： 1234567function person(name, age) &#123; this.name = name this.age = age&#125;let p = objectFactory(person, &#x27;布兰&#x27;, 12)console.log(p) // &#123; name: &#x27;布兰&#x27;, age: 12 &#125;复制代码 实现 instanceof 关键字instanceof 就是判断构造函数的 prototype 属性是否出现在实例的原型链上。 1234567891011function instanceOf(left, right) &#123; let proto = left.__proto__ while (true) &#123; if (proto === null) return false if (proto === right.prototype) &#123; return true &#125; proto = proto.__proto__ &#125;&#125;复制代码 上面的 left.proto 这种写法可以换成 Object.getPrototypeOf(left)。 实现 Object.createObject.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 12345678910111213141516171819Object.create2 = function(proto, propertyObject = undefined) &#123; if (typeof proto !== &#x27;object&#x27; &amp;&amp; typeof proto !== &#x27;function&#x27;) &#123; throw new TypeError(&#x27;Object prototype may only be an Object or null.&#x27;) if (propertyObject == null) &#123; new TypeError(&#x27;Cannot convert undefined or null to object&#x27;) &#125; function F() &#123;&#125; F.prototype = proto const obj = new F() if (propertyObject != undefined) &#123; Object.defineProperties(obj, propertyObject) &#125; if (proto === null) &#123; // 创建一个没有原型对象的对象，Object.create(null) obj.__proto__ = null &#125; return obj&#125;复制代码 实现 Object.assign1Object.assign2 = function(target, ...source) &#123; if (target == null) &#123; throw new TypeError(&#x27;Cannot convert undefined or null to object&#x27;) &#125; let ret = Object(target) source.forEach(function(obj) &#123; if (obj != null) &#123; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; ret[key] = obj[key] &#125; &#125; &#125; &#125;) return ret&#125;复制代码 实现 JSON.stringifyJSON.stringify([, replacer [, space]) 方法是将一个 JavaScript 值(对象或者数组)转换为一个 JSON 字符串。此处模拟实现，不考虑可选的第二个参数 replacer 和第三个参数 space，如果对这两个参数的作用还不了解，建议阅读 MDN 文档。 基本数据类型： undefined 转换之后仍是 undefined(类型也是 undefined) boolean 值转换之后是字符串 “false”&#x2F;“true” number 类型(除了 NaN 和 Infinity)转换之后是字符串类型的数值 symbol 转换之后是 undefined null 转换之后是字符串 “null” string 转换之后仍是string NaN 和 Infinity 转换之后是字符串 “null” 函数类型：转换之后是 undefined 如果是对象类型(非函数) 如果是一个数组：如果属性值中出现了 undefined、任意的函数以及 symbol，转换成字符串 “null” ； 如果是 RegExp 对象：返回 {} (类型是 string)； 如果是 Date 对象，返回 Date 的 toJSON 字符串值； 如果是普通对象； 如果有 toJSON() 方法，那么序列化 toJSON() 的返回值。 如果属性值中出现了 undefined、任意的函数以及 symbol 值，忽略。 所有以 symbol 为属性键的属性都会被完全忽略掉。 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。 1function jsonStringify(data) &#123; let dataType = typeof data; if (dataType !== &#x27;object&#x27;) &#123; let result = data; //data 可能是 string/number/null/undefined/boolean if (Number.isNaN(data) || data === Infinity) &#123; //NaN 和 Infinity 序列化返回 &quot;null&quot; result = &quot;null&quot;; &#125; else if (dataType === &#x27;function&#x27; || dataType === &#x27;undefined&#x27; || dataType === &#x27;symbol&#x27;) &#123; //function 、undefined 、symbol 序列化返回 undefined return undefined; &#125; else if (dataType === &#x27;string&#x27;) &#123; result = &#x27;&quot;&#x27; + data + &#x27;&quot;&#x27;; &#125; //boolean 返回 String() return String(result); &#125; else if (dataType === &#x27;object&#x27;) &#123; if (data === null) &#123; return &quot;null&quot; &#125; else if (data.toJSON &amp;&amp; typeof data.toJSON === &#x27;function&#x27;) &#123; return jsonStringify(data.toJSON()); &#125; else if (data instanceof Array) &#123; let result = []; //如果是数组 //toJSON 方法可以存在于原型链中 data.forEach((item, index) =&gt; &#123; if (typeof item === &#x27;undefined&#x27; || typeof item === &#x27;function&#x27; || typeof item === &#x27;symbol&#x27;) &#123; result[index] = &quot;null&quot;; &#125; else &#123; result[index] = jsonStringify(item); &#125; &#125;); result = &quot;[&quot; + result + &quot;]&quot;; return result.replace(/&#x27;/g, &#x27;&quot;&#x27;); &#125; else &#123; //普通对象 /** * 循环引用抛错(暂未检测，循环引用时，堆栈溢出) * symbol key 忽略 * undefined、函数、symbol 为属性值，被忽略 */ let result = []; Object.keys(data).forEach((item, index) =&gt; &#123; if (typeof item !== &#x27;symbol&#x27;) &#123; //key 如果是symbol对象，忽略 if (data[item] !== undefined &amp;&amp; typeof data[item] !== &#x27;function&#x27; &amp;&amp; typeof data[item] !== &#x27;symbol&#x27;) &#123; //键值如果是 undefined、函数、symbol 为属性值，忽略 result.push(&#x27;&quot;&#x27; + item + &#x27;&quot;&#x27; + &quot;:&quot; + jsonStringify(data[item])); &#125; &#125; &#125;); return (&quot;&#123;&quot; + result + &quot;&#125;&quot;).replace(/&#x27;/g, &#x27;&quot;&#x27;); &#125; &#125;&#125;复制代码 参考：实现 JSON.stringify 实现 JSON.parse介绍 2 种方法实现： eval 实现； new Function 实现； eval 实现第一种方式最简单，也最直观，就是直接调用 eval，代码如下： 1var json = &#x27;&#123;&quot;a&quot;:&quot;1&quot;, &quot;b&quot;:2&#125;&#x27;;var obj = eval(&quot;(&quot; + json + &quot;)&quot;); // obj 就是 json 反序列化之后得到的对象复制代码 但是直接调用 eval 会存在安全问题，如果数据中可能不是 json 数据，而是可执行的 JavaScript 代码，那很可能会造成 XSS 攻击。因此，在调用 eval 之前，需要对数据进行校验。 1var rx_one = /^[\\],:&#123;&#125;\\s]*$/;var rx_two = /\\\\(?:[&quot;\\\\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g;var rx_three = /&quot;[^&quot;\\\\\\n\\r]*&quot;|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;var rx_four = /(?:^|:|,)(?:\\s*\\[)+/g;if ( rx_one.test( json.replace(rx_two, &quot;@&quot;) .replace(rx_three, &quot;]&quot;) .replace(rx_four, &quot;&quot;) )) &#123; var obj = eval(&quot;(&quot; +json + &quot;)&quot;);&#125;复制代码 参考：JSON.parse 三种实现方式 new Function 实现Function 与 eval 有相同的字符串参数特性。 1var json = &#x27;&#123;&quot;name&quot;:&quot;小姐姐&quot;, &quot;age&quot;:20&#125;&#x27;;var obj = (new Function(&#x27;return &#x27; + json))();复制代码 实现 Promise实现 Promise 需要完全读懂 Promise A+ 规范，不过从总体的实现上看，有如下几个点需要考虑到： then 需要支持链式调用，所以得返回一个新的 Promise； 处理异步问题，所以得先用 onResolvedCallbacks 和 onRejectedCallbacks 分别把成功和失败的回调存起来； 为了让链式调用正常进行下去，需要判断 onFulfilled 和 onRejected 的类型； onFulfilled 和 onRejected 需要被异步调用，这里用 setTimeout 模拟异步； 处理 Promise 的 resolve； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141const PENDING = &#x27;pending&#x27;;const FULFILLED = &#x27;fulfilled&#x27;;const REJECTED = &#x27;rejected&#x27;;class Promise &#123; constructor(executor) &#123; this.status = PENDING; this.value = undefined; this.reason = undefined; this.onResolvedCallbacks = []; this.onRejectedCallbacks = []; let resolve = (value) = &gt; &#123; if (this.status === PENDING) &#123; this.status = FULFILLED; this.value = value; this.onResolvedCallbacks.forEach((fn) = &gt; fn()); &#125; &#125;; let reject = (reason) = &gt; &#123; if (this.status === PENDING) &#123; this.status = REJECTED; this.reason = reason; this.onRejectedCallbacks.forEach((fn) = &gt; fn()); &#125; &#125;; try &#123; executor(resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125; then(onFulfilled, onRejected) &#123; // 解决 onFufilled，onRejected 没有传值的问题 onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : (v) = &gt; v; // 因为错误的值要让后面访问到，所以这里也要抛出错误，不然会在之后 then 的 resolve 中捕获 onRejected = typeof onRejected === &quot;function&quot; ? onRejected : (err) = &gt; &#123; throw err; &#125;; // 每次调用 then 都返回一个新的 promise let promise2 = new Promise((resolve, reject) = &gt; &#123; if (this.status === FULFILLED) &#123; //Promise/A+ 2.2.4 --- setTimeout setTimeout(() = &gt; &#123; try &#123; let x = onFulfilled(this.value); // x可能是一个proimise resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125; if (this.status === REJECTED) &#123; //Promise/A+ 2.2.3 setTimeout(() = &gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125; if (this.status === PENDING) &#123; this.onResolvedCallbacks.push(() = &gt; &#123; setTimeout(() = &gt; &#123; try &#123; let x = onFulfilled(this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); this.onRejectedCallbacks.push(() = &gt; &#123; setTimeout(() = &gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); &#125; &#125;); return promise2; &#125;&#125;const resolvePromise = (promise2, x, resolve, reject) = &gt; &#123; // 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise Promise/A+ 2.3.1 if (promise2 === x) &#123; return reject( new TypeError(&quot;Chaining cycle detected for promise #&lt;Promise&gt;&quot;)); &#125; // Promise/A+ 2.3.3.3.3 只能调用一次 let called; // 后续的条件要严格判断 保证代码能和别的库一起使用 if ((typeof x === &quot;object&quot; &amp;&amp; x != null) || typeof x === &quot;function&quot;) &#123; try &#123; // 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候） Promise/A+ 2.3.3.1 let then = x.then; if (typeof then === &quot;function&quot;) &#123; // 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty Promise/A+ 2.3.3.3 then.call( x, (y) = &gt; &#123; // 根据 promise 的状态决定是成功还是失败 if (called) return; called = true; // 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1 resolvePromise(promise2, y, resolve, reject); &#125;, (r) = &gt; &#123; // 只要失败就失败 Promise/A+ 2.3.3.3.2 if (called) return; called = true; reject(r); &#125;); &#125; else &#123; // 如果 x.then 是个普通值就直接返回 resolve 作为结果 Promise/A+ 2.3.3.4 resolve(x); &#125; &#125; catch (e) &#123; // Promise/A+ 2.3.3.2 if (called) return; called = true; reject(e); &#125; &#125; else &#123; // 如果 x 是个普通值就直接返回 resolve 作为结果 Promise/A+ 2.3.4 resolve(x); &#125;&#125;;复制代码 Promise 写完之后可以通过 promises-aplus-tests 这个包对我们写的代码进行测试，看是否符合 A+ 规范。不过测试前还得加一段代码： 12345678910111213// promise.js// 这里是上面写的 Promise 全部代码Promise.defer = Promise.deferred = function () &#123; let dfd = &#123;&#125; dfd.promise = new Promise((resolve,reject)=&gt;&#123; dfd.resolve = resolve; dfd.reject = reject; &#125;); return dfd;&#125;module.exports = Promise;复制代码 全局安装： 12npm i promises-aplus-tests -g复制代码 终端下执行验证命令： 12promises-aplus-tests promise.js复制代码 上面写的代码可以顺利通过全部 872 个测试用例。 参考： BAT前端经典面试问题：史上最最最详细的手写Promise教程 100 行代码实现 Promises&#x2F;A+ 规范 Promise.resolvePromsie.resolve(value) 可以将任何值转成值为 value 状态是 fulfilled 的 Promise，但如果传入的值本身是 Promise 则会原样返回它。 1Promise.resolve = function(value) &#123; // 如果是 Promsie，则直接输出它 if(value instanceof Promise)&#123; return value &#125; return new Promise(resolve =&gt; resolve(value))&#125;复制代码 参考：深入理解 Promise Promise.reject和 Promise.resolve() 类似，Promise.reject() 会实例化一个 rejected 状态的 Promise。但与 Promise.resolve() 不同的是，如果给 Promise.reject() 传递一个 Promise 对象，则这个对象会成为新 Promise 的值。 1Promise.reject = function(reason) &#123; return new Promise((resolve, reject) =&gt; reject(reason))&#125;复制代码 Promise.allPromise.all 的规则是这样的： 传入的所有 Promsie 都是 fulfilled，则返回由他们的值组成的，状态为 fulfilled 的新 Promise； 只要有一个 Promise 是 rejected，则返回 rejected 状态的新 Promsie，且它的值是第一个 rejected 的 Promise 的值； 只要有一个 Promise 是 pending，则返回一个 pending 状态的新 Promise； 1234567891011121314151617Promise.all = function(promiseArr) &#123; let index = 0, result = [] return new Promise((resolve, reject) =&gt; &#123; promiseArr.forEach((p, i) =&gt; &#123; Promise.resolve(p).then(val =&gt; &#123; index++ result[i] = val if (index === promiseArr.length) &#123; resolve(result) &#125; &#125;, err =&gt; &#123; reject(err) &#125;) &#125;) &#125;)&#125;复制代码 Promise.racePromise.race 会返回一个由所有可迭代实例中第一个 fulfilled 或 rejected 的实例包装后的新实例。 123456789101112Promise.race = function(promiseArr) &#123; return new Promise((resolve, reject) =&gt; &#123; promiseArr.forEach(p =&gt; &#123; Promise.resolve(p).then(val =&gt; &#123; resolve(val) &#125;, err =&gt; &#123; rejecte(err) &#125;) &#125;) &#125;)&#125;复制代码 Promise.allSettledPromise.allSettled 的规则是这样： 所有 Promise 的状态都变化了，那么新返回一个状态是 fulfilled 的 Promise，且它的值是一个数组，数组的每项由所有 Promise 的值和状态组成的对象； 如果有一个是 pending 的 Promise，则返回一个状态是 pending 的新实例； 1234567891011121314151617181920212223242526Promise.allSettled = function(promiseArr) &#123; let result = [] return new Promise((resolve, reject) =&gt; &#123; promiseArr.forEach((p, i) =&gt; &#123; Promise.resolve(p).then(val =&gt; &#123; result.push(&#123; status: &#x27;fulfilled&#x27;, value: val &#125;) if (result.length === promiseArr.length) &#123; resolve(result) &#125; &#125;, err =&gt; &#123; result.push(&#123; status: &#x27;rejected&#x27;, reason: err &#125;) if (result.length === promiseArr.length) &#123; resolve(result) &#125; &#125;) &#125;) &#125;) &#125;复制代码 Promise.anyPromise.any 的规则是这样： 空数组或者所有 Promise 都是 rejected，则返回状态是 rejected 的新 Promsie，且值为 AggregateError 的错误； 只要有一个是 fulfilled 状态的，则返回第一个是 fulfilled 的新实例； 其他情况都会返回一个 pending 的新实例； 123456789101112131415161718Promise.any = function(promiseArr) &#123; let index = 0 return new Promise((resolve, reject) =&gt; &#123; if (promiseArr.length === 0) return promiseArr.forEach((p, i) =&gt; &#123; Promise.resolve(p).then(val =&gt; &#123; resolve(val) &#125;, err =&gt; &#123; index++ if (index === promiseArr.length) &#123; reject(new AggregateError(&#x27;All promises were rejected&#x27;)) &#125; &#125;) &#125;) &#125;)&#125;复制代码","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"}]},{"title":"掘金spam沸点脚本","date":"2021-05-22T11:17:40.000Z","path":"2021/05/22/掘金spam沸点脚本/","text":"用于攻击某些发言有问题的用户，刷他沸点评论，将textarea放到浏览器里，放上垃圾话后，在浏览器执行脚本（开小号执行，会被掘金检测到后然后禁言，慎用） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164// userId从用户主页获取// &lt;textarea id=&quot;testTextarea&quot;&gt;&lt;/textarea&gt; // 垃圾话填装var get_item_id_url = &#x27;https://api.juejin.cn/content_api/v1/short_msg/query_list&#x27;; // 获取用户最新一条数据接口var comment_api_url = &#x27;https://api.juejin.cn/interact_api/v1/comment/publish&#x27;; // 发布评论接口var comments = testTextarea.value.replace(/Sellenite/g, &#x27;&#x27;).split(&#x27;\\n&#x27;);function ajax(options) &#123; options = options || &#123;&#125;; options.data = options.data || &#123;&#125;; // 请求方式，默认是GET options.type = options.type || &#x27;GET&#x27;; // 避免有特殊字符，必须格式化传输数据 options.data = JSON.stringify(options.data); var xhr = null; // 实例化XMLHttpRequest对象 if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else &#123; // IE6及其以下版本 xhr = new ActiveXObjcet(&#x27;Microsoft.XMLHTTP&#x27;); &#125;; // 监听事件，只要 readyState 的值变化，就会调用 readystatechange 事件 xhr.onreadystatechange = function() &#123; // readyState属性表示请求/响应过程的当前活动阶段，4为完成，已经接收到全部响应数据 if (xhr.readyState == 4) &#123; var status = xhr.status; // status：响应的HTTP状态码，以2开头的都是成功 if (status &gt;= 200 &amp;&amp; status &lt; 300) &#123; var response = &#x27;&#x27;; // 判断接受数据的内容类型 var type = xhr.getResponseHeader(&#x27;Content-type&#x27;); if (type.indexOf(&#x27;xml&#x27;) !== -1 &amp;&amp; xhr.responseXML) &#123; response = xhr.responseXML; //Document对象响应 &#125; else if (type === &#x27;application/json&#x27;) &#123; response = JSON.parse(xhr.responseText); //JSON响应 &#125; else &#123; response = xhr.responseText; //字符串响应 &#125;; // 成功回调函数 options.success &amp;&amp; options.success(response); &#125; else &#123; options.error &amp;&amp; options.error(status); &#125; &#125;; &#125;; if (options.type === &#x27;GET&#x27;) &#123; // 三个参数：请求方式、请求地址(get方式时，传输数据是加在地址后的)、是否异步请求(同步请求的情况极少)； xhr.open(options.type, options.url, true); xhr.send(null); &#125; else &#123; // 连接和传输数据 xhr.open(options.type, options.url, true); //必须，设置提交时的内容类型 xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json; charset=UTF-8&#x27;); // 传输数据 xhr.send(options.data); &#125;&#125;function randomNum(minNum, maxNum) &#123; switch (arguments.length) &#123; case 1: return parseInt(Math.random() * minNum + 1, 10); break; case 2: return parseInt(Math.random() * (maxNum - minNum + 1) + minNum, 10); break; default: return 0; break; &#125;&#125;// 使用循环循环获取所有沸点数async function getAllItemIds(requestUserId) &#123; function rq(cursor = 0) &#123; return new Promise((resolve, reject) =&gt; &#123; ajax(&#123; url: get_item_id_url, // 请求地址 type: &#x27;POST&#x27;, // 请求类型，默认&quot;GET&quot;，还可以是&quot;POST&quot; data: &#123; cursor: String(cursor), // 页码开始 limit: 100, // 每次请求多少大小 sort_type: 4, // 列表类型，4为沸点 user_id: requestUserId &#125;, success: function(res) &#123; // 请求成功的回调函数 res = JSON.parse(res); var list = res.data; resolve(&#123; list: list || [], has_more: res.has_more &#125;); &#125;, error: function(error) &#123; reject(error); &#125; &#125;); &#125;) &#125; let cursor = 0; let arr = []; let res; do &#123; res = await rq(cursor); arr = [...arr, ...res.list]; cursor += 100; &#125; while (res.has_more); let ret = []; arr.forEach((item, i) =&gt; &#123; var itemId = item.msg_id; var userId = item.author_user_info &amp;&amp; item.author_user_info.user_id; if (itemId &amp;&amp; userId === requestUserId) &#123; ret.push(&#123; itemId, userId &#125;) &#125; &#125;) return ret;&#125;function setComment(itemId) &#123; return new Promise((resolve, reject) =&gt; &#123; var num = randomNum(0, comments.length - 1); var comment = comments[num]; ajax(&#123; url: comment_api_url, // 请求地址 type: &#x27;POST&#x27;, // 请求类型，默认&quot;GET&quot;，还可以是&quot;POST&quot; data: &#123; &quot;item_id&quot;: itemId, &quot;item_type&quot;: 4, &quot;comment_content&quot;: comment, &quot;comment_pics&quot;: [], &quot;client_type&quot;: 2608 &#125;, // 传输数据 success: function(res) &#123; resolve(JSON.parse(res)); &#125;, error: function(error) &#123; reject(error); &#125; &#125;); &#125;)&#125;// 评论所有动态setInterval(function() &#123; var targetUserId = &#x27;2137106332779502&#x27;; getAllItemIds(targetUserId).then((arr) =&gt; &#123; if (arr.length) &#123; var promise = arr.map(item =&gt; &#123; return setComment(item.itemId); &#125;); Promise.all(promise).then((res) =&gt; &#123; console.log(res); &#125;) &#125; else &#123; console.log(&#x27;该用户暂未有可评论的沸点内容&#x27;); &#125; &#125;)&#125;, 5000)","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"}]},{"title":"使用iframe引入微信公众号的链接","date":"2020-07-21T13:56:10.000Z","path":"2020/07/21/使用iframe引入微信公众号的链接/","text":"本文实现了以下功能： iframe可加载微信公众号内容 可加载微信的视频或外链的视频 可绕过微信图片的防盗链 iframe里的微信公众号的跳转链接实现浏览器新窗口跳转 前言：由于微信前端页面的的服务器设置了Content-Security-Policy，导致他的资源如果在非白名单的网页被引用，就会拒绝返回资源，导致iframe加载内容失败 注：开启了CSP的时候要记得配置一下unsafe-eval和unsafe-inline，否则一些eval()，setTimeout，setInterval会无法执行；内联script，内联样式，内联事件都会失效 关于CSP的一些详细说明： https://blog.csdn.net/qq_25623257/article/details/90473859 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy 微信的CSP配置如下（检查前端html的响应头返回，微信这里是一个服务端渲染）： 1content-security-policy: script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; &#x27;unsafe-eval&#x27; http://*.qq.com https://*.qq.com http://*.weishi.com https://*.weishi.com http://*.m.tencent.com https://*.m.tencent.com http://*.weixin.qq.com https://*.weixin.qq.com https://midas.gtimg.cn &#x27;nonce-505653230&#x27;;style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; http://*.qq.com https://*.qq.com;object-src &#x27;self&#x27; http://*.qq.com https://*.qq.com http://*.qpic.cn https://*.qpic.cn http://*.qlogo.cn https://*.qlogo.cn;font-src &#x27;self&#x27; data: http://*.qq.com https://*.qq.com http://fonts.gstatic.com https://fonts.gstatic.com;frame-ancestors &#x27;self&#x27; http://wx.qq.com https://wx.qq.com http://wx2.qq.com https://wx2.qq.com http://wx8.qq.com https://wx8.qq.com http://web.wechat.com https://web.wechat.com http://web1.wechat.com https://web1.wechat.com http://web2.wechat.com https://web2.wechat.com http://sticker.weixin.qq.com https://sticker.weixin.qq.com http://bang.qq.com https://bang.qq.com http://app.work.weixin.qq.com https://app.work.weixin.qq.com http://work.weixin.qq.com https://work.weixin.qq.com http://finance.qq.com https://finance.qq.com http://gu.qq.com https://gu.qq.com http://wzq.tenpay.com https://wzq.tenpay.com http://test.tcp.tencent.com https://test.tcp.tencent.com http://dev.tcp.tencent.com https://dev.tcp.tencent.com http://tcp.tencent.com https://tcp.tencent.com http://mail.qq.com https://mail.qq.com http://wx.mail.qq.com https://wx.mail.qq.com http://iwx.mail.qq.com https://iwx.mail.qq.com http://dev.mail.qq.com https://dev.mail.qq.com;report-uri https://mp.weixin.qq.com/mp/fereport?action=csp_report 看到配置还配置到了一个report-uri，如果触发了拦截，会主动发送POST请求到这个uri里，发送的payload字段如下： 12345678910111213&#123; &quot;csp-report&quot;: &#123; &quot;document-uri&quot;: &quot;https://mp.weixin.qq.com/s/84wXnUBr1oE4D9z9oScRmg&quot;, &quot;referrer&quot;: &quot;&quot;, &quot;violated-directive&quot;: &quot;frame-ancestors&quot;, &quot;effective-directive&quot;: &quot;frame-ancestors&quot;, &quot;original-policy&quot;: &quot;script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; &#x27;unsafe-eval&#x27; http://*.qq.com https://*.qq.com http://*.weishi.com https://*.weishi.com http://*.m.tencent.com https://*.m.tencent.com http://*.weixin.qq.com https://*.weixin.qq.com https://midas.gtimg.cn &#x27;nonce-1034686668&#x27;;style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; http://*.qq.com https://*.qq.com;object-src &#x27;self&#x27; http://*.qq.com https://*.qq.com http://*.qpic.cn https://*.qpic.cn http://*.qlogo.cn https://*.qlogo.cn;font-src &#x27;self&#x27; data: http://*.qq.com https://*.qq.com http://fonts.gstatic.com https://fonts.gstatic.com;frame-ancestors &#x27;self&#x27; http://wx.qq.com https://wx.qq.com http://wx2.qq.com https://wx2.qq.com http://wx8.qq.com https://wx8.qq.com http://web.wechat.com https://web.wechat.com http://web1.wechat.com https://web1.wechat.com http://web2.wechat.com https://web2.wechat.com http://sticker.weixin.qq.com https://sticker.weixin.qq.com http://bang.qq.com https://bang.qq.com http://app.work.weixin.qq.com https://app.work.weixin.qq.com http://work.weixin.qq.com https://work.weixin.qq.com http://finance.qq.com https://finance.qq.com http://gu.qq.com https://gu.qq.com http://wzq.tenpay.com https://wzq.tenpay.com http://test.tcp.tencent.com https://test.tcp.tencent.com http://dev.tcp.tencent.com https://dev.tcp.tencent.com http://tcp.tencent.com https://tcp.tencent.com http://mail.qq.com https://mail.qq.com http://wx.mail.qq.com https://wx.mail.qq.com http://iwx.mail.qq.com https://iwx.mail.qq.com http://dev.mail.qq.com https://dev.mail.qq.com;report-uri https://mp.weixin.qq.com/mp/fereport?action=csp_report&quot;, &quot;disposition&quot;: &quot;enforce&quot;, &quot;blocked-uri&quot;: &quot;https://mp.weixin.qq.com/s/84wXnUBr1oE4D9z9oScRmg&quot;, &quot;status-code&quot;: 0, &quot;script-sample&quot;: &quot;&quot; &#125;&#125; 并且使用了iframe的前端会报一个错： 1Refused to display &#x27;https://mp.weixin.qq.com/s/84wXnUBr1oE4D9z9oScRmg&#x27; in a frame because an ancestor violates the following Content Security Policy directive: &quot;frame-ancestors &#x27;self&#x27; http://wx.qq.com https://wx.qq.com http://wx2.qq.com https://wx2.qq.com http://wx8.qq.com https://wx8.qq.com http://web.wechat.com https://web.wechat.com http://web1.wechat.com https://web1.wechat.com http://web2.wechat.com https://web2.wechat.com http://sticker.weixin.qq.com https://sticker.weixin.qq.com http://bang.qq.com https://bang.qq.com http://app.work.weixin.qq.com https://app.work.weixin.qq.com http://work.weixin.qq.com https://work.weixin.qq.com http://finance.qq.com https://finance.qq.com http://gu.qq.com https://gu.qq.com http://wzq.tenpay.com https://wzq.tenpay.com http://test.tcp.tencent.com https://test.tcp.tencent.com http://dev.tcp.tencent.com https://dev.tcp.tencent.com http://tcp.tencent.com https://tcp.tencent.com http://mail.qq.com https://mail.qq.com http://wx.mail.qq.com https://wx.mail.qq.com http://iwx.mail.qq.com https://iwx.mail.qq.com http://dev.mail.qq.com https://dev.mail.qq.com&quot;. 如果网页不在白名单里，这时候前端就不能够直接引用微信公众号的资源了，只能够将微信本身的html内容返回后，做处理后再渲染出来 寻找了网上的方案，所有的方案都指向了以下项目： https://github.com/Rob--W/cors-anywhere 该项目可以允许任意跨域请求，且基于nodejs开发，很好地解决了本地部署的问题，因为不可能使用他提供的服务器，很慢且很不稳定，把源码下载下来后可以直接本地部署。用法： 1axios.get(process.env.VUE_APP_CORS_ANYWHERE_API_URL + &#x27;/&#x27; + website) 这样就可以返回请求的内容，我们把website替换成微信公众号的链接，这时候返回了html到前端，完成了成功的第一步 拿到html后，尝试使用write写入资源（必须，因为有一些script需要加载，使用appendChild会导致这些script无法执行）后，会发现除了标题，其他一片空白，因为很多visibility属性都被设置为hidden了，需要全局替换一些改为visible 注：iframe的src不要使用&#39;data:text/html;charset=utf-8,&#39; + html的方式加载，使用container.contentWindow.document.write(html)写入资源 然后又会发现图片全部都有一个data-src属性，原本的src属性只是一个默认图，这时候也需要将他们的属性进行替换，data-src是用来作为懒加载的，有些js并不能够好好运行，只能改成直接显示 图片显示出来后，会发现微信居然对图片也做了防盗链处理，只能够处理防盗链的问题才能够显示。图片防盗链的原理是在放图片的服务器上加了对Referer的验证，资源在请求的时候，会带上Referer这个请求头（自动带上，且前端不可以设置这个请求头），那么解决方法就是请求自己的服务器，然后在自己的服务器再请求图片的服务器，自己的服务器置空Referer这个请求头，这样图片的服务器就会认为你只是简单的加载图片，而不是通过项目请求的图片，就会成功返回这个图片文件流，然后自己的服务器将这个文件流返回给前端，就可以完成绕过图片防盗链 网上有很多绕过图片防盗链的请求链接，这里推荐使用https://images.weserv.nl，速度很快 但有个坑点，如果是gif，需要在后面加上一些参数&amp;output=gif&amp;n=-1，说明他以gif返回，否则返回的图片是不会动的： 1https://images.weserv.nl/?url=https://mmbiz.qpic.cn/mmbiz_gif/iblvrvduDqxFibk6bianDue1Ygn2t0k1Cs8dmKjwcibxIesKWwDZwrib0aNxOxpZQyo4MxUPag0Cgz3dCrTMW6prHGA/640?wx_fmt=gif&amp;output=gif&amp;n=-1 或者使用文章里绕过图片防盗链的node方法，放在自己的服务器更放心。 微信的图片链接一般都会有一个参数说明这个图片是什么类型：wx_fmt，否则其实微信这个mmbiz.qpic.cn接口，也只是请求文件流，并不是访问服务器的真实地址，通过这个wx_fmt决定了返回的Content-Type是什么，这样直接浏览才会显示图片类型，而不是变成了下载这个文件 注：不要在html增加&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;的方法处理这类事件 解决了图片的外链问题后，会发现上传到微信服务器的视频的视频链接是无法加载的，且前端报了以下错误： 1moon4df393.js:275 [TryCatch]Error: Blocked a frame with origin &quot;https://mp.weixin.qq.com&quot; from accessing a cross-origin frame. 意思就是这个加载的视频链接，里面加载的js有进行xhr请求，在我们域名进行请求就会造成跨域。 由于在上一个获取微信内容的步骤中，已经有允许跨域请求的接口，我们查找出这个视频链接进行了什么xhr请求，然后使用这个跨域接口将它请求返回到前端即可。这个请求实际是为了返回视频的资源地址，返回了资源地址后，直接修改dom使用video加载这个src即可解决微信视频无法播放的问题 还有一个问题，就是微信对跳转链接【有图片跳转和文字跳转】也做了处理，通过这种方法加载出来的文章点击这个链接是无法跳转的，且需求是需要在浏览器新窗口进行跳转，这就需要特殊处理一下： 大体方向是取到需要跳转链接的a标签的dom，然后addEventListener，分别加入click和touch事件，且必须使用捕获的监听事件，才能正确执行回调的方法且不执行其他微信加了的监听事件 以下为具体细节实现源码： 1&lt;iframe id=&quot;wx_iframe&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126let timer = null;const website = &#x27;https://mp.weixin.qq.com/s/84wXnUBr1oE4D9z9oScRmg&#x27;;const imgPrefix = &#x27;https://images.weserv.nl/?url=&#x27;; // 绕过微信公众号图片的防盗链，如果是加载gif，需要加上参数&amp;output=gif&amp;n=-1，必须加上n=-1，不然不生效// ..._getWeixinNews() &#123; this.$client.showLoading(); axios.get(process.env.VUE_APP_CORS_ANYWHERE_API_URL + &#x27;/&#x27; + website).then(res =&gt; &#123; // 处理DOMString let data = res.data // data-src是图片的预加载机制，visible是返回后默认是hidden data = data.replace(/data-src/gi, &#x27;src&#x27;).replace(/hidden/gi, &#x27;visible&#x27;); // 在img前面加上反倒链的请求链接 data = data.replace(/&lt;img [^&gt;]*src=[&#x27;&quot;]([^&#x27;&quot;]+)[^&gt;]*&gt;/gi, (match, capture) =&gt; &#123; // gif必须加上额外参数 if (match.indexOf(&#x27;data-type=&quot;gif&quot;&#x27;) !== -1) &#123; return match.replace(capture, imgPrefix + capture + &#x27;&amp;output=gif&amp;n=-1&#x27;) &#125; else &#123; return match.replace(capture, imgPrefix + capture) &#125; &#125;); // 将DOMString转换为DOM，以便操作DOM const wx_dom = document.createElement(&#x27;div&#x27;); wx_dom.innerHTML = data; // 删除加载失败的二维码，要想加载成功需要代理地址 const qrcode = wx_dom.querySelector(&#x27;#js_pc_qr_code&#x27;); qrcode &amp;&amp; qrcode.parentNode.removeChild(qrcode); // 删除再看人数，功能不能正常执行 const watching = wx_dom.querySelector(&#x27;#js_like_btn&#x27;); watching &amp;&amp; watching.parentNode.removeChild(watching); // 删除点击外链的时候会出现的弹框 const js_link_dialog = wx_dom.querySelector(&#x27;#js_link_dialog&#x27;); js_link_dialog &amp;&amp; js_link_dialog.parentNode.removeChild(js_link_dialog); // 处理微信的视频iframe const videoElList = Array.from(wx_dom.querySelectorAll(&#x27;.video_iframe.rich_pages&#x27;)); const _videoInfoList = videoElList.map((el, index) =&gt; &#123; // 有一些视频是外链，vidtype是1，例如https://mp.weixin.qq.com/s/sMzUXCsPUH1PvtiK3BDU8w，是没有el.dataset.mpvid的，这时候请求会返回的url_info是一个空数组 // 微信本身的视频的vidtype是为2 return &#123; index, container: el.parentNode, mpvid: el.dataset.mpvid, // 微信视频的id cover: imgPrefix + decodeURIComponent(el.dataset.cover), // 封面 requestUrl: `http://mp.weixin.qq.com/mp/videoplayer?action=get_mp_video_play_url&amp;preview=0&amp;__biz=&amp;mid=&amp;idx=&amp;vid=$&#123;el.dataset.mpvid&#125;&amp;uin=&amp;key=&amp;pass_ticket=&amp;wxtoken=&amp;appmsg_token=&amp;x5=0&amp;f=json` // 请求视频真实地址的请求 &#125; &#125;); const requestVideoInfoPromiseList = _videoInfoList.map(item =&gt; &#123; if (item.mpvid) &#123; return axios.get(process.env.VUE_APP_CORS_ANYWHERE_API_URL + &#x27;/&#x27; + item.requestUrl); &#125; else &#123; return Promise.resolve(&#123; data: null &#125;); &#125; &#125;); // 渲染函数，在最后一步执行 const next = () =&gt; &#123; // 必须使用iframe的write进行写入资源，否则script不会运行，一些微信引用的外链视频就会无法执行 const container = document.getElementById(&#x27;wx_iframe&#x27;); container.contentWindow.document.write(wx_dom.innerHTML); // iframe无法冒泡出去 container.contentWindow.document.addEventListener(&#x27;click&#x27;, this.handleUnActiveMobileEdit); // 处理点击a标签外链链接跳转 console.log(&#x27;------- a_link inject -------&#x27;); const aList = Array.from(container.contentWindow.document.querySelectorAll(&#x27;a&#x27;)); const aLinkList = []; for (const aItem of aList) &#123; if (aItem.getAttribute(&#x27;tab&#x27;) === &#x27;outerlink&#x27; &amp;&amp; aItem.href) &#123; // pc监听，必须使用捕获 aItem.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123; e.preventDefault(); e.stopImmediatePropagation(); window.open(aItem.href); &#125;, true); // 移动端监听，必须使用捕获 aItem.addEventListener(&#x27;touchend&#x27;, (e) =&gt; &#123; e.preventDefault(); e.stopImmediatePropagation(); window.open(aItem.href); &#125;, true); aLinkList.push(aItem); &#125; &#125; console.log(aLinkList); // 处理微信的page_share_img模式，由于body的class是通过js生成的，会导致部分样式不生效，需要手动添加 const body = container.contentWindow.document.documentElement || container.contentWindow.document.body; body &amp;&amp; addClass(body, &#x27;page_share_img&#x27;); // 持续监听iframe的高度，由于图片显示的关系，高度会一直变化 timer = setInterval(() =&gt; &#123; if (container.contentWindow) &#123; // 使用内容的高度作为iframe的高度，以达到自适应的效果 const inner = container.contentWindow.document.querySelector(&#x27;#js_article&#x27;); container.style.height = inner.scrollHeight + &#x27;px&#x27;; &#125; &#125;, 1000); this.$client.hideLoading(); &#125; // 获取微信video真实播放地址 Promise.all(requestVideoInfoPromiseList).then(arr =&gt; &#123; console.log(&#x27;------- wx_video inject -------&#x27;); const videoInfoList = _videoInfoList.map((item, index) =&gt; &#123; return &#123; ...item, videoUrl: (arr[index].data &amp;&amp; arr[index].data.url_info &amp;&amp; arr[index].data.url_info[0]) ? arr[index].data.url_info[0].url : &#x27;&#x27; &#125; &#125;); for (const item of videoInfoList) &#123; if (!item.videoUrl) &#123; continue; &#125; // 安卓微信X5内核浏览器，假如有poster无法显示，video标签加上x5-video-player-type=&quot;h5&quot;试试 item.container.innerHTML = ` &lt;div&gt; &lt;video src=&quot;$&#123;item.videoUrl&#125;&quot; width=&quot;100%&quot; style=&quot;object-fit: contain;&quot; poster=&quot;$&#123;item.cover&#125;&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; &lt;/div&gt; `; &#125; console.log(videoInfoList); next(); &#125;).catch((err) =&gt; &#123; this.$client.error(&#123; message: err.message &#125;); next(); &#125;); &#125;).catch((err) =&gt; &#123; this.$client.error(&#123; message: err.message &#125;); this.$client.hideLoading(); &#125;)&#125;","tags":[{"name":"微信","slug":"微信","permalink":"https://sellenite.github.io/tags/%E5%BE%AE%E4%BF%A1/"}]},{"title":"node实现上传文件并保存到硬盘","date":"2020-07-21T13:54:17.000Z","path":"2020/07/21/node实现上传文件并保存到硬盘/","text":"上传文件到node服务器保存并返回文件信息关键是要使用一个中间件multer 使用express： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const express = require(&#x27;express&#x27;)const app = express()const port = 3000const multer = require(&#x27;multer&#x27;)const storage = multer.diskStorage(&#123; // 注意这里，需要具体处理文件的路径 destination: function (req, file, cb) &#123; cb(null, &#x27;./uploads/&#x27;) &#125;, // 注意这里，需要具体处理文件的名称，因为存在中文等 filename: function (req, file, cb) &#123; cb(null, Date.now() + &#x27;-&#x27; + file.originalname) &#125;&#125;)const upload = multer(&#123; storage: storage &#125;)// 多文件就要 upload.array(),单文件就用 upload.single()// single要与const form = new FormData();form.append(&#x27;file&#x27;, event.target.files[0])的key一致；// single要与&lt;input id=&#x27;upload&#x27; type=&quot;file&quot; name=&quot;file&quot; /&gt;name属性一致app.post(&#x27;/upload&#x27;, upload.single(&#x27;file&#x27;), (req, res, next) =&gt; &#123; // 这里的req.file返回的是一个json对象 if (req.file) &#123; return res.status(200).json(&#123; code: 0, msg: &#x27;上传成功&#x27;, data: req.file &#125;); &#125; else &#123; return res.status(200).json(&#123; code: 1, msg: &#x27;上传失败&#x27;, data: null &#125;); &#125;&#125;)// node console.log(req.file)// &#123;// fieldname: &#x27;file&#x27;,// originalname: &#x27;19730B75-15AF-4ede-9852-0392DEDD96A4.png&#x27;,// encoding: &#x27;7bit&#x27;,// mimetype: &#x27;image/png&#x27;,// destination: &#x27;./uploads/&#x27;,// filename: &#x27;1591588463244-19730B75-15AF-4ede-9852-0392DEDD96A4.png&#x27;,// // 文件保存的路径，这里是由于本机服务器是windows的问题，真实项目需要统一处理路径问题// path: &#x27;uploads\\\\1591588463244-19730B75-15AF-4ede-9852-0392DEDD96A4.png&#x27;,// size: 107642// &#125; 前端代码： 1&lt;input type=&quot;file&quot; @change=&quot;loadFile&quot;&gt; 12345678910111213loadFile(event) &#123; const form = new FormData(); form.append(&#x27;file&#x27;, event.target.files[0]) axios(&#123; method: &#x27;POST&#x27;, url: &#x27;http://localhost:3000/upload&#x27;, // request headers的content-type必须设置为multipart/form-data headers: &#123; &#x27;Content-Type&#x27;: &#x27;multipart/form-data&#x27; &#125;, data: form &#125;)&#125; 返回的data里会有path的属性，是中间件写上去的，是文件保存的路径","tags":[{"name":"Node","slug":"Node","permalink":"https://sellenite.github.io/tags/Node/"}]},{"title":"node实现绕过图片防盗链","date":"2020-07-21T13:51:46.000Z","path":"2020/07/21/node实现绕过图片防盗链/","text":"绕过图片防盗链的关键就是要伪造请求头的Referer，将Referer置为空即可 不要在html增加&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;的方法处理这类事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445const express = require(&#x27;express&#x27;)const app = express()const port = 3000const superagent = require(&#x27;superagent&#x27;)function getQueryObject(url) &#123; url = url == null ? window.location.href : url const search = url.substring(url.lastIndexOf(&#x27;?&#x27;) + 1) const obj = &#123;&#125; const reg = /([^?&amp;=]+)=([^?&amp;=]*)/g search.replace(reg, (rs, $1, $2) =&gt; &#123; const name = decodeURIComponent($1) let val = decodeURIComponent($2) val = String(val) obj[name] = val return rs &#125;) return obj&#125;// 前端无法修改请求头的Referer，只能通过接口修改，做一个转发请求app.get(&#x27;/imgBridge&#x27;, async (req, res, next) =&gt; &#123; let url = req.query.url; if (!url) &#123; res.send(&#x27;&#x27;); return false; &#125; // 微信的链接自带说明是什么格式，可以直接取，不用再额外分析文件的格式是什么 const wx_query = getQueryObject(url); superagent.get(req.query.url) .set(&#x27;Referer&#x27;, &#x27;&#x27;) .end(function(err, result) &#123; if (err) &#123; return false; &#125; // 返回头必须写入对应的文件类型，直接在浏览器打开才会显示正确的图片而不是下载 res.set(&#123; &#x27;Content-Type&#x27;: `image/$&#123;query.wx_fmt&#125;` &#125;); // 返回文件流 res.end(result.body); return; &#125;);&#125;) 使用方法，直接赋值到img的src上或background的url上： 1http://localhost:8080?url=https://mmbiz.qpic.cn/mmbiz_gif/iblvrvduDqxFibk6bianDue1Ygn2t0k1Cs8dmKjwcibxIesKWwDZwrib0aNxOxpZQyo4MxUPag0Cgz3dCrTMW6prHGA/640?wx_fmt=gif 即可显示出图片","tags":[{"name":"Node","slug":"Node","permalink":"https://sellenite.github.io/tags/Node/"}]},{"title":"git常用错误解决方案","date":"2020-07-21T13:48:01.000Z","path":"2020/07/21/git常用错误解决方案/","text":"git常用错误解决方案git被墙，需要设置代理假如git push等操作出现Timed out等，无法对远端的代码进行操作，且访问github的时候无法访问，就要考虑是被墙的问题。浏览器可以通过SwitchyOmega进行代理，git同样需要进行配置代理才能够访问 我用的是ByWave，是V2ray的机场。注册购买登录后进入系统设置面板，主要看Socks5端口和HTTP端口，然后在需要进行配置的项目执行以下配置命令（不建议使用–global命令，不同项目的地址可能都不同，不需要所有都代理） 使用Socks5：（设配置定义的端口是1081） git config http.proxy &quot;socks5://127.0.0.1:1081&quot; git config https.proxy &quot;socks5://127.0.0.1:1081&quot; 使用HTTP： git config http.proxy &quot;http://127.0.0.1:1081&quot;git config https.proxy &quot;http://127.0.0.1:1081&quot; 然后开启代理，即可进行git push等操作 如果要取消代理配置，执行以下命令即可： git config --unset http.proxy git config --unset https.proxy github连接报”ssh: connect to host github.com port 22: Connection timed out”错误先测试是不是由于这个问题无法进行一系列的git操作： 在连接github时，执行”ssh -T &#103;&#x69;&#116;&#x40;&#103;&#x69;&#116;&#x68;&#117;&#98;&#x2e;&#99;&#111;&#109;” 命令时，出现 1ssh: connect to host github.com port 22: Connection timed out 解决方法： 首先设置好ssh key 然后找到git的安装目录，找到&#x2F;etc&#x2F;ssh&#x2F;ssh_config文件，然后再把以下这段写入到文本即可 123456Host github.com // 或者使用默认的Host *User YourEmail@163.com // 设置成自己ssh定义的emailHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 Ubuntu就在根目录找到.ssh和直接找&#x2F;etc路径即可，注意需要使用sudo权限去修改","tags":[{"name":"Git","slug":"Git","permalink":"https://sellenite.github.io/tags/Git/"}]},{"title":"记一次钉钉鉴权验证过程","date":"2020-07-21T12:06:08.000Z","path":"2020/07/21/记一次钉钉鉴权验证过程/","text":"在使用jsapi中，出现以下错误的原因是：1&#123;&quot;errorMessage&quot;:&quot;对应企业没有某域名微应用&quot;, &quot;errorCode&quot;:&quot;3&quot;&#125; 微应用管理的基础信息，应用首页地址或PC端首页地址必须要和打开的地址匹配，不然就会报上面的错 鉴权的时候也必须使用对应的corpId，公司ID一般是不变的，可以写死，在开发者后台的首页就能看到 必须由最高管理员授权管理员对应的应用权限，才能进入应用拿到最新的AgentId，AppKey，AppSecret，不然有可能是旧的，就会造成鉴权错误 附：移动端调试钉钉详细步骤 连续点击版本号6次 进入系统和更新菜单，打开开发人员选项 在开发者选项中，先把“仅充电模式下允许ADB调试”打开，然后再打开“USB调试” 连接USB，选择充电模式，必须是充电模式 自动会打开RSA验证菜单，确认 下载钉钉android开发版，在开发者后台，工具与资源下载，pc和android都有 进入手机dev钉钉版，设置-通用-开发者选项，勾选微应用调试 应用稳定性管理增加开发负责人和APPOPS为自己 手机连接到电脑，打开chrome，chrome:&#x2F;&#x2F;inspect 开始调试，必须翻墙 如果无法翻墙，使用UC Devtools也可以进行inspect，如果UC无法inspcet，考虑进入设置，切换InspectorURI Resource为默认资源 这时候无论是微应用还是在里面打开的h5页面，都能够监听调试，查看网络请求或错误信息 开发一般会接入vConsole，就是微信开发的移动端调试工具，点击浮窗即可查看信息","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"},{"name":"钉钉","slug":"钉钉","permalink":"https://sellenite.github.io/tags/%E9%92%89%E9%92%89/"}]},{"title":"Vue工作经验总结（3）","date":"2019-08-26T14:18:15.000Z","path":"2019/08/26/Vue工作经验总结（3）/","text":"v-model语法糖时，可以使用watch进行数据初始化之前一直都是使用created+watch进行里面数据的初始化，其实可以直接使用watch就可以了： 123456value: &#123; immediate: true, handler(val) &#123; this.currentValue = val; &#125;&#125; elementUI里的table，template里不要使用refelementUI里的table，template里不要使用ref，引用的结果会与预期有差距，暂时无法找出什么原因 使用v-model进行双向绑定时，oninput可以立即修改数据其实v-model就是emit一个input事件的语法糖，根据这个我们可以通过监听input事件，在修改之前就将它拦截修改就可以了，不用根据watch这个绑定值然后再手动修改一次，因为这样会有一个闪烁的问题，直接拦截input事件就不会出现这个问题，具体实现： 1&lt;components v-model=&quot;test&quot; @input=&quot;value=value.replace(/[^\\d]/g, &#x27;&#x27;)&quot;&gt;&lt;/components&gt; 这样绑定的test值就是经过执行函数后的值 fixed定位的浮动框，在滚动时依然能跟随屏幕移动参考elementUI在处理pop组件，这些组件一般都是放在body下，然后使用fixed定位的，如果不进行处理，在进行滚动的时候会一直定在同一个地方，很奇怪。 参考popper.js 227行左右的监听滚动函数 elementUI的table固定高度时，如何将里面滚动内容跳到顶部可以看一下源码，里面存了dom 1this.$refs.table.bodyWrapper.scrollTop = 0 父元素和子元素的渲染时机和顺序父子组件在加载的时候，执行的先后顺序为父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted UI组件二次封装时传值的问题前端可能有这样的需求，使用第三方UI组件时，如ElementUI时，里面的钩子函数等不能满足业务需求，这时候就需要在外面再套一层。这时候由于里面有很多props，如果一个一个对应地去赋值，就会很烦，而且有可能会漏，以下是为了解决这个问题的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;el-select v-bind=&quot;$props&quot; @change=&quot;changeEmit&quot; @visible-change=&#x27;visibleChangeEmit&#x27;&gt; &lt;el-option v-for=&quot;item in options&quot; :key=&quot;item[propsAlias.value]&quot; :label=&quot;item[propsAlias.label]&quot; :value=&quot;item[propsAlias.label] + &#x27;·&#x27; + item[propsAlias.value]&quot;&gt; &lt;/el-option&gt; &lt;/el-select&gt;&lt;/template&gt;&lt;script&gt;import &#123; Select &#125; from &#x27;element-ui&#x27;export default &#123; name: &#x27;em-select&#x27;, props: &#123; ...Select.props, // 这里继承原 UI 组件的 props // 配置 options: &#123; type: Array, default: () =&gt; [ &#123; value: &#x27;选项1&#x27;, label: &#x27;黄金糕&#x27; &#125;, &#123; value: &#x27;选项2&#x27;, label: &#x27;双皮奶&#x27; &#125; ] &#125;, // 数据项属性别名 propsAlias: &#123; type: Object, default: () =&gt; &#123; return &#123; value: &#x27;value&#x27;, label: &#x27;label&#x27; &#125; &#125; &#125; &#125;, data() &#123; return &#123;&#125; &#125;, methods: &#123; changeEmit(val)&#123; this.$emit(&#x27;change&#x27;, val); // 选中值发生变化时触发 &#125;, visibleChangeEmit(isVisible)&#123; this.$emit(&#x27;visible-change&#x27;, isVisible); // 下拉框出现/隐藏时触发 &#125; &#125;&#125;&lt;/script&gt; 这样就可以实现一次二次封装，在二次封装的组件里进行props的注册和传值。里面传什么，都会传到ElementUI的原组件里，注意$props的用法，官网给出的demo： 12&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;&lt;child-component v-bind=&quot;$props&quot;&gt;&lt;/child-component&gt; bind也可以一次性绑定多个属性： 12&lt;!-- 绑定一个有属性的对象 --&gt;&lt;div v-bind=&quot;&#123; id: someProp, &#x27;other-attr&#x27;: otherProp &#125;&quot;&gt;&lt;/div&gt; 如果不使用额外的prop传入，可以直接传入attrs和listeners，这样就可以传入不确定的属性和绑定函数 1&lt;child-component v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/child-component&gt; 当ElementUI的form里面只有一个input元素，使用@keyup.enter.native会导致刷新页面的问题由于ElementUI在定义组件的时候，遵循以下规则： 当一个 form 元素中只有一个输入框时，在该输入框中按下回车应提交该表单。如果希望阻止这一默认行为，可以在 &lt;el-form&gt; 标签上添加 @submit.native.prevent。 所以会出现第一次回车就会刷新页面，再次回车，才出发回车事件。 当一个 form 元素中只有一个输入框时，在该输入框中按下回车应提交该表单。如果希望阻止这一默认行为，可以在 标签上添加 @submit.native.prevent。 123&lt;el-form @submit.native.prevent&gt; &lt;el-input v-model=&quot;inpulValue&quot; @keyup.enter.native=&quot;searchKey&quot;&gt;&lt;/el-input&gt;&lt;/el-form&gt; ElementUI的table高度自适应问题之前一直做了一件蠢事，为了解决ElementUI的table自适应问题，一直使用了resize事件，然后重新计算了当前剩余高度，然后赋值给table的height。其实不用这么干，只需要利用flex，在table加一个垂直方向的flex: 1 0 auto即可 ElementUI的table二次封装，支持配置render定制化这个技巧比较重要，利用了之前一直没用过的scopedSlots。由于ElementUI本来的table配置定制化全部是使用template来实现的。在这里完成的组件里，可以直接通过配置定制render，支持jsx和h() table.vue 123&lt;el-table :data=&quot;tableData&quot; v-bind=&quot;tableConfig&quot; v-on=&quot;tableEvent&quot;&gt; &lt;table-column v-for=&quot;(item, index) in columnConfigComputed&quot; :key=&quot;index&quot; :config=&quot;item&quot; /&gt;&lt;/el-table&gt; 123456789101112131415161718192021222324252627282930313233343536373839watch: &#123; columnConfig: &#123; deep: true, immediate: true, handler(nVal, oVal) &#123; // 对特殊的type进行改造，避免多次重复写代码 this.columnConfigComputed = nVal.map((item, index) =&gt; &#123; const SELECTION_WIDTH = 40; // 固定选择的宽度 if (item.type === &#x27;selection&#x27;) &#123; item.width = SELECTION_WIDTH; &#125; // 官方没有单选的type，只有多选的type（selection），所以单选需要额外改造 if (item.type === &#x27;radio&#x27;) &#123; item.width = SELECTION_WIDTH; item.render = (scoped) =&gt; &#123; return this.$createElement(&#x27;el-checkbox&#x27;, &#123; props: &#123; value: scoped.row.id === this.currentRow.id &#125;, nativeOn: &#123; // 点击checkbox的时候，如果有定义点击行事件，会导致触发行事件，这里禁止冒泡 click: (e) =&gt; &#123; if (this.currentRow.id) &#123; this.currentRow = &#123;&#125;; &#125; else &#123; this.currentRow = _.cloneDeep(scoped.row); &#125; e.stopImmediatePropagation(); e.preventDefault(); &#125; &#125; &#125;) &#125; &#125; return item; &#125;); &#125; &#125;&#125; table-column.vue 1234567891011121314151617181920&lt;script&gt;export default &#123; name: &#x27;table-column&#x27;, functional: true, props: &#123; config: &#123; type: Object, default: () =&gt; &#123;&#125; &#125; &#125;, render: (h, context) =&gt; &#123; return h(&#x27;el-table-column&#x27;, &#123; props: context.props.config, scopedSlots: &#123; default: context.props.config.render // 使用scopedSlots，这里会传入本来的props，在这里也就是scoped，可以通过scoped.row.xx拿到数据 &#125; &#125;) &#125;&#125;&lt;/script&gt; 使用的时候，这样配置即可定制column的内容，就可以利用render属性，返回一个jsx，CLI3的本来配置就有支持jsx的transformer，可以直接使用，如果不是使用CLI3启动的项目，需要额外配置babel： 1&lt;list-table :column-config=&quot;columnConfig&quot; /&gt; 123456789101112131415161718192021222324export default &#123; data() &#123; return &#123; columnConfig: [ &#123; type: &#x27;radio&#x27; // 额外定义的type &#125;, &#123; type: &#x27;index&#x27; &#125;, &#123; prop: &#x27;date&#x27;, // 支持本来的直接传入prop渲染数据的配置 label: &#x27;日期&#x27; &#125;, &#123; label: &#x27;姓名&#x27;, render: (scoped) =&gt; &#123; return &lt;span style=&#x27;color: red;&#x27;&gt;&#123; scoped.row.name &#125;&lt;/span&gt; &#125; &#125; ] &#125; &#125;&#125; v-bind和v-on绑定一个对象，一次性将属性传入v-bind和v-on绑定一个对象，二次封装时可以一下子将所有需要传入的属性传入，不用一个一个定义 123&lt;el-table :data=&quot;tableData&quot; v-bind=&quot;tableConfig&quot; v-on=&quot;tableEvent&quot;&gt; &lt;table-column v-for=&quot;(item, index) in columnConfigComputed&quot; :key=&quot;index&quot; :config=&quot;item&quot; /&gt;&lt;/el-table&gt; v-model后面可以加一个修饰符.trim，防止仅输入空格具体的情况有： element ui 中自带的表单必填项校验输入空格时，依然能逃过验证（required: true还是可以通过）， 需要再在 v-model 加上 .trim 来禁止输入空格字符，加上之后则不能只输入空格。 vue项目的env文件配置在vue-cli3的项目中，npm run serve时会把process.env.NODE_ENV设置为development；npm run build 时会把process.env.NODE_ENV设置为production； 其实通过改变process.env.NODE_ENV值区分打包环境是有问题的，因为webpack打包时针对process.env.NODE_ENV&#x3D;&#x3D;&#x3D;production和其他情况打出来的包结构和大小都不一样； 如果需要设置env文件，例如.env.sit，然后npm run sit务必在文件里添加NODE_ENV&#x3D;production，不然cli会以development模式打包，打出来的结构和大小都不一样 使用render的时候，绑定带有修饰符native的事件时，需要写在nativeOn的对象里1234567891011121314151617return this.$createElement(&#x27;el-checkbox&#x27;, &#123; props: &#123; value: scoped.row.id === this.currentRow.id &#125;, nativeOn: &#123; // 点击checkbox的时候，如果有定义点击行事件，会导致触发行事件，这里禁止冒泡 click: (e) =&gt; &#123; if (this.currentRow.id) &#123; this.currentRow = &#123;&#125;; &#125; else &#123; this.currentRow = _.cloneDeep(scoped.row); &#125; e.stopImmediatePropagation(); e.preventDefault(); &#125; &#125;&#125;) el-radio,el-checkbox，关于ElementUI组件使用@click.native时，绑定的事件会触发2次的问题解决方法：在click.native中执行e.preventDefault();原因：原因是阻止了element组件里的radio里的label的默认事件，就不会触发两次了 如何使用computed的值去作为v-model的值首先computed的原理：computed如果只写函数，只会在get这个属性的时候才会触发函数，然后return一个值。如果在任何情况都不获取这个值，这个函数是永远不会执行的 如果想使用computed的返回值作为v-model，要同时设定get()和set() 但一般不会这么写，一般会使用watch去监听这个属性，然后在里面对真正的值进行赋值 12345678910computed: &#123; currentValue: &#123; get: function() &#123; return this.value; &#125;, set: function(newValue) &#123; this.$emit(&quot;input&quot;, newValue); // 通过 input 事件更新 model &#125; &#125;&#125; 如何使用fonts-size去控制svg的大小svg本身添加css： 123width: 1em;height: 1em;font-size: 23px; 这样才能够通过font-size控制大小 填充svg使用fill css，如果里面没有指定颜色的话就可以生效 关于项目发布后，第一次加载项目会白屏，清除缓存后才可以的问题打包后，js的hash更改，仍然有缓存的原因是，服务器缓存了html文件，导致即使打包后，html引用的还是缓存里的文件，加载了不存在的js文件，导致白屏。解决方案：服务器里配置html文件永不缓存 使用axios(ajax)的post方式下载文件12345678910111213this.httpPost(&#123; url: &#x27;/download&#x27;, responseType: &#x27;blob&#x27;, // important data: params, onSuccess: (res) =&gt; &#123; const url = window.URL.createObjectURL(new Blob([res])); const link = document.createElement(&#x27;a&#x27;); link.href = url; link.setAttribute(&#x27;download&#x27;, &#x27;自定义文件名&#x27;); document.body.appendChild(link); link.click(); &#125;&#125;); 路由对象不可进行深复制的问题路由中的component属性必须保留render函数和name，才能正确地被keep-alive缓存下来，千万不要对路由本身进行深复制，会将函数给过滤掉 关于ElementUI的Form组件的多行list进行表单验证的方法首先看Form组件系列的源码，原理是使用Form组件的model传入的对象，然后利用FormItem的prop进行属性的查找。属性值的查找ElementUI进行了一个函数封装，源码如下： 12345678910111213141516171819202122232425export function getPropByPath(obj, path, strict) &#123; let tempObj = obj; path = path.replace(/\\[(\\w+)\\]/g, &#x27;.$1&#x27;); path = path.replace(/^\\./, &#x27;&#x27;); let keyArr = path.split(&#x27;.&#x27;); let i = 0; for (let len = keyArr.length; i &lt; len - 1; ++i) &#123; if (!tempObj &amp;&amp; !strict) break; let key = keyArr[i]; if (key in tempObj) &#123; tempObj = tempObj[key]; &#125; else &#123; if (strict) &#123; throw new Error(&#x27;please transfer a valid prop path to form item!&#x27;); &#125; break; &#125; &#125; return &#123; o: tempObj, k: keyArr[i], v: tempObj ? tempObj[keyArr[i]] : null &#125;;&#125;; 其中传入的obj就是model的属性，path是传入的prop属性，使用查找到之后对本身进行赋值，一层一层地找下去，使得这一的写法也可以进行找到属性： 12// model =&gt; &#123; list: [&#123; a: 1 &#125;] &#125;// prop =&gt; &quot;list.0.a&quot; 注意，in操作符也能判断元素在不在这个数组里，和indexOf一样可以判断，但这里的in不仅能判断元素在不在数组，还能判断元素在不在对象，所以lisy.0.a能够查找成功 那么既然这样，在list进行遍历的时候，将index作为拼接传入prop，就能找到对应的属性，进行表单验证： 12345678910111213141516171819&lt;el-form class=&quot;form&quot; ref=&quot;form&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; label-width=&quot;100px&quot; style=&quot;width: 700px;&quot;&gt; &lt;el-row&gt; &lt;el-col&gt; &lt;el-form-item label=&quot;申请原因&quot; prop=&quot;remark&quot;&gt; &lt;el-input type=&quot;textarea&quot; :placeholder=&quot;inputPlaceHolder()&quot; resize=&quot;none&quot; :autosize=&quot;&#123; minRows: 5, maxRows: 5&#125;&quot; v-model=&quot;form.remark&quot; :disabled=&quot;!editable&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;!-- 列表的表单验证方法 --&gt; &lt;template v-for=&quot;(item, index) in form.purchaseItems&quot;&gt; &lt;el-row :key=&quot;`$&#123;index&#125;-0`&quot;&gt; &lt;el-col&gt; &lt;el-form-item label=&quot;类别&quot; :rules=&quot;rules.typeName&quot; :prop=&quot;`purchaseItems.$&#123;index&#125;.typeName`&quot;&gt; &lt;el-input v-model=&quot;item.typeName&quot; :disabled=&quot;true&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/template&gt;&lt;/el-form&gt; 12345678data() &#123; return &#123; form: &#123; remark: &#x27;&#x27;, purchaseItems: [] &#125; &#125;&#125; 小知识，传入的prop，与进行表单验证的时候，自定义规则validator，传入的函数，rule的参数，与rule.field是一样的，灵活利用这些属性，可以进行一些比较复杂的表单验证方法，看源码是比较直接的方法 如果有通过v-if进行显示el-form-item的，需要在el-form-item上加上key值，否则会出现一些奇怪的bug，例如表单校验不成功 小知识2，element-ui是利用prop属性找到值，vant则是利用传入value 1234567formValue: function formValue() &#123; if (this.children &amp;&amp; (this.$scopedSlots.input || this.$slots.input)) &#123; return this.children.value; &#125; return this.value;&#125; vuex带有命名空间的属性的取法1234567computed: &#123; // 重新进行命名 ...mapGetters(&#x27;user&#x27;, &#123; name: &#x27;userName&#x27; &#125;), ...mapGetters(&#x27;user&#x27;, [&#x27;userName&#x27;])&#125; vue-router获得完整路径的方法使用router自带的resolve的方法，可以获得绝对地址 12let routeData = this.$router.resolve(&#123; path: &#x27;/home&#x27;, query: &#123; id: 1 &#125; &#125;);window.open(routeData.href, &#x27;_blank&#x27;); 在vue里使用lodash的防抖功能1234567methods: &#123; remoteMethod: _.debounce(function(query) &#123; // do something // 不要传入箭头函数 // 这里可以使用this访问vue里面的属性，this指向vm &#125;, 500),&#125; 注意，lodash的debounce的callback，最好用function，不要使用箭头函数，原因是他绑定了调用方法的那个this，在里面的this就是vm实例本身。传入箭头函数后，箭头函数绑定this的优先度最高，这时候的this是指向全局，在严格模式时是undefined。所以传入箭头函数后，如果要访问vm实例本身，只能另外定义一个变量储存this，然后使用这个变量去访问实例的属性 v-bind里也可以使用filter1:value=&quot;form.usesCarType | useCarTypeFilter&quot; 关于vue-admin类的页面缓存方法单页面admin有一种比较容易的方法，就是实际上就算维护了多级的路由，在addRoutes的时候弄成平级就可以了，这样不管是多少级路由，始终只有一个router-view，不是多级router-view了。只是要从后台进行一个路由树的配置，来渲染菜单栏，然后弄成平面的数组，放到addRouters里 在vue实例外获取当前vue-router路由的信息及有关应用引入项目中export default出来的router实例，router对Vue实例有引用，可以据此访问到$route。其实dom树也引用了Vue实例，所以可以从dom的访问到所有的Vue相关的东西，比如组件等 具体代码为router.app.$route 这个一般应用在一些工具js，需要获取当前路由对应的组件信息进行一些操作，例如请求中断后跳转到对应的错误页面，放在axios的全局响应拦截器上 123456789101112131415161718import router from &#x27;@/router/index.js&#x27;function toErrorPage(config = &#123;&#125;) &#123; const pageName = router.app.$route.name; // 防止递归错误 if (pageName !== &#x27;ErrorPage&#x27;) &#123; router.replace(&#123; name: &#x27;ErrorPage&#x27;, query: &#123; pageName, message: config.message, type: config.type, originQuery: JSON.stringify(router.app.$route.query || &#123;&#125;), originParams: JSON.stringify(router.app.$route.params || &#123;&#125;) &#125; &#125;) &#125;&#125;","tags":[{"name":"Vue","slug":"Vue","permalink":"https://sellenite.github.io/tags/Vue/"}]},{"title":"JS工作经验总结（3）","date":"2019-08-26T13:53:30.000Z","path":"2019/08/26/JS工作经验总结（3）/","text":"JS工作经验总结（2） JS拿到图片实际宽高方法其实IE9+和其他浏览器都有原生的api可以取得到图片的实际宽高，用于做一些图片放大插件等有用处。如果api不兼容，可以使用图片onload后，取得到的宽高也是图片的实际宽高 1234567891011121314151617181920if (typeof el.naturalWidth == undefined) &#123; // LTE 8 var i = new Image(); var rw, rh; i.src = el.src; // 判断是否有缓存 if (i.complete) &#123; rw = i.width; rh = i.height; &#125; else &#123; i.onload = function() &#123; rw = i.width; rh = i.height; &#125; &#125;&#125; else &#123; // GTE IE9 rw = el.naturalWidth; rh = el.naturalHeight;&#125; 关于使用formData传送的类型formData可以直接传file，也可以通过Blob二进制类型转成二进制，然后放到formData里。一些压缩的原理就是经过转换后，存成二进制，然后发到后台，后台收到的仍然是文件类型 注意formData传图片文件的时候，是不能直接传base64的，因为它不是文件类型。 清空input文件的值1inputEl.files.value = null; for-in循环时，使用数值作为键值遍历的问题使用for in循环时，如果对象的键值为数值，会根据数值的大小顺序，从低到高进行遍历，遍历的顺序不可信，不要使用遍历对象然后直接push到数组，会有排序问题，需要额外的方法对数组进行排序 webpack打包体积过大，使用cdn引入依赖由于我们常引用依赖的方法是import xx from ‘xxx’，但由于引用的cdn是通过全局变量进行引用的，如果想要使用cdn，同时使用import的方法，可以采用cdn和webpack的externals 字符串模板换行的情况在模板字符串里换行的时候，实际上会的确存在换行符\\n的，想要字符串进行换行，记得设置一下元素的white-space属性，设置为pre-wrap或pre-line进行换行 url存在特殊字符的情况get请求，后端定义路由时，注意不要用到可能带有【.】作为路由url，会导致【.】后面的都会被忽略，且【.】属于安全字符，不会被转义。如果有这种情况，只能够使用参数方式传参，这样带【.】是无问题的 例如： 1/api/goods/100445.2 1/api/goods?id=100445.2 第一种就是路由方式去传参，100445.2会被浏览器忽略成100445去请求后端 第二种是参数方式传参，就没有问题 如果有各类特殊字符，对参数进行一个encodeURIComponent()操作即可，这是一个编码标准，后端也很容易将它解码，当get请求传入json字符串的时候，必须使用这个编码转码发到后端 getBoundingClientRect获取的高度问题getBoundingClientRect拿到的top值只是距离窗口顶部的距离，如果有scroll，先拿到距离文档最高出的距离，需要将rect.top + window.pageYOffset || document.documentElement.scrollTop 前端登录RSA加密流程流程是这样的： 请求后端，拿到一个publicKey和一个标识字符串 前端使用插件，利用publicKey对密码进行RSA加密 使用加密后的密码和标识字符串请求登录接口 标识字符串的作用是后台通过这个标识使用对应的privateKey对加密字符串进行解密 RSA为什么能安全：加密后的字符串，必须通过privateKey去解密，就算抓包的时候请求抓到publicKey，那也只是加密所使用的key，并不能解密。所以抓包抓到的加密字符串没有privateKey是无法加密的，privateKey保存在后台，解密工作在后台进行 伪代码： 1234567891011import JsEncrypt from &#x27;jsencrypt&#x27;;let jse = new JsEncrypt();// publicKey是请求后台获取的jse.setPublicKey(publicKey);let encodePassword = jse.encrypt(password);client.request.post(&#x27;/login&#x27;, &#123; username: username, password: encodePassword, key: key // 标识字符串，后台使用对应的密钥进行解密&#125;); 已经通过RSA加密的内容进行解密（一般不会这么做，privateKey是不能暴露出来的）： 12345import JsEncrypt from &#x27;jsencrypt&#x27;;let jse = new JsEncrypt();jse.setPrivateKey(privateKey);let decodePassword = jse.decrypt(encodePassword); 这样就完成一次RSA登录流程 offsetTop的相对偏移问题offsetTop是元素到offsetParent顶部的距离，offsetParent是距离元素最近的一个具有定位的祖宗元素（relative，absolute，fixed），若祖宗都不符合条件，offsetParent为body 使用ajax的方式下载文件一直使用的url下载方式只能为get【使用window.location.open或建立一个假的a标签或使用iframe加载路径】，而且并不是一个ajax请求，返回的是一个文件流，带有后端文件名称的文件。但这种方式有个问题，就是不知道后端能够下载文件的时机。假如这个文件是一个后端动态生成的excel文件，那么距离生成会有一段时间，传统的url下载方式并不知道后端什么时候才能下载 以下为使用ajax的方式下载文件，配合blob二进制格式，以axios为例的伪代码： 123456789101112131415161718192021222324252627282930313233function downFile(url, parameter) &#123; return axios(&#123; url: url, params: parameter, method:&#x27;get&#x27; , responseType: &#x27;blob&#x27; &#125;)&#125;// 这里的fileName完全自定义，但如果想获取文件本来的名字就需要改接口function handleExportXls(fileName) &#123; let url = &#x27;/download&#x27;; let param = &#123; id: 10001 &#125;; downFile(url, param).then((data) =&gt; &#123; if (!data) &#123; alert(&quot;文件下载失败&quot;); return &#125; if (typeof window.navigator.msSaveBlob !== &#x27;undefined&#x27;) &#123; window.navigator.msSaveBlob(new Blob([data]), fileName + &#x27;.xls&#x27;) &#125; else &#123; let url = window.URL.createObjectURL(new Blob([data])) let link = document.createElement(&#x27;a&#x27;) link.style.display = &#x27;none&#x27; link.href = url link.setAttribute(&#x27;download&#x27;, fileName + &#x27;.xls&#x27;) document.body.appendChild(link) link.click() document.body.removeChild(link); //下载完成移除元素 window.URL.revokeObjectURL(url); //释放掉blob对象 &#125; &#125;)&#125; 这样就可以在不跳转的情况下，下载ajax请求的二进制文件 但这时的文件名是需要前端定义的，如何知道后端的这个文件是什么名称？可以通过后端的配合，设置响应头一个属性，前端取响应头的属性然后赋值即可 例子： 123456789101112131415161718this.$axios(&#123; method: params.method, url: params.url, data: params.data, responseType: &#x27;blob&#x27; // 指明返回格式,&#125;).then(res =&gt; &#123; // 这里尤其需要注意, &#x27;\\ufeff&#x27; 用于解决乱码问题, blob可以解决数据量大导致网络失败. const blob = new Blob([&#x27;\\ufeff&#x27; + res.data], &#123; type: &#x27;text/csv;charset=utf-8&#x27; &#125;) const url = window.URL.createObjectURL(blob) // 通过创建a标签实现 const link = document.createElement(&#x27;a&#x27;) link.href = url // 对下载的文件命名 link.download = decodeURI(res.headers[&#x27;content-disposition&#x27;].split(&#x27;=&#x27;)[1]) || &#x27;发货单导出数据表.csv&#x27; document.body.appendChild(link) link.click() document.body.removeChild(link)&#125;) 注意content-disposition这个属性能在请求调试里看到，但如果res.headers怎么都取不到的话，需要在服务器端配置一个属性： 1Access-Control-Expose-Headers: Content-Disposition 参考：https://stackoverflow.com/questions/37897523/axios-get-access-to-response-header-fields In case of CORS requests, browsers can only access the following response headers by default: Cache-Control Content-Language Content-Type Expires Last-Modified Pragma If you would like your client app to be able to access other headers, you need to set the Access-Control-Expose-Headers header on the server: 1Access-Control-Expose-Headers: Access-Token, Uid 获取布局信息的操作时，会强制队列刷新比如当你访问以下属性或者使用以下方法： offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight getComputedStyle() getBoundingClientRect 以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，最好避免使用上面列出的属性，他们都会刷新渲染队列。如果要使用它们，最好将值缓存起来。 但强制清空队列也有好处，可以解决display:none转场的transition失效问题： 123el.style.display = &#x27;block&#x27;;el.offsetHeight;el.style.transform = &#x27;translate3d(100px, 0, 0)&#x27;; 假如元素设置了transition，且display为none，如果不使用el.offsetHeight这句强制刷新队列，那么转场的动画就会失效 混合开发时web端和原生端的请求的不同 web端请求 web端发送请求是基于XMLHttpRequest或fetch 浏览器同源政策CORS安全限制，需要后端设置请求头或设置服务器代理转发 不够安全，无法网络优化，原生端无法对请求进行监控或加密 原生端请求，web端利用JSBridge调起原生端请求 没有浏览器跨域限制 安全加密，签名校验 弱网优化，流量优化 原生端可以对请求进行压缩 甚至可以将http请求替换成rpc（远程过程调用）这种节省流量的方法，利用私有协议请求数据（底层变了） 混合开发的JSBridge实现原理web端调用原生端方法： 拦截URL Schema，可使用alert等，原生端会对其进行拦截 原生端注入JSAPI，注入一个全局对象，web端可以直接调用 原生端调用web端方法： web端定义一个全局对象，原生端直接执行js字符串代码 带有回调的原理： web端发起时，利用JSBridge调用原生端方法，原生端又执行web端的js字符串代码，进行两次跨端的操作，是需要两边都约定好协议和全局对象 原生端发起原理与上面相同 由于代码繁琐或有坑，一般采用开源里比较成熟的JSBridge，会带有封装好的webview和JSAPI SSO单点登录方案SSO单点登录有两种方案，一种是Domain相同的，一种是Domain不相同的 Domain相同的SSO接入非常简单，逻辑大多是后台实现，就是在response的时候进入setCookie操作，同时指定Domain，例如.bilibili.com，这样所有是这个Domain都能够共享cookie 另一种是Domain不相同的接入。加入不同的网页的端的Domain都不相同，这时候分别需要他们的后台进行SSO接入，具体就是放出一个接口，这个接口在被请求成功的时候会对对应的前台页面的Domain下写入cookie，为了确保这样，通常都是不同端的前台和后台使用代理请求，确保在同一个域里。然后从SSO里调用这些后台的接口，后台就会对对应的前台写入cookie 关于window.open()的使用事项window.open()可以指定内容： 1234567891011const newWin = window.open();if (!newWin) &#123; return;&#125;newWin.document.write(item.content);newWin.document.body.style.width = &#x27;1000px&#x27;;newWin.document.body.style.margin = &#x27;0 auto&#x27;;if (item.title === undefined) &#123; item.title = &#x27;标题&#x27;;&#125;newWin.document.title = item.title; 然后，发现window.open()拦截是有条件的。一般通过用户的点击事件触发的在新标签页中打开链接，浏览器是不会拦截的，因为这种形式打开新窗口浏览器会认为是用户自己需要的。 在我的项目中，是需要在ajax异步请求成功后需要在新窗口中打开返回的url地址，使用window.open()会被拦截，因为在异步队列里进行弹窗，浏览器认为该操作不是用户主动触发的，所以会拦截。 ajax请求由异步改为同步。(async:false) (测试有效) 1234567891011121314$.ajax(&#123; async: false, // 该值为必须的 url: &quot;请求地址&quot;, type: &quot;post&quot;, success: function (data) &#123; var data = JSON.parse(data), result = data.result; if (result == &quot;0&quot;) &#123; window.open(&quot;新的页面&quot;); &#125;else&#123; …… //相关处理 &#125; &#125;&#125;); 递归遍历父元素找到对应的DOM元素1234function findAncestor (el, cls) &#123; while ((el = el.parentElement) &amp;&amp; !el.classList.contains(cls)); return el;&#125; 安装node-sass被墙解决方法1npm i node-sass --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/ 找到树中指定id的所有父节点(或包括自己)1234567891011121314151617181920212223242526272829303132333435363738394041424344const treeData = [&#123; id: 1, children: [&#123; id: 2, children: [&#123; id: 3, &#125;, &#123; id: 4, &#125;], &#125;],&#125;, &#123; id: 5, children: [&#123; id: 6, &#125;],&#125;];let relateNodes = []const getRelateNodes = (his = [], targetId = null, tree = []) =&gt; &#123; for (const item of tree) &#123; const children = item.children || [] if (item.id === targetId) &#123; // 如果只要返回父元素们，就写成relateNodes = his relateNodes = [...his, item] return true &#125; else if (children.length &gt; 0) &#123; const history = [...his] history.push(item) // 终止递归的条件 if (getRelateNodes(history, targetId, children)) &#123; break &#125; &#125; &#125;&#125;// 要查找的对象里存在的idconst id = 4getRelateNodes([], id, treeData)// 返回各个父元素的对象合集，可用于修改数据，做像树组件的展开等数据变更console.log(relateNodes) 遍历树把该层属于第几层树的属性写进去123456789101112131415161718192021222324252627282930313233 const treeData = [&#123; id: 1, children: [&#123; id: 2, children: [&#123; id: 3, &#125;, &#123; id: 4, &#125;], &#125;], &#125;, &#123; id: 5, children: [&#123; id: 6, &#125;], &#125;];// 第几层递归 let level = 0 const fn = (arr = [], level) =&gt; &#123; for (let i = 0; i &lt; arr.length; i++) &#123; const item = arr[i] item.__level = level if (!item.children) item.children = [] if (Array.isArray(item.children) &amp;&amp; item.children.length) &#123; fn(item.children, level + 1) &#125; &#125; &#125; fn(treeData, level) console.log(treeData) scrollTo实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function easeInOutQuad(t, b, c, d) &#123; t /= d / 2 if (t &lt; 1) &#123; return c / 2 * t * t + b &#125; t-- return -c / 2 * (t * (t - 2) - 1) + b&#125;const requestAnimFrame = (function() &#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) &#123; window.setTimeout(callback, 1000 / 60) &#125;&#125;)()function move($el, amount) &#123; if ($el) &#123; $el.scrollTop = amount &#125; else &#123; document.documentElement.scrollTop = amount document.body.parentNode.scrollTop = amount document.body.scrollTop = amount &#125;&#125;function position($el) &#123; if ($el) &#123; return $el.scrollTop &#125; else &#123; return document.documentElement.scrollTop || document.body.parentNode.scrollTop || document.body.scrollTop &#125;&#125;export default function scrollTo($el, to, duration, callback) &#123; const start = position($el) const change = to - start const increment = 20 let currentTime = 0 duration = (duration != null) ? 500 : duration let animateScroll = function() &#123; currentTime += increment const val = easeInOutQuad(currentTime, start, change, duration) move($el, val) if (currentTime &lt; duration) &#123; requestAnimFrame(animateScroll) &#125; else &#123; if (callback &amp;&amp; typeof (callback) === &#x27;function&#x27;) &#123; callback() &#125; &#125; &#125; animateScroll()&#125; 根据数组对象的某个字段去重1234function uniqueArrayByObjectKey(arr, key) &#123; const res = new Map() return arr.filter(item =&gt; !res.has(item[key]) &amp;&amp; res.set(item[key], 1))&#125; 简单数组去重123function uniqueArray(arr) &#123; return Array.from(new Set(arr))&#125; 多语言某些在中间需要替换语言例如：LANG &#x3D; “The quantity of selected products:XXX; Subtotal:XXX” replacement &#x3D; [1, 10] transformI18n(LANG, replacement) 12345678function transformI18n(key, replacement) &#123; if (!Array.isArray(replacement)) &#123; replacement = [replacement] &#125; const regex = /(XXX)+/gi let count = 0 return i18n.t(key).replace(regex, () =&gt; replacement[count++])&#125;","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"}]},{"title":"微信工作经验总结","date":"2019-05-27T14:20:28.000Z","path":"2019/05/27/微信工作经验总结/","text":"记一次微信公众号&#x2F;h5支付 公众号支付，https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&amp;index=6 第三方H5支付，https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=15_4 具体步骤： 用户选择商品，提交订单，生成订单号，这时候金额什么的都会保存在后台算，不需要前端送任何关于钱的字段 如果是公众号JSAPI支付，需要将这个订单号传到后台，生成一个签名，返回的字段里面包含公众号id，时间戳，随机字符串，签名方式，签名等 使用这些签名的字段调用JSAPI 在回调里处理成功和失败 如果是h5支付，需要将订单号请求另一个接口，返回一个外部链接mwebUrl，然后拼接一个支付回调地址&amp;redirect_url&#x3D;，直接使用window.location.href将地址转到外部链接，就会h5就会进行支付了 注意：就算判断了支付成功，回调里也不能直接做成功的处理，到最后有可能由于各种原因失败，这时候一般都是判断支付成功后，跳到另一个页面，然后轮询这个订单的状况，那时候返回支付成功的时候，才算是真的成功，后台会得到各种信息，交易流水，交易时间等 注意：h5支付如果订单超时，一般时间比较短，比使用JSAPI的方法短很多，这时候mwebUrl是不会返回回来的 注意：已经生成订单的交易后台如果对交易金额进行修改，在继续交易用原订单号请求签名的时候，就会报错，走到了catch，不允许交易 注意：调用公众号JSAPI支付的时候，需要在平台里维护支付的url，不然会在调用JSAPI的时候走到失败的回调，各种报错会有错误提示信息显示，根据提示处理即可","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"},{"name":"微信","slug":"微信","permalink":"https://sellenite.github.io/tags/%E5%BE%AE%E4%BF%A1/"}]},{"title":"CSS工作经验总结","date":"2019-05-17T14:44:25.000Z","path":"2019/05/17/CSS工作经验总结/","text":"使用line-height垂直居中时，要注意border的设置将border设置为一个很粗的值时再进行垂直居中设置，line-height和height和border都在同一个元素设置时，会有偏差，这时候解决的方法就是将border的设置放置在此对象的外层 使用line-height，越大的时候，安卓和ios差距越大，尽量在移动端不要使用line-height进行垂直居中，多使用flex flex左边固定宽度，右边动态高度实现123456789101112.line &#123; display: flex; width: 200px;&#125;.left &#123; width: 30px&#125;.right &#123; flex: 1;&#125; 123456&lt;div class=&quot;test&quot;&gt; &lt;div class=&quot;line&quot;&gt; &lt;div class=&quot;left&quot;&gt;固定宽度&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;动态高度，文字多的时候会换行撑开&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; flex左边固定宽度，右边强制不换行，超出省略号【有坑】在flex为1的容器中，设置了里面的元素100%长度且超出省略，这时候外容器并不会像想象中那样，而是外容器的宽度随着里面的长度改变而改变，这是由于flex布局的问题，需要在外容器加上width: 0或overflow: hidden来解决，具体代码如下： 1234567891011121314151617181920212223242526.line &#123; display: flex; width: 200px;&#125;.left &#123; width: 30px&#125;.right &#123; flex: 1; /* 必须，使用了不会让flex一直延伸 */ overflow: hidden; /* 或使用以下代码 */ width: 0; /* 必须同时使用，实测火狐只有width: 0还不够，需要加上min-width */ min-width: 0;&#125;.nowrap &#123; display: inline-block; width: 100%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125; 12345678&lt;div class=&quot;test&quot;&gt; &lt;div class=&quot;line&quot;&gt; &lt;div class=&quot;left&quot;&gt;123&lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;span class=&quot;nowrap&quot;&gt;需要单行显示超出省略的内容&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 上面的二种方法都可以达到我们需要的效果，即给 content 设置了 flex 为 1 的时候，它会动态的获得父容器的剩余宽度，且不会被自己的子元素把内容撑开。 记得实现单行文字超出省略需要以下条件： 将css设置在包含文字的元素上 元素需要固定高度 元素设置以下css属性 white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 流程实现（stepBar）结构可以参考elementUI的Steps组件，实现比较取巧，组件什么的可以通过这种结构进行拓展。总的来说line是通过位移实现的，最后一个需要需要隐藏 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556.test &#123; display: flex; width: 500px;&#125;.item &#123; flex: 1;&#125;.line-wrapper &#123; position: relative; display: flex; justify-content: center; align-items: center;&#125;/* 重点 */.line &#123; position: absolute; height: 1px; width: 100%; background: #CCC; /* 位移重点 */ left: 50%; right: -50%;&#125;/* 最后一个是不用显示的，line需要位移 */.item:last-of-type .line-wrapper .line &#123; display: none;&#125;.point &#123; position: relative; z-index: 1; display: inline-block; width: 9px; height: 9px; border: 2px solid #FFF; background: #CCC; border-radius: 50%;&#125;.content &#123; display: flex; justify-content: center; align-items: center;&#125;.item.pass .line,.item.pass .point &#123; background: #a6d5f3;&#125;.item.current .point &#123; background: #2aa5f3;&#125; 1234567891011121314151617181920212223242526272829303132&lt;div class=&quot;test&quot;&gt; &lt;!-- 已经过去的状态 --&gt; &lt;div class=&quot;item pass&quot;&gt; &lt;div class=&quot;line-wrapper&quot;&gt; &lt;div class=&quot;line&quot;&gt;&lt;/div&gt; &lt;span class=&quot;point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;span&gt;第一步&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 当前进行状态 --&gt; &lt;div class=&quot;item current&quot;&gt; &lt;div class=&quot;line-wrapper&quot;&gt; &lt;div class=&quot;line&quot;&gt;&lt;/div&gt; &lt;span class=&quot;point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;span&gt;第二步&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 还无进行的状态 --&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;line-wrapper&quot;&gt; &lt;div class=&quot;line&quot;&gt;&lt;/div&gt; &lt;span class=&quot;point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;span&gt;第三步&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 文字两端对齐技巧原理：利用text-align: justify进行两端对齐，但是由于文字只有一行的话是不会生效的，这时候需要靠伪元素伪造一行，直接在需要对齐的文字里加入这个class即可： 注意，使用了这个方法后生效的元素会高了很多，不知道什么原因，需要另外加height调整高度处理 1234567891011.justified &#123; text-align: justify;&#125;.justified:after &#123; content: &#x27;&#x27;; display: inline-block; width: 100%; /* opera浏览器需要添加 vertical-align:top 才能完全解决底部多余的空白 */ vertical-align:top;&#125; 文字超出多少行省略实现所遇到的问题：-webkit-box-orient: vertical 在使用 webpack 打包的时候这段代码会被删除掉，原因是 optimize-css-assets-webpack-plugin 这个插件的问题。 使用scss，传入行数即可 12345678910.line-camp( @clamp:2 ) &#123; text-overflow: -o-ellipsis-lastline; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: @clamp; /*! autoprefixer: off */ -webkit-box-orient: vertical; /* autoprefixer: on */&#125; 注意line-clamp是一个不规范的css属性，一般只能兼容webkit内核的浏览器，如果有兼容需要的话需要另寻方法 内联首屏关键CSS像饿了么那样，加载时候，会出现一个比较捡漏的大概样式，其实有一种专门的称呼，叫做Critical CSS。这里做个记录 从 html 元素继承 box-sizing我不希望每次都重写一遍border-box，而是希望他是继承而来的，那么我们可以使用如下代码： 1234567html &#123; box-sizing: border-box;&#125;*, *:before, *:after &#123; box-sizing: inherit;&#125; 这样的好处在于他不会覆盖其他组件的 box-sizing 值，又无需为每一个元素重复设置 box-sizing: border-box; IOS中滑动页面fixed浮动的问题fixed元素如果不是在body的第一下级，会有往上滑动遮罩的问题，或向下滑动也会有遮罩的问题 类似以下结构，button为fixed是没有问题的： 12345&lt;body&gt; &lt;div class=&quot;other&quot;&gt;其他&lt;/div&gt; &lt;div class=&quot;container&quot;&gt;&lt;/div&gt; &lt;div class=&quot;button&quot;&gt;按钮&lt;/div&gt;&lt;/body&gt; 但如果是以下那样，就会有问题（button为fixed，固定在最底）： 123456&lt;body&gt; &lt;div class=&quot;other&quot;&gt;其他&lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;button&quot;&gt;按钮&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 像以上这种情况只能使用relative+absolute了 父元素设置了min-height：100%, 子元素设置height:100%无效通过google知道了 webkit（chrom&#x2F;safari）bug：有最小高度的父盒子里面的子元素不能继承高度属性，父元素只能设置height让子元素继承 在vue里的scoped状态里可以修改element-ui等全局样式，使用局部样式覆盖如下代码，这样就可以局部修改scoped状态下wrapper的el-form-item样式，由于el-form-item是全局样式，不使用&#x2F;deep&#x2F;在scoped状态下是无法修改的 12345.wrapper &#123; /deep/ .el-form-item &#123; /* ... */ &#125;&#125; webpack下scss可以将变量作为js的变量使用在scss里输出变量： 12345$menuBg: #3c3c3d;:export &#123; menuBg: $menuBg;&#125; 在js里就可以这么使用： 123import variables from &#x27;@/common/scss/variables.scss&#x27;;variables.menuBg 参考资料： the :export directive is the magic sauce for webpackhttps://www.bluematador.com/blog/how-to-share-variables-between-js-and-sass input框在flex里的长度问题input框有默认的宽度，直接写在flex容器里会有布局问题，一般解决方法是在外面再包一层div作为flex的容器，然后包着input，input设置width为100%处理 scss里变量传入calc的办法在calc里直接使用遍历或方法会失效，需要这样写： 1234.test &#123; height: calc(100% - #&#123;$header-height&#125;); width: calc(100% - #&#123;px2rem(30px)&#125;);&#125; flex实现sticky-footerflex也可以实现sticky-footer，相比传统的实现方式，要较为简单。在兼容性允许flex的情况下，优先使用这种布局会比较简单： 本质上是利用flex的方向和伸缩完成： 12345&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;header&quot;&gt;header&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;&lt;/div&gt; 12345678910.wrapper &#123; height: 100%; display: flex; flex-direction: column; overflow: auto;&#125;.main &#123; flex: 1;&#125; 全是英文和数字的情况会造成不换行解决办法注意在全是英文和数字的情况下，按照默认样式，是有可能不会自动换行而自动溢出的，需要在元素上以下属性： 12word-break: nomal;word-wrap: break-word; 浮动布局错位问题在使用栅栏布局或其他浮动布局的时候，如果有第二行浮动元素错位问题，需要考虑是否上一行有元素高度或行高过高，导致元素浮动错位 后端返回了换行符，前端如何换行后端返回了换行符，由于前端的css换行属性默认是不会换行的，需要通过设置css的white-space属性，设置为pre-line和pre-wrap都可以进行换行，区别是pre-line会把多个空格合并成一个，而pre-wrap不会，可以根据实际需求进行设置 不要使用fixed布局去嵌套fixed布局不要使用fixed布局去嵌套fixed布局，会引起zIndex和transform无法如愿的情况，或是引起iOS的滑动bug。最外层容器尽量不要使用fixed，因为可能会在里面再嵌套一些全局弹窗 例如 123456&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;div class=&quot;fullPage&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 以上代码，如果left，right，fullPage都设置为fixed，left的zIndex设置为2，right的zIndex设置为1，则fullPage无论设置多大，层级依然比left低，因为同级right的zIndex比left低，与子元素无关。需要将right的zIndex设置得比left高，fullPage的fixed的层级才会在left之上 href设为空时可以跳转到当前html的路径1&lt;a href&gt;跳到首页&lt;/a&gt; 这样设置就可以跳到当前html的路径，通常单页的404页跳转的时候可能会用到这个 fixed布局的相对定位问题position:fixed默认是相对浏览器定位的。如果想fixed定位相对父级容器定位，子元素定义好fixed后，不要添加:top,bottom,left,right样式,通过margin定位，即可实现相对父元素的效果，且固定位置不变，不用通过js去计算 添加css属性让任何事件无效给元素增加pointer-events: none;, 这样伪类元素可以点击穿透, 也就是能看到, 但是不触发任何默认事件(click等) border-1px最终实现方案，兼容pc和移动端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// 如果编译的时候提示编码的问题，百度修改ruby下sass的设定源码@mixin border-1px($directionList: bottom, $color: #ccc, $radius:(0, 0, 0, 0), $position: after) &#123; // 是否只有一个方向，type-of是sass判断变量类型的内置函数 // list是一种格式，类似这种：(top, right, bottom, left)，可使用each遍历 $isSingleDirection: type-of($directionList)==list; // 使用not对boolean进行取反 @if (not $isSingleDirection) &#123; $directionList: ($directionList); &#125; // 先设定普通pc状态下的样式 @each $direction in $directionList &#123; border-#&#123;$direction&#125;: 1px solid $color; &#125; // 判断圆角是list还是number @if(type-of($radius)==list) &#123; border-radius: nth($radius, 1) nth($radius, 2) nth($radius, 3) nth($radius, 4); &#125; @else &#123; border-radius: $radius; &#125; // 判断到是移动端时（移动端有dpr），使用伪类的方式实现，删除之前的样式 @media only screen and (-webkit-min-device-pixel-ratio: 2) &#123; &amp; &#123; position: relative; // 删除1像素密度比下的边框 @each $direction in $directionList &#123; border-#&#123;$direction&#125;: none; &#125; &#125; &amp;:#&#123;$position&#125; &#123; content: &quot;&quot;; position: absolute; top: 0; left: 0; display: block; width: 200%; height: 200%; transform: scale(0.5); box-sizing: border-box; padding: 1px; transform-origin: 0 0; pointer-events: none; border: 0 solid $color; @each $direction in $directionList &#123; border-#&#123;$direction&#125;-width: 1px; &#125; @if(type-of($radius)==list) &#123; border-radius: nth($radius, 1)*2 nth($radius, 2)*2 nth($radius, 3)*2 nth($radius, 4)*2; &#125; // unit用于检查单位是什么，unitless()检查带不带单位，单位是百分比直接赋值 @else if (unit($radius)==&#x27;%&#x27;) &#123; border-radius: $radius; &#125; @else &#123; border-radius: $radius*2; &#125; &#125; &#125; @media only screen and (-webkit-min-device-pixel-ratio: 3) &#123; &amp;:#&#123;$position&#125; &#123; @if(type-of($radius)==list) &#123; border-radius: nth($radius, 1)*3 nth($radius, 2)*3 nth($radius, 3)*3 nth($radius, 4)*3; &#125; @else if (unit($radius)==&#x27;%&#x27;) &#123; border-radius: $radius; &#125; @else &#123; border-radius: $radius*3; &#125; width: 300%; height: 300%; transform: scale(0.33333); &#125; &#125;&#125; 使用方法： 12345// 设定底下一条线，radius为10px@include border-1px(bottom, #eee, (10px 10px 10px 10px));// 设定四周都有线，radius为50%，即圆@include border-1px((top, right, bottom, left), #eee, 50%, before); 英文不会换行 word-break:break-alltransform不适用于inline元素","tags":[{"name":"CSS","slug":"CSS","permalink":"https://sellenite.github.io/tags/CSS/"}]},{"title":"常用HTTP状态码","date":"2019-03-27T15:29:50.000Z","path":"2019/03/27/常用HTTP状态码/","text":"状态码 英文 描述 200 OK 请求成功。一般用于GET与POST请求 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 304 Not Modified 协商缓存。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://sellenite.github.io/tags/HTTP/"}]},{"title":"call/apply/bind/new/create/instanceof原理","date":"2019-03-25T16:42:53.000Z","path":"2019/03/26/call-apply-bind-new-create-instanceof原理/","text":"call123456789101112Function.prototype.myCall = function(context) &#123; if (typeof this !== &#x27;function&#x27;) &#123; throw new TypeError(&#x27;Error&#x27;); &#125; context = context || window; const args = [...arguments].slice(1); // 将函数绑定到上下文 context.fn = this; const result = context.fn(...args); delete context.fn; return result;&#125; apply123456789101112131415Function.prototype.myApply = function(context) &#123; if (typeof this !== &#x27;function&#x27;) &#123; throw new TypeError(&#x27;Error&#x27;); &#125; context = context || window; context.fn = this; let result; if (arguments[1]) &#123; result = context.fn(...arguments[1]); &#125; else &#123; result = context.fn(); &#125; delete context.fn; return result;&#125; bind12345678910111213141516Function.prototype.myBind = function(context) &#123; if (typeof this !== &#x27;function&#x27;) &#123; throw new TypeError(&#x27;Error&#x27;); &#125; const _this = this; const args = [...arguments].slice(1); // bind需要返回一个函数 return function F() &#123; // 因为返回了一个函数，如果进行了new F()，需要重新制定this if (this instanceof F) &#123; return new _this(...args, ...arguments); &#125; // 合并参数执行 return _this.apply(context, [...args, ...arguments]); &#125;&#125; new123456789101112131415161718192021222324// 使用__proto__const myNew = function() &#123; // 创建一个对象 const obj = &#123;&#125;; const Constructor = [].shift.call(arguments); // obj原型指向原型链 obj.__proto__ = Constructor.prototype; // 使obj得到构造函数的属性 const result = Constructor.apply(obj, arguments); // 返回 return typeof result === &#x27;object&#x27; ? result : obj;&#125;// 使用Object.createconst myNew2 = function(Foo, ...args) &#123; const obj = Object.create(Foo.prototype); const result = Foo.apply(obj, args); if (typeof result === &#x27;object&#x27;) &#123; return result; &#125; else &#123; // 构造函数不返回对象时执行，一般情况下是执行这行 return obj; &#125;&#125; Object.create12345const myCreate = function(obj) &#123; let F = function() &#123;&#125;; F.prototype = obj; return new F();&#125; instanceof123456789101112131415161718// instanceof实现原理，本质是遍历原型链const myInstanceof = function(left, right) &#123; // 原本的instanceof只能根据原型链上判断，因此基础类型直接返回false if (typeof left !== &#x27;object&#x27;) &#123; return false; &#125; let prototype = right.prototype; left = left.__proto__; while (true) &#123; if (left == null) &#123; return false; &#125; if (left === prototype) &#123; return true; &#125; left = left.__proto__; &#125;&#125;;","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"}]},{"title":"Vue工作经验总结（2）","date":"2019-03-14T10:04:19.000Z","path":"2019/03/14/Vue工作经验总结（2）/","text":"props可以控制传入的限制，使用validator1234567891011121314151617const oneOf = (value, validList) =&gt; &#123; for (let i = 0; i &lt; validList.length; i++) &#123; if (value === validList[i]) &#123; return true; &#125; &#125; return false;&#125;props: &#123; size: &#123; validator(value) &#123; return oneOf(value, [&#x27;large&#x27;, &#x27;small&#x27;, &#x27;default&#x27;]) &#125;, default: &#x27;default&#x27; &#125;&#125; provide&#x2F;inject允许支持上下文特性，共享数据（类似react的context）123456789// 祖先组件provide() &#123; return &#123; form: this &#125;&#125;// 子组件，这样子组件就可以使用this.form访问到祖先组件的实例了inject: [&#x27;form&#x27;] 使用mixins高度抽象各类方法，方便复用使用mixins时，如果有定义created等函数的，会先执行mixins里的created，然后再执行组件里的created。如果mixins里有定义方法，然后组件里也定义了一个同样名称的方法，组件里的方法会覆盖mixins里的方法。 组件内使用$emit出来的事件，同样可以在本组件使用$on监听到123// 同一个组件this.$emit(&#x27;on-select&#x27;, selectValue);this.$on(&#x27;on-select&#x27;, (selectValue) =&gt; &#123;&#125;); Vue2.x废除了Vue1.x的$dispatch和$broadcast的方法，可以使用现有的$on和$emit实现 12345678910111213141516171819202122232425262728293031323334353637383940/** * Vue1.x * $dispatch用于向上级派发事件，只要是它的父级（一级或多级以上），都可以在组件内通过$on监听到 * $broadcast用于向下级广播时间，同样使用$on监听到 * 由于Vue2.x已经废弃这两个方法，使用$emit和$on替代，使用递归遍历方式可以模拟达到功能 * 根本原理是使用$emit可以在本组件使用$on监听到 */export default &#123; methods: &#123; // 需要指定谁接受这个信息 dispatch(componentName, eventName, params) &#123; let parent = this.$parent || this.$root; let name = parent.$options.name; // 循环往上遍历 while (parent &amp;&amp; (!name || name !== componentName)) &#123; parent = parent.$parent; if (parent) &#123; name = parent.$options.name; &#125; &#125; // 找到后触发emit，然后使用on就可监听到 if (parent) &#123; parent.$emit.apply(parent, [eventName, params]); &#125; &#125;, // 具名函数，子组件递归遍历查询使用 broadcast: function broadcast(componentName, eventName, params) &#123; this.$children.forEach((child) =&gt; &#123; let name = child.$options.name; if (name === componentName) &#123; child.$emit.apply(child, [eventName, params]); &#125; else &#123; broadcast.apply(child, [componentName, eventName, params]); &#125; &#125;); &#125; &#125;&#125; dispatch是用于子组件向祖先组件派发事件，与Vue1.x的方法不同，模拟的方法需要指定组件的名称。使用方法: 1234// 子组件this.dispatch(&#x27;form&#x27;, &#x27;on-select&#x27;, selectValue);// 祖先组件监听this.$on(&#x27;on-select&#x27;, (selectValue) =&gt; &#123;&#125;); broadcast是用于祖先组件向子组件广播事件，与Vue1.x的方法不同，模拟的方法同样需要指定组件的名称。使用方法: 1234// 祖先组件this.broadcast(&#x27;y-select&#x27;, &#x27;trigger-select&#x27;, value);// 子组件监听this.$on(&#x27;trigger-select&#x27;, (value) =&gt; &#123;&#125;); 5个很有用的找到任意组件的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/** * 由一个组件，向上找到最近的指定组件 * @param &#123;Object&#125; context 上下文 * @param &#123;String&#125; componentName 需要找的指定组件的name * @return &#123;Object&#125; 返回找到组件的实例 */function findComponentUpward(context, componentName) &#123; let parent = context.$parent; let name = context.$parent.$options.name; // 循环往上遍历 while (parent &amp;&amp; (!name || name !== componentName)) &#123; parent = parent.$parent; if (parent) &#123; name = parent.$options.name; &#125; &#125; return parent;&#125;/** * 由一个组件，向上找到所有的指定组件，递归使用组件比较少用，一般不用该方法 * @param &#123;Object&#125; context 上下文 * @param &#123;String&#125; componentName 需要找的指定组件的name * @return &#123;Array&#125; 返回找到组件的实例集合 */function findComponentsUpward(context, componentName) &#123; let parents = []; let parent = context.$parent; if (parent) &#123; if (parent.$options.name === componentName) &#123; parents.push(parent) &#125; // 递归遍历 return [ ...parents, ...findComponentsUpward(parent, componentName) ]; &#125; else &#123; return []; &#125;&#125;/** * 由一个组件，向下找到最近的指定组件，递归遍历子组件 * @param &#123;Object&#125; context 上下文 * @param &#123;String&#125; componentName 需要找的指定组件的name * @return &#123;Object&#125; 返回找到组件的实例 */function findComponentDownward(context, componentName) &#123; let children = context.$children; let child = null; if (children.length &gt; 0) &#123; for (let item of children) &#123; if (item.$options.name === componentName) &#123; child = item; break; &#125; else &#123; // 跟Emitter不同，这个函数主要要返回，在第一次递归的时候必须赋值拿到后来递归的返回值 child = findComponentDownward(item, componentName); if (child) break; &#125; &#125; &#125; return child;&#125;/** * 由一个组件，向下找到所有指定的组件，递归遍历子组件，这个比网上遍历所有父组件有用 * @param &#123;Object&#125; context 上下文 * @param &#123;String&#125; componentName 需要找的指定组件的name * @return &#123;Array&#125; 返回找到组件的实例集合 */function findComponentsDownward(context, componentName) &#123; let ret = []; let children = context.$children; if (children.length &gt; 0) &#123; for (let item of children) &#123; if (item.$options.name === componentName) &#123; ret.push(item); &#125; // 递归遍历 ret = [ ...ret, ...findComponentsDownward(item, componentName) ] &#125; return ret; &#125; else &#123; return []; &#125;&#125;/** * 由一个组件，找到指定组件的兄弟组件 * @param &#123;Object&#125; context 上下文 * @param &#123;String&#125; componentName 需要找的指定组件的name * @param &#123;Boolean&#125; exceptMe 是否除去组件本身 * @return &#123;Array&#125; 返回找到组件的实例集合 */function findBrothersComponents(context, componentName, exceptMe = true) &#123; let parent = context.$parent; let children = parent.$children; let brothers = children.filter((child) =&gt; &#123; return child.$options.name === componentName; &#125;); // 利用vue实例里的_uid属性的值是唯一的做筛选 let index = brothers.findIndex((brother) =&gt; brother._uid === context._uid); if (exceptMe) &#123; brothers.splice(index, 1); &#125; return brothers;&#125;export &#123; findComponentUpward, findComponentsUpward, findComponentDownward, findComponentsDownward, findBrothersComponents&#125;; 导入后，使用方法： 1findComponentUpward(this, &#x27;y-checkbox-group&#x27;); 利用eventBus实现跨组件通信首先建立一个js文件，导出一个vue实例： 12import Vue from &#x27;vue&#x27;;export default new Vue(); 实例方法里有$emit和$on方法，同一个实例中$emit出来的事件可以在$on里监听到，利用这个原理可以实现跨组件通信： 分别导入这个实例 需要传出方：Bus.$emit(&#39;eventBus&#39;, &#39;eventBus&#39;); 接收方：Bus.$on(&#39;eventBus&#39;, (val) =&gt; &#123;&#125;); import一个.vue文件，其实返回的就是export的那个对象，具体形式是这样的：1234567&#123; beforeCreate: [ƒ], beforeDestroy: [ƒ], data: ƒ data(), methods: &#123;add: ƒ, remove: ƒ&#125;, render: ƒ ()&#125; 其中render函数是通过Webpack的vue-loader编译出来的 :is可以绑定一个组件对象，或可以是一个String，比如标签名或组件名v-bind&#x3D;”{a:1, b:2}”可以绑定一个有属性的对象，然后props里使用递归组件的使用递归组件就是指组件在模板中调用自己，开启递归组件的必要条件，就是在组件中设置一个 name 选项。 实现一个递归组件的必要条件是： 要给组件设置 name； 要有一个明确的结束条件 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;my-component :count=&quot;count + 1&quot; v-if=&quot;count &lt;= 5&quot;&gt;&lt;/my-component&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;my-component&#x27;, props: &#123; count: &#123; type: Number, default: 1 &#125; &#125;&#125;&lt;/script&gt; vue 2.2.0以上，可以指定v-model的语法糖传入的指定值子组件设置model： 1234567export default &#123; ..., model: &#123; prop: &#x27;number&#x27;, event: &#x27;change&#x27; &#125;&#125; 然后子组件在接受props和设置事件时写入自定义的属性： 1234567891011121314export default &#123; ..., props: &#123; number: &#123; type: Number, default: 0 &#125; &#125;, methods: &#123; handelChange(e) &#123; this.emit(&#x27;change&#x27;, e.target.value); &#125; &#125;&#125; 父组件（v-model写法）： 1&lt;input-number v-model=&quot;inputNumberVal&quot; /&gt; 这样父子组件就完成了一次不是使用value&#x2F;input的v-model语法糖 vue2.3.0+的.sync 修饰符可以看做v-model使用的扩展版，可以绑定多个语法糖，本质还是在父组件上修改数据，并非在子组件 子组件里面的emit方式改变： 123456789101112131415export default &#123; ..., props: &#123; number: &#123; type: Number, default: 0 &#125; &#125;, methods: &#123; handelChange(e) &#123; // 注意这里使用的emit格式 this.emit(&#x27;update:number&#x27;, e.target.value); &#125; &#125;&#125; 父组件，绑定的属性后加上.sync： 1&lt;sync-number :number.sync=&quot;syncNumberVal&quot; /&gt; 看起来要比 v-model 的实现简单多，实现的效果是一样的。v-model 在一个组件中只能有一个，但 .sync 可以设置很多个，且有以下限制： 不能和表达式一起使用（如 v-bind:title.sync=&quot;doc.title + &#39;!&#39;&quot; 是无效的）； 不能用在字面量对象上（如 v-bind.sync=&quot;&#123; title: doc.title &#125;&quot; 是无法正常工作的）。 $nextTick原理nextTick源码 由于vue是异步执行DOM更新的，nextTick的作用就是将回调推到异步队列去执行，确保DOM已经更新完毕。分别使用了三种执行异步队列的方法，优雅降级： 如果浏览器支持Promise，使用promise.then延迟调用 MutationObserver是h5新加的一个功能，其功能是监听dom节点的变动，在所有dom变动完成后，执行回调函数 以上都不支持就使用setTimeout延迟器 现在2.6版本的走的全是microtasks，microtasks比macrotasks的优先级高很多，如果遇到nextTick后获取的DOM不符合预期，直接使用setTimeout延迟20毫秒，确保DOM更新即可 We are reverting back to microtasks everywhere and will remove withMacroTask entirely in 2.6. macrotasks: setTimeout setInterval setImmediate requestAnimationFrame I&#x2F;O UI rendering microtasks: process.nextTick Promises Object.observe MutationObserver 123setTimeout(() =&gt; &#123; cb();&#125;, 20); 参考资料： https://juejin.im/post/5a1af88f5188254a701ec230 https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/ vue数组更新及小技巧可以更新数组视图的操作有： push pop shift unshift splice sort reverse 不可更新数组的操作有： 当利用索引直接设置一个项时，例如：this.items[index] = value 当修改数组的长度时，例如：this.items.length = newLength 利用索引修改一个项，并且可以更新视图的技巧是，先复制一个完全一样的，然后修改对应的索引。虽然修改一个索引不会更新，但修改整个指向数据就会更新： 123456handler(val) &#123; // 浅复制/深复制一个数组，这里为了方便使用浅复制 const data = [...this.items]; data[2] = val; this.items = data;&#125; 使用了keep-alive后，在router-view里设定path属性可以加载多个参数不同，且使用同一个组件的路由以上情况多在后台管理模式下常见，即多个标签切换，例如编辑，是根据params或query进行加载不同的详情，但由于使用的是同一个组件，在使用keep-alive后，会导致每次加载的都是已经缓存下来的组件，这时候如果在每个路由上都定义不同的path，即使是同一个组件，也会进行重新的加载 123&lt;keep-alive :include=&quot;cachedViews&quot;&gt; &lt;router-view :key=&quot;$route.path&quot; /&gt;&lt;/keep-alive&gt; 其中cachedViews是一个组件内名字的数组，只有匹配上，才会被keep-alive vue-router编程式路由跳转问题vue-router在使用this.$router.push的时候，需要注意path和params不能公用，path会覆盖params，但可以使用query。如果需要使用params进行跳转，需要使用name+params的组合进行跳转 不要将this.$route传入某个地方由于this.$route里的match属性存在循环引用的问题，假如每次路由跳转将整个this.$route传入vuex里进行管理，会造成内存泄露导致卡死的问题，需要重新建立一个完全独立的副本。注意由于循环引用，深复制是会失败的，建立副本直接每个值都赋值一遍就好，重要的也就是path，query，params，meta，fullPath这些 在better-scroll里使用定位问题在使用better-scroll，如果需要使用一些特殊定位，置顶等效果，不要将需要定位的元素写在第一个子元素或第一个子元素里，由于better-scroll实例化之后的滚动效果只对第一个子元素生效，写在第一个子元素里实例化后的transform会使所有定位失效 slot的使用（新旧两种方法）注意。slot不仅能向父组件传递当前作用域的数据，还能传递方法 子组件v-slot： 12345678910111213141516171819202122232425&lt;template&gt; &lt;!-- 知识点：具名插槽，插槽传递props，传递methods --&gt; &lt;div class=&quot;v-slot&quot;&gt; &lt;slot name=&quot;namedSlot&quot; :user=&quot;user&quot;&gt;&#123;&#123; user.lastName &#125;&#125;&lt;/slot&gt; &lt;slot name=&quot;button&quot; :close=&quot;close&quot;&gt;&lt;/slot&gt; &lt;slot :user=&quot;user&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; user: &#123; lastName: &#x27;Satellite&#x27; &#125; &#125; &#125;, methods: &#123; close() &#123; alert(&#x27;close method from inner&#x27;) &#125; &#125;&#125;&lt;/script&gt; 2.6.0以下引用方式： 1234567891011&lt;v-slot&gt; &lt;!-- 老版无法使用解构 --&gt; &lt;template slot=&quot;namedSlot&quot; slot-scope=&quot;slotProps&quot;&gt; &lt;h1&gt;&#123;&#123; slotProps.user.lastName &#125;&#125;&lt;/h1&gt; &lt;/template&gt; &lt;!-- slot不用template，直接写在上面也可以 --&gt; &lt;!-- slot可以传递函数 --&gt; &lt;button slot=&quot;button&quot; slot-scope=&quot;methodsProps&quot; @click=&quot;methodsProps.close&quot;&gt; 测试slot传过来的方法 &lt;/button&gt;&lt;/v-slot&gt; 2.6.0以上引用方式： 1234567891011121314151617181920&lt;v-slot&gt; &lt;template v-slot:namedSlot=&quot;slotProps&quot;&gt; &lt;h1&gt;&#123;&#123; slotProps.user.lastName &#125;&#125;&lt;/h1&gt; &lt;/template&gt; &lt;!-- 使用解构 --&gt; &lt;template v-slot:namedSlot=&quot;&#123;&#123; user &#125;&#125;&quot;&gt; &lt;h1&gt;&#123;&#123; user.lastName &#125;&#125;&lt;/h1&gt; &lt;/template&gt; &lt;!-- 使用缩写 --&gt; &lt;template #namedSlot=&quot;&#123;&#123; user &#125;&#125;&quot;&gt; &lt;h1&gt;&#123;&#123; user.lastName &#125;&#125;&lt;/h1&gt; &lt;/template&gt; &lt;!-- 使用缩写的时候，default插槽需要写出来 --&gt; &lt;p #default=&quot;&#123;&#123; user &#125;&#125;&quot;&gt;user.lastName&lt;/p&gt; &lt;!-- slot不用template，直接写在上面也可以 --&gt; &lt;!-- slot可以传递函数 --&gt; &lt;button v-slot:button=&quot;methodsProps&quot; @click=&quot;methodsProps.close&quot;&gt; 测试slot传过来的方法 &lt;/button&gt;&lt;/v-slot&gt; 使用全局指令开发点击波纹效果其实本质上就是点击的时候在元素里加入一个元素，元素做放大动画，需要css3支持 waves.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import &#x27;./waves.scss&#x27;;const context = &#x27;@@wavesContext&#x27;;function handleClick(el, binding) &#123; // binding.value，指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2 // 这样也可以将event传进来，神奇 function handle(e) &#123; const type = binding.value || &#x27;hit&#x27;; // 可输入center或hit const opts = &#123; ele: el, // 波纹作用元素 color: &#x27;rgba(0, 0, 0, 0.15)&#x27;, // 波纹颜色 type &#125;; const target = opts.ele; console.log(target, e); if (target) &#123; target.style.position = &#x27;relative&#x27;; target.style.overflow = &#x27;hidden&#x27;; const rect = target.getBoundingClientRect(); let ripple = target.querySelector(&#x27;.waves-ripple&#x27;); if (!ripple) &#123; ripple = document.createElement(&#x27;span&#x27;); ripple.className = &#x27;waves-ripple&#x27;; ripple.style.width = ripple.style.height = Math.max(rect.width, rect.height) + &#x27;px&#x27;; target.appendChild(ripple); &#125; else &#123; ripple.className = &#x27;waves-ripple&#x27;; &#125; switch (opts.type) &#123; case &#x27;center&#x27;: // 访问offsetHeight可以重绘重新触发动画 // 为了使蒙层置于中间，注意是使用定位 ripple.style.top = rect.height / 2 - ripple.offsetHeight / 2 + &#x27;px&#x27;; ripple.style.left = rect.width / 2 - ripple.offsetWidth / 2 + &#x27;px&#x27;; break; default: ripple.style.top = (e.pageY - rect.top - ripple.offsetHeight / 2 - document.documentElement.scrollTop || document.body.scrollTop) + &#x27;px&#x27;; ripple.style.left = (e.pageX - rect.left - ripple.offsetWidth / 2 - document.documentElement.scrollLeft || document.body.scrollLeft) + &#x27;px&#x27;; &#125; ripple.style.backgroundColor = opts.color; ripple.className = &#x27;waves-ripple z-active&#x27;; return false; &#125; &#125; // 单例 if (!el[context]) &#123; el[context] = &#123; removeHandle: handle &#125; &#125; else &#123; el[context].removeHandle = handle &#125; return handle;&#125;export default &#123; // 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 bind(el, binding) &#123; el.addEventListener(&#x27;click&#x27;, handleClick(el, binding), false); &#125;, // 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 inserted(el) &#123; &#125;, /** * 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。 * 但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 */ update(el, binding) &#123; el.removeEventListener(&#x27;click&#x27;, el[context].removeHandle, false) el.addEventListener(&#x27;click&#x27;, handleClick(el, binding), false) &#125;, // 指令所在组件的 VNode 及其子 VNode 全部更新后调用 componentUpdated() &#123; &#125;, // 只调用一次，指令与元素解绑时调用。 unbind(el) &#123; el.removeEventListener(&#x27;click&#x27;, el[context].removeHandle, false); el[context] = null; delete el[context]; &#125;&#125; main.js 12import waves from &#x27;@/directive/waves/waves.js&#x27;;Vue.directive(&#x27;waves&#x27;, waves); 使用： 12&lt;div class=&quot;btn&quot; v-waves&gt;测试waves&lt;/div&gt;&lt;div class=&quot;btn&quot; v-waves=&quot;&#x27;center&#x27;&quot;&gt;测试waves&lt;/div&gt; router初始化，回到new Router()的时候由于前端有时需要做权限处理，这时候就需要做权限处理，使用动态路由的router.addRoutes()，动态添加路由。 有以下场景：new Router()的时候已经添加里基础的路由，也通过addRoutes添加了对应权限的路由。这时候角色退出登录，登入另一个角色，角色拥有其他权限，这时候就需要清除之前添加的路由，回到初始基础路由的时候再一次动态添加对应角色的路由 由于vue-router官方只有动态添加路由的api，没有提供删除动态路由的办法，有issue提供了以下方法： 初始创建的router实例，最终要返回的状态： 12345const createRouter = () =&gt; new Router(&#123; routes: constantRoutes&#125;)const router = createRouter() reset方法： 12345// Detail see: https://github.com/vuejs/vue-router/issues/1234#issuecomment-357941465export function resetRouter() &#123; const newRouter = createRouter() router.matcher = newRouter.matcher // reset router&#125; ElementUI的table切换错乱解决方案ElementUI存在一个问题，譬如进行两个table切换或动态渲染table列，会有渲染错乱的问题，有两个解决方案 1、在每个el-table-column上设置独一无二的key值，千万不要设置一个随机数值2、每个column都使用scope渲染 图片预览插件vue-photo-preview的实现插件地址：https://github.com/826327700/vue-photo-preview 实现原理：本插件是使用photoSwipe这个插件进行二次开发，使用全局mixins，将设定特定属性的元素取出来，获取图片地址，再按photoSwipe的数据格式进行传入调用 父子组件的渲染和监听顺序问题vue组件的渲染顺序是由内而外的，父组件的created要先于子组件的mounted，所以需要在父组件的created定义监听子组件的函数，使用监听一般都是父子组件关联比较大的 使用全局指令开发统一管理点击document有些弹出额外框的组件，像日历选择，tooltip等，都会有一种需求，就是要求点击组件外的地方能够使组件收起来，而这个实现的原理其实就是在组件加载的时候，对document加入监听函数，然后在组件销毁的钩子里移除这个监听，避免组件移除后监听函数还存在，垃圾无法被回收而造成内存泄露。 可以想象如果每个组件都要这么写的话，每个判断点击的地方是否在组件外的逻辑都要重新写，是很麻烦的事，这时候就可以利用全局指令，哪里需要判断的，加上就可以 以下代码取自ElementUI，需要注意判断点击的地方是否在组件内的判断条件就可以，全局指令的应用参考vue官网即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import Vue from &#x27;vue&#x27;;import &#123; on &#125; from &#x27;@/utils/dom&#x27;;const nodeList = [];const ctx = &#x27;@@clickoutsideContext&#x27;;let startClick;let seed = 0;!Vue.prototype.$isServer &amp;&amp; on(document, &#x27;mousedown&#x27;, e =&gt; (startClick = e));!Vue.prototype.$isServer &amp;&amp; on(document, &#x27;mouseup&#x27;, e =&gt; &#123; nodeList.forEach(node =&gt; node[ctx].documentHandler(e, startClick));&#125;);function createDocumentHandler(el, binding, vnode) &#123; return function(mouseup = &#123;&#125;, mousedown = &#123;&#125;) &#123; if (!vnode || !vnode.context || !mouseup.target || !mousedown.target || el.contains(mouseup.target) || el.contains(mousedown.target) || el === mouseup.target || (vnode.context.popperElm &amp;&amp; (vnode.context.popperElm.contains(mouseup.target) || vnode.context.popperElm.contains(mousedown.target)))) return; if (binding.expression &amp;&amp; el[ctx].methodName &amp;&amp; vnode.context[el[ctx].methodName]) &#123; vnode.context[el[ctx].methodName](); &#125; else &#123; el[ctx].bindingFn &amp;&amp; el[ctx].bindingFn(); &#125; &#125;;&#125;/** * v-clickoutside * @desc 点击元素外面才会触发的事件 * @example * &lt;div v-clickoutside=&quot;handleClose&quot;&gt; */export default &#123; bind(el, binding, vnode) &#123; nodeList.push(el); const id = seed++; el[ctx] = &#123; id, documentHandler: createDocumentHandler(el, binding, vnode), methodName: binding.expression, bindingFn: binding.value &#125;; &#125;, update(el, binding, vnode) &#123; el[ctx].documentHandler = createDocumentHandler(el, binding, vnode); el[ctx].methodName = binding.expression; el[ctx].bindingFn = binding.value; &#125;, unbind(el) &#123; let len = nodeList.length; for (let i = 0; i &lt; len; i++) &#123; if (nodeList[i][ctx].id === el[ctx].id) &#123; nodeList.splice(i, 1); break; &#125; &#125; delete el[ctx]; &#125;&#125;; 局部使用： 12directives: &#123; Clickoutside &#125;,&lt;div v-clickoutside=&quot;handleClose&quot;&gt; 注意，此指令可以对组件本身使用，也可以对元素本身使用","tags":[{"name":"Vue","slug":"Vue","permalink":"https://sellenite.github.io/tags/Vue/"}]},{"title":"Promise、Promise.all、Promise.race实现原理","date":"2019-03-08T14:50:21.000Z","path":"2019/03/08/Promise、Promise.all、Promise.race实现原理/","text":"Promise原理 简易版Promise 实现原理，执行从闭包带出来的resolve和reject函数 然后再执行then，将函数压到执行栈中 然后第一步的异步函数执行好了，就会利用resolve或reject传入参数并执行栈中的函数 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const PENDING = &#x27;pending&#x27;;const RESOLVED = &#x27;resolved&#x27;;const REJECTED = &#x27;rejected&#x27;;const MyPromise = function(fn) &#123; const that = this; this.state = PENDING; this.value = null; this.resolvedCallbacks = []; this.rejectedCallbacks = []; function resolve(value) &#123; // 执行环境不同，需要使用闭包变量 if (that.state === PENDING) &#123; that.state = RESOLVED; that.value = value; that.resolvedCallbacks.forEach(cb =&gt; cb(that.value)); &#125; &#125; function reject(value) &#123; if (that.state === PENDING) &#123; that.state = REJECTED; that.value = value; that.rejectedCallbacks.forEach(cb =&gt; cb(that.value)); &#125; &#125; try &#123; fn(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : v =&gt; v; onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : r =&gt; &#123; throw r &#125;; if (this.state === PENDING) &#123; this.resolvedCallbacks.push(onFulfilled); this.rejectedCallbacks.push(onRejected); &#125; // 如果在new Promise的时候就已经处理的resolve，直接执行函数 if (this.state === RESOLVED) &#123; onFulfilled(this.value); &#125; if (this.state === REJECTED) &#123; onRejected(this.value); &#125;&#125; Promise.all原理 返回新的promise，遍历循环传入的数组，处理每一个promise的then和catch then里处理将返回的内容写入对应的位置，如果判断所有结果已经处理，就将数组集合resolve catch里处理错误，只要有一个错误，就直接将错误reject 实现123456789101112131415161718const promiseAll = (arr) =&gt; &#123; let result = new Array(arr.length).fill(undefined), count = arr.length; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; arr.length; i++) &#123; arr[i].then((res) =&gt; &#123; // 按顺序写入结果 result[i] = res; if (--count === 0) &#123; resolve(result); &#125; &#125;).catch((err) =&gt; &#123; reject(err); &#125;) &#125; &#125;);&#125; Promise.race原理 返回新的promise，遍历循环传入的数组，处理每一个promise的then和catch then里处理返回的内容，只要有返回，立即将结果resolve catch里处理错误，只要捕获到错误，立即将错误reject 实现123456789101112const promiseRace = (arr) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; arr.length; i++) &#123; // 一个成功直接返回 arr[i].then((res) =&gt; &#123; resolve(res); &#125;).catch((err) =&gt; &#123; reject(err); &#125;); &#125; &#125;);&#125;","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"}]},{"title":"ubuntu和nginx常用命令","date":"2019-03-03T16:10:51.000Z","path":"2019/03/04/ubuntu和nginx常用命令/","text":"Ubuntu配置host： 1sudo vim /etc/hosts 安装nginx： 1sudo apt-get install nginx 查看有没有nginx占用： 1ps -ef | grep nginx 强制删除所有nginx进程： 1sudo pkill -9 nginx 获取root权限 1sudo su 退出root权限模式 1ctrl+d 下载文件（url是下载文件的地址） 1wget url 查看当前路径 1pwd 返回上一次打开的路径 1cd - 创建文件夹 1mkdir name 创建&#x2F;修改文件 12vim filenametouch filename 查看文件内容 1cat filename vim保存退出 12345678// 保存并退出:wq// 保存:w// 退出:q// 强制退出:q! vim视图模式 1:set nu vim编辑模式 1i vim只读模式 1esc 连接远程服务器 1ssh user@remote_ip 上传网站到服务器 12// scp -r ./demo/* root@46.86.255.117:/root/www 例子scp -r local_dir user@ip:/remote_dir 解压 1tar -xzvf filename.tar.xz 移动文件夹 1mv -r xxx pathname 重命名 1mv old_filename new_filename 软链 1ls -n Nginx启动nginx： 1sudo nginx -c /etc/nginx/nginx.conf 停止nginx进程 1nginx -s stop 重启nginx 1sudo nginx -s reload 查看nginx默认配置文件和路径和语法是否正确 1nginx -t","tags":[{"name":"Linux","slug":"Linux","permalink":"https://sellenite.github.io/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"https://sellenite.github.io/tags/Nginx/"}]},{"title":"项目上线流程总结","date":"2019-02-28T16:30:49.000Z","path":"2019/03/01/项目上线流程总结/","text":"发布必备条件 一台Linux服务器（CentOS&#x2F;Ubuntu）服务器 一款Web服务器（Nginx&#x2F;Apache&#x2F;Tomcat） 一个属于自己的独立域名（cn&#x2F;com&#x2F;org&#x2F;…） 本次流程以CentOS和Nginx配置为例 webpack设置静态地址打包 output的publicPath从开发地址/dist/设置为线上地址：//www.yuuhei.site/dist/ 服务器购买 选择阿里云产品的【云服务器ECS】 安全组有http（默认端口80）、https（默认端口443），linux SSH登录（默认端口22），windows远程桌面登录（默认端口3389） 链接远程服务器 windows下最好使用git bash，ubuntu下默认是bash控制台 使用ssh user@remote_ip 连接 Web服务器的选择 Nginx：高性能，高并发 Apache：多平台，安全，流行 Tomcat：多用于Java做jsp解析 配置Web服务器 命令行执行安装Nginx，各个linux系统的下载命令不一样，ubuntu执行sudo apt-get install nginx centOS和Ubuntu的nginx的配置文件一般都在&#x2F;etc&#x2F;nginx下，可以使用nginx -t查看配置文件位置 nginx.conf文件内容的user xxx需要改为user root 着重配置的是http块区域里的内容（http &gt; server &gt; location） node使用官网解压包安装 解压安装包 1tar -xzvf node-v10.15.2-linux-x64.tar.xz 移动文件夹到&#x2F;usr&#x2F;local&#x2F;node 1mv node-v10.15.2-linux-x64 /usr/local/node 建立全局命令node和npm软链（全局命令一般都在&#x2F;usr&#x2F;local&#x2F;bin&#x2F;） 12ls -n /usr/local/node/bin/node /usr/local/bin/ls -n /usr/local/node/bin/npm /usr/local/bin/ 这时候就可以直接全局执行node和npm了 nginx.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 改成user rootuser root# ...http &#123; listen 80; server_name yuuhei.site; root /root/www/admin-fe/dist/; index index.html; # 日志文件 access_log /etc/nginx/logs/access.log combined; # 完全满足 location = / &#123; # 网站路径，存放网站的地方 root /root/www/admin-fe/dist/; # 输入ip后，默认会显示哪个网址，不设置就需要手动在浏览器上访问 index index.html index.htm; try_files $uri $uri/ /index.html; &#125; location ~ .*\\.html$ &#123; root /root/www/admin-fe/dist/; index index.html index.htm; &#125; # 满足条件，访问.do，正则匹配服务器地址 location ~ .*\\.do$ &#123; proxy_pass http://www.server.com; &#125; # 代理后端API的配置 # 用于转发的路径标记 location /api/ &#123; proxy_pass http://192.168.0.1:8080/;###被代理的API地址 &#125; # 拒绝访问设定 location ~ /source/.* &#123; deny all; &#125; # 指定访问静态资源，假如加载js的路径是 http://yuuhei.cn/dist/xxx.js location ~ .*(js|css|png|jpg|gif)$ &#123; root /root/www/admin-fe/; &#125; # 都不满足则尝试，与 = / 有区别 location / &#123; try_files $uri $uri/ /index.html; &#125;&#125; 部署了前端静态资源html的服务器配置nginx，达到代理请求转发的效果，例如果配置了&#x2F;api&#x2F;，在项目里请求的地址就是&#x2F;api&#x2F;xxx&#x2F;xxx，且需在本地配置代理方便开发，代理配置在vue.config.js 123456789101112131415161718192021222324252627&#123; devServer: &#123; port: 8802, // 设置通过localhost和127.0.0.1都可以访问 host: &#x27;0.0.0.0&#x27;, // webpack-dev-server出于安全考虑，默认检查hostname, 经过内网穿透之后,访问会出现Invalid Host header disableHostCheck: true, // 代理设置 proxy: &#123; // 这个仅为本地调试用 [process.env.VUE_APP_DEV_API_URL]: &#123; target: &#x27;http://10.20.2.182:8580&#x27;, changeOrigin: true, pathRewrite: &#123; [&#x27;^&#x27; + process.env.VUE_APP_DEV_API_URL]: &#x27;&#x27; &#125; &#125;, [process.env.VUE_APP_OA_DINGDING_CRM_API_URL]: &#123; target: &#x27;http://10.10.14.98:8580&#x27;, changeOrigin: true, pathRewrite: &#123; [&#x27;^&#x27; + process.env.VUE_APP_OA_DINGDING_CRM_API_URL]: process.env.VUE_APP_OA_DINGDING_CRM_API_URL &#125; &#125; &#125; &#125;&#125; 域名解析 www：平时输入网址的www，例如www.baidu.com @：平时输入网址不输入www，例如baidu.com 记录值：公网服务器的IPv4地址 记录类型 A：将域名指向一个IPv4地址 CNAME：将域名指向另外一个域名（redirect） 备案，服务器和域名的信息必须一致才能访问 网站工作原理 输入网址 DNS解析，寻找对应服务器地址 进行握手（HTTP会话） 建立文档树，加载资源 项目index.html被缓存的解决方法单页面的项目，就算js，css等文件做了hash的处理，在发完版后进入去的第一次，会有白屏的问题。原因就是index.html被缓存，之前的js的hash都变了，然后旧的html加载了不存在的js，导致报错白屏 重点是location &#x2F; 的add_header Cache-Control &quot;no-cache, no-store&quot;;，不设置缓存，其余的是代理的设置 123456789101112131415161718192021222324252627282930313233 server &#123; listen 8161; server_name xxx; #启用https配置 #listen 443; #server_name xxx; #ssl on; #ssl_certificate cret/server.pem; #ssl_certificate_key cret/server.key; #ssl_session_timeout 5m; #ssl_protocols TLSv1 TLSv1.1 TLSv1.2;#启用TLS1.1、TLS1.2要求OpenSSL1.0.1及以上版本，若您的OpenSSL版本低于要求，请使用 ssl_protocols TLSv1; #ssl_ciphers HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUM; #ssl_prefer_server_ciphers on; autoindex on; index index.html; access_log /data/logs/xxxlocation /test/ &#123; proxy_set_header Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header REMOTE-HOST $remote_addr; proxy_pass xxx; &#125;location / &#123; try_files $uri $uri/ /index.html; root /data/code/prod_oa_front/oa_fe_ding_m/lsmy-oa-dingding-mobile/dist; add_header Cache-Control &quot;no-cache, no-store&quot;; autoindex on; &#125;&#125;","tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://sellenite.github.io/tags/Nginx/"}]},{"title":"前后端跨域解决方案总结","date":"2019-02-27T15:19:11.000Z","path":"2019/02/27/前后端跨域解决方案总结/","text":"产生跨域的原因 浏览器限制 请求链接跨域 请求类型是XMLHttpRequest 跨域解决方法之一：JSONP​ 实现jsonp，需要前后端都需要改造，后端需要增加支持返回js函数，主要约定是url的key字段，由于jquery默认的jsonp请求的关键字key默认是callback，后端一般都会使用callback关键字，当然也可以定义另一个名称，而这个key对应的value使用什么都可以，jquery是使用随机数，后台会获取这个随机数，作为返回js函数的函数名。这是大多数情况，原理是如此，但可能有所不同。 ​ 除此之外，还需要注意要使用随机数，不然jsonp由于是js脚本，如果请求参数相同，就会使用缓存的结果，而不会使用最新的结果，jquery的jsonp默认有随机数参数 ​ jsonp有以下弊端：服务端也需要改造，请求只能是get。由于请求是get，一般只能用来请求一些获取数据的接口，而不能用于修改用户信息等类型的接口（需要用到post）。由于这个缺点，一般很少接口会用到jsonp，解决跨域问题还需要找其他解决办法 网络请求的路径和解决思路​ 一般请求路径是：Client(调用方) - Apache&#x2F;Nginx(http服务器) - Tomcat(被调用方后台应用服务器)。其中Apache&#x2F;Nginx会处理来自client的请求，判断该请求为什么类型的请求，如果是静态请求，则直接处理返回给client，如果是动态请求，则转发给后台的应用服务器，处理完毕后则原路返回。 ​ 动态请求指，跟用户数据有关的请求，xhr等 ​ 静态请求指，跟用户数据无关的请求，例如img，js，css ​ 解决跨域的思路有两种，一种是在被调用方后台应用服务器上做处理，在响应头上增加字段，告诉浏览器允许对方调用，浏览器就不会报跨域问题；第二种是隐藏跨域的思路，在http服务器上做处理，做一个http请求转发，浏览器发现所有的请求都是同一个域，就不会报跨域问题。 被调用方解决 - 支持跨域（应用服务器配置响应头、Apache&#x2F;Nginx服务器配置响应头CORS）​ 当浏览器进行跨域请求时，会在预检请求的时候在请求头加上Origin字段，对应的值是当前域的信息。然后返回的时候会检查响应头里有没有允许跨域的字段，如果没有，浏览器就会报错拦截。具体检查的响应头字段是Access-Control-Allow-Origin，它是html5新增的一项标准，IE10以下是不支持的。如果需要IE10以下都完美支持跨域，请使用http服务器转发(http反向代理)解决问题。 ​ 一般这个方法，后台应用服务器简称为filter，添加filter组件后，再在响应头里添加Access-Control-Allow-Origin(允许跨域的域名)，Access-Control-Allow-Methods(允许跨域的请求类型) 12// 后台设定返回res.addHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;*&#x27;); 简单请求和复杂请求（跨域时才区分）​ 浏览器在进行跨域请求时，会判断该请求是简单请求还是非简单请求，如果是简单请求，则会先执行，后判断；如果是非简单请求，浏览器就会先发一个预检命令（OPTIONS），通过之后再发跨域请求。 工作中比较常见的【简单请求】： 方法为GET、HEAD、POST 请求header里无自定义请求 Content-Type为以下几种： text&#x2F;plain（表单数据以纯文本形式进行编码） multipart&#x2F;form-data（一般上传文件时会用到） application&#x2F;x-www-form-urlencoded（表单数据编码为键值对，&amp;分隔） 工作中比较常见的【非简单请求】： put、delete方法的ajax请求 发送json格式的ajax请求（Content-Type为appliation&#x2F;json;charset&#x3D;utf-8） 带自定义头的ajax请求 ​ 发送json格式的ajax请求时，预检命令，请求头会加上一个Access-Control-Allow-Headers为Content-Type，询问后台应用服务器是否允许这个头。如果后台没有在filter里加上这个响应头告诉浏览器允许这个header，浏览器发现没有通过的信息就会报错 12// 后台设定返回res.addHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;Content-Type&#x27;); ​ 非简单请求一共会发送两次请求，第一次是OPTIONS预检命令，第二次才是真正的跨域请求 ​ OPTIONS预检命令是可以做缓存的，由于非简单请求每次都会发送两次请求，这样会比较影响性能。后台应用服务器可以通过在响应头里增加Access-Control-Max-Age，值是毫秒数，这样浏览器在规定时间内，这个接口的请求就不会再进行OPTIONS预检命令，直接执行下一个请求。如果用户在浏览器开发模式中将Disable cache开启，那么就会清掉这个缓存，重新验证OPTIONS预检命令 12// OPTIONS请求设置3600毫秒缓存res.addHeader(&#x27;Access-Control-Max-Age&#x27;, &#x27;3600&#x27;); ​ 注意，如果使用了反向代理解决跨域问题的时候，那么这些请求实际上都没有跨域，都在同一个域名上请求，不存在简单请求和复杂请求，就没有了OPTIONS这个预检请求了，直接进行请求 带cookie的跨域​ ajax会自动带上同源的cookie，不会带上不同源的cookie。前端如果需要发起跨域的带有cookie的请求，需要将XMLHttpRequest.withCredentials置为true，修改方法为： 1234$.ajax(&#123; // ... xhrFields:&#123; withCredentials:true &#125;&#125;) ​ 这个修改永远不会影响到同源请求，不同域下的XmlHttpRequest 响应，不论其header 设置什么值，都无法为它自身站点设置cookie值，除非它在请求之前将withCredentials 设为true。 ​ 以上是前端需要做的改造，后端需要做的改造如下： 12res.addHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;具体网址&#x27;);res.addHeader(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;); ​ 注意，这时候后端应用服务器就不能将 Access-Control-Allow-Origin置为*这样的通配符形式，一定要用全匹配的地址，而且需要额外配置Access-Control-Allow-Credentials，通过这样的参数设置，就可以保持跨域ajax时传递cookies。 ​ 这时注意，这也不是后台应用服务器将Access-Control-Allow-Origin写死，由前面得知，浏览器在跨域请求时，会在预检请求OPTIONS里增加一个Origin字段，这时候后台就可以取到这个字段，然后将它赋值给Access-Control-Allow-Origin，这也就变相得实现通配符的功能～ ​ 需要非常注意，我们发送的cookie，是被调用方域名的cookie，cookie要加在被调用方的域名上，而不是调用方的cookie 1document.cookie = &quot;name=yuuhei; path=/&quot;; 带自定义头的跨域​ jquery的ajax自定义请求有两种方法： 12345678$.ajax(&#123; // ... headers: &#123; token: &#x27;ASDFGH&#x27; &#125;, // 或 beforeSend: function(xhr) &#123; xhr.setRequestHeader(&#x27;token&#x27;, &#x27;ASDFGH&#x27;) &#125;&#125;) ​ 后端也要做响应处理，不然浏览器会报Access-Control-Allow-Headers的问题，需要在后台代码加上对应名称的header（像加之前Content-Type的时候那样加），可以先获取由发起方得到的自定义header，再赋值这样的套路（像之前设定Origin时的方法），这样后台代码就不会写死。 express作为后台应用服务器解决方案总结（被调用方解决）：1234567891011121314151617// nginx反向代理解决后这些都不用设置了var allowCrossDomain = function(req, res, next) &#123; let origin = req.headers.origin; // 允许域名 res.header(&#x27;Access-Control-Allow-Origin&#x27;, origin); // 允许方法 res.header(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;GET, POST, PUT, DELETE&#x27;); // 允许发json，客户端强制发送contentType为appliation/json;charset=utf-8，会有OPTIONS预检请求 res.header(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;Content-Type, Token&#x27;); // 允许跨域带cookie res.header(&#x27;Access-Control-Allow-Credentials&#x27;,&#x27;true&#x27;); // 预检命令缓存 res.header(&#x27;Access-Control-Max-Age&#x27;,&#x27;3600&#x27;); next();&#125;;app.use(allowCrossDomain); 被调用方- Nginx解决方案​ nginx有一个虚拟主机的概念，什么是虚拟主机： 多个域名指向同一个服务器，nginx服务器根据不同的域名，转发到不同的应用服务器 ​ 虚拟主机的配置：配置host文件，设定如下类似代码，这样nginx就可以配置多个虚拟域名，其实访问的都是同一个ip地址： 123# 127.0.0.1就是本地的ip，b.com就是映射的虚拟主机ip# linux下使用sudo vim /etc/hosts修改保存127.0.0.1 b.com ​ 配置nginx：打开nginx目录，打开conf目录，新建一个vhost文件夹，然后修改nginx.conf 12# nginx.conf 在http块区域里最后面增加include vhost/*.conf; ​ 在vhost文件夹创建一个conf文件，配置如下： 12345678910111213141516171819202122232425# vhost文件夹新增.confserver &#123; # 浏览器请求地址端口 listen 80; # 浏览器请求地址 server_name b.com; location / &#123; # 后台应用服务器地址 proxy_pass http://localhost:8080/; # 在次修改响应头 add_header Access-Control-Allow-Methods *; add_header Access-Control-Allow-Credentials true; add_header Access-Control-Max-Age 3600; add_header Access-Control-Allow-Origin $http_origin; add_header Access-Control-Allow-Headers $http_access_control_request_headers # 处理OPTIONS命令直接返回，不需要转发到应用服务器 if ($request_method = OPTIONS)&#123; return 200; &#125; &#125;&#125; 配置完之后前端请求的地址可以从http://localhost:8080/user.do变为http://b.com/user.do，这样就完成了应用服务器的虚拟服务器映射，此时cookies需要加在http://b.com这个被调用方域名上，像之前所说的 调用方 - 隐藏跨域解决方案，反向代理（目前最好解决方案）反向代理的意思是，访问统一域名的两个不同的url，会去到两个不同的服务器 nginx目录下，新建vhost文件夹，新增配置a.com.conf，host已做映射 12# host配置虚拟地址，模拟线上地址127.0.0.1 a.com 配置nginx.conf 12# nginx.conf 在http块区域里最后面增加include vhost/*.conf; nginx.conf目录下新建一个vhost文件夹，新建a.com.conf 12345678910111213141516# a.com server &#123; listen 80; server_name a.com; location / &#123; # 本地客户端代理 proxy_pass http://localhost:8081/; &#125; location ~ .*\\.do$ &#123; # 注意，使用了正则匹配代理路径就不能包含uri，即/ proxy_pass http://localhost:3000; &#125;&#125; 现在所有的.do请求都会经过3000端口的这个代理 开启nginx（ubuntu下） 1nginx -c /etc/nginx/nginx.conf ​ 就可以通过a.com和a.com/user.do就可以同时访问客户端和后台应用服务器，解决跨域问题 ​ 这样解决的最大区别是，请求的地址，之前必须是一个绝对地址，现在是一个相对地址。比如之前请求的地址是http://localhost:3000/users.do，现在只需要请求/users.do即可 ​ 这样的解决方法，之前前后端做的跨域设置都不用做，因为现在经过nginx反向代理后，两个地址都指向同一个域名，无跨域问题，cookie也能够发送到后台应用服务器～","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"},{"name":"Nginx","slug":"Nginx","permalink":"https://sellenite.github.io/tags/Nginx/"}]},{"title":"JS上传文件到后台并返回","date":"2019-02-25T03:05:57.000Z","path":"2019/02/25/JS上传文件到后台并返回/","text":"一般表单上传文件到后台的格式1234&lt;form name=&quot;form2&quot; action=&quot;/manage/product/upload.do&quot; method=&quot;post&quot; encType=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;upload_file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;upload&quot; /&gt;&lt;/form&gt; 字段说明： name：input标签的name属性值要对应后台的字段 enctype：属性规定在发送到服务器之前应该如何对表单数据进行编码，有以下三个值： application&#x2F;x-www-form-urlencoded：表单数据编码为键值对，&amp;分隔 multipart&#x2F;form-data：不对字符编码。在使用包含文件上传控件的表单时，必须使用该值 text&#x2F;plain：空格转换为 “+” 加号，但不对特殊字符编码 如何实现上传不跳转​ 默认的使用上述提交表单，选择完图片提交后会进行页面跳转，这不是所期望的。由于兼容性问题，会分为IE10+和非IE10的情况。 ​ IE9和IE9以下只能用iframe表单上传拿回调，target&#x3D;”rfFrame”调取的是下面这个iframe的id值。作用是为了提交表单时防止页面跳转，不兼容Formdata。 ​ IE10+和其他浏览器可以使用ajax的post去send一个Formdata的js对象，可以实现提交表单不跳转。 ​ FormData类型其实是在XMLHttpRequest 2级定义的，它是为序列化表以及创建与表单格式相同的数据（当然是用于XHR传输）提供便利，使用FormData的最大优点就是我们可以异步上传一个二进制文件，兼容性需要IE10+。 Formdata实现上传文件123456789// ...// 取file文件的方法let fileObject = document.getElementById(&#x27;upload_file&#x27;).files[0];// FormData表单对象，ie10+和其他浏览器才能使用，ie9和以下只能够使用原始form+iframe取回调let form = new FormData();// 将文件对象打入form实例，upload_file为后台指定的名称，取的是原有的input的name属性的值form.append(&#x27;upload_file&#x27;, fileObject);// ...xhr.send(form); 注意事项： 传输文件时，send的时候不需要对参数进行序列化，直接将整个form对象发送过去，jquery设置processData为false 传输文件时，不能设置请求头，jquery设置contentType为fasle 可以在input框onChange时进行上传文件，点击确认和取消都会触发input的onChange 点击input上传file时，如果点击取消，e.target会被更改，e.target.files[0]这个对象属性会消失 form+iframe实现上传文件不跳转​ form原始处理form的回调这样做的：监听form指向的隐藏iframe的onLoad事件，取iframe里的innerHTML，因为它的innerHTML会直接返回一个对象，可以直接使用；有可能会返回其他东西，具体看后台怎样返回，前端再具体处理 ​ jquery可以使用ajaxForm插件实现form的提交回调 具体实现原理代码仅供参考，内嵌xhr请求实现，react版。 组件实现： react-fileupload.jsx; 组件调用： 123456789101112131415161718192021class FileUploader extends React.Component&#123; render()&#123; const options=&#123; baseUrl :&#x27;/manage/product/upload.do&#x27;, fileFieldName : &#x27;upload_file&#x27;, dataType : &#x27;json&#x27;, chooseAndUpload : true, uploadSuccess : (res) =&gt; &#123; this.props.onSuccess(res.data); &#125;, uploadError : (err) =&gt; &#123; this.props.onError(err.message || &#x27;上传图片出错啦&#x27;); &#125; &#125; return ( &lt;FileUpload options=&#123;options&#125;&gt; &lt;button className=&quot;btn btn-xs btn-default&quot; ref=&quot;chooseAndUpload&quot;&gt;请选择图片&lt;/button&gt; &lt;/FileUpload&gt; ) &#125;&#125;","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"}]},{"title":"ElementUI中的input组件简单实现","date":"2019-01-16T14:19:16.000Z","path":"2019/01/16/ElementUI中的input组件简单实现/","text":"注意事项： 此为ElementUI的input组件的简单实现 里面的input不要使用v-model绑定数据，应该直接使用el本身的value来作为值，之前的做法一直是input又再使用了v-model input的change事件是在input在失焦的时候才会触发的 compositionstart和compositionend是为了避免某些时候中文的预选字也会触发双向绑定，目的是为了避免输入中文输入法的时候也触发了change事件 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&lt;template&gt; &lt;div class=&quot;search-wrapper-box&quot;&gt; &lt;div class=&quot;search-wrapper&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; ref=&quot;input&quot; :placeholder=&quot;placeholder&quot; @keyup.enter=&quot;handleSearch&quot; @input=&quot;handleInput&quot; @change=&quot;handleChange&quot; @compositionstart=&quot;handleCompositionStart&quot; @compositionend=&quot;handleCompositionEnd&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;right&quot; @click=&quot;handleSearch&quot;&gt; 搜索 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; placeholder: &#123; type: [String, Number], default: &#x27;搜索&#x27; &#125;, value: &#123; type: [String, Number], default: &#x27;&#x27; &#125; &#125;, data() &#123; return &#123; nativeInputValue: &#x27;&#x27;, isComposing: false &#125; &#125;, watch: &#123; value: &#123; immediate: true, handler(val) &#123; this.nativeInputValue = val === null || val === undefined ? &#x27;&#x27; : String(val); &#125; &#125;, nativeInputValue() &#123; this.setNativeInputValue(); &#125; &#125;, mounted() &#123; this.setNativeInputValue(); &#125;, methods: &#123; getInput() &#123; return this.$refs.input; &#125;, setNativeInputValue() &#123; const input = this.getInput(); if (!input) return; if (input.value === this.nativeInputValue) return; input.value = this.nativeInputValue; &#125;, handleInput(event) &#123; if (this.isComposing) return; if (event.target.value === this.nativeInputValue) return; this.$emit(&#x27;input&#x27;, event.target.value); this.$nextTick(this.setNativeInputValue); &#125;, handleChange(event) &#123; this.$emit(&#x27;change&#x27;, event.target.value); &#125;, handleSearch() &#123; this.$emit(&#x27;search&#x27;, this.nativeInputValue); &#125;, handleCompositionStart() &#123; this.isComposing = true; &#125;, handleCompositionEnd(event) &#123; this.isComposing = false; this.handleInput(event); &#125; &#125; &#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt; $border-color: #eee; $primary-color: #738d91; @mixin center &#123; display: flex; justify-content: center; align-items: center; &#125; .search-wrapper-box &#123; display: flex; &#125; .search-wrapper &#123; width: 600px; height: 42px; background-color: #FFF; border-radius: 4px; display: flex; border: 1px solid $border-color; .left &#123; flex: 1; input &#123; width: 100%; height: 100%; border: none; outline: none; padding: 0 20px; font-size: 16px; &amp;::-webkit-input-placeholder &#123; color: #91a8b0; &#125; &amp;::-moz-placeholder &#123; color: #91a8b0; &#125; &amp;:-ms-input-placeholder &#123; color: #91a8b0; &#125; &#125; &#125; .right &#123; width: 80px; cursor: pointer; border-left: 1px solid $border-color; background-color: $primary-color; color: #FFF; @include center; &#125; &#125;&lt;/style&gt;","tags":[{"name":"Vue","slug":"Vue","permalink":"https://sellenite.github.io/tags/Vue/"},{"name":"组件","slug":"组件","permalink":"https://sellenite.github.io/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"你不知道的JavaScript（下）读书笔记","date":"2019-01-13T05:24:16.000Z","path":"2019/01/13/你不知道的JavaScript（下）读书笔记/","text":"第二部分 ES6及更新版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497/** * 你不知道的JavaScript(下卷) 第二部分 ES6及更新版本 * 第一部分没有笔记 */&#123; const runSomething = (obj) =&gt; &#123; let x = Math.random(), y = Math.random(); return obj.something(x, y); &#125; let num = runSomething(&#123; // 递归引用当前函数的必要写法 something: function something(x, y) &#123; if (x &gt; y) &#123; return something(y, x); &#125; return y - x; &#125; &#125;); console.log(num);&#125;;&#123; let obj1 = &#123; foo() &#123; console.log(&#x27;foo obj1&#x27;); &#125; &#125;; let obj2 = &#123; foo() &#123; // 可以这样使用super super.foo(); console.log(&#x27;foo obj2&#x27;); &#125; &#125;; // 其实就是将obj1的__proto__赋值给obj2 Object.setPrototypeOf(obj2, obj1); obj2.foo();&#125;;&#123; // 标签字符串字面量 const foo = (strings, ...values) =&gt; &#123; console.log(strings); console.log(values); &#125;; const desc = &#x27;awesome&#x27;; foo`Everything is $&#123;desc&#125;!`;&#125;;&#123; // 标签字符串字面量简单应用 const fixNum = (strings, ...values) =&gt; &#123; // strings [&quot;you should pay &quot;, &quot; to me&quot;] // values [19.9891] return strings.reduce((prev, curr, currIdx) =&gt; &#123; console.log(prev); console.log(curr); if (currIdx &gt; 0) &#123; if (typeof values[currIdx - 1] === &#x27;number&#x27;) &#123; prev += `$$&#123;values[currIdx - 1].toFixed(2)&#125;` &#125; else &#123; prev += values[currIdx - 1]; &#125; &#125; return prev + curr; &#125;, &quot;&quot;); &#125;; const amt = 19.9891; // 每个通过字面量传入的数字都会被toFixed const result = fixNum`you should pay $&#123;amt&#125; to me`; console.log(result);&#125;;&#123; // 箭头函数没有自己的arguments，而是继承自父层 const foo = function() &#123; const bar = () =&gt; &#123; console.log(arguments); // Arguments [1, 2, 3, callee:(..)] &#125;; bar(4, 5, 6); &#125; foo(1, 2, 3); // 但是仍然像普通函数一样可以通过结构来得到类似arguments的数组 const baz = (...args) =&gt; &#123; console.log(args); &#125; baz(7, 8, 9); // [7, 8, 9]&#125;;&#123; // 箭头函数内部没有constructor方法，也没有prototype，所以不支持new操作 // 它对this的处理与一般的普通函数不一样，箭头函数的this始终指向函数定义时的this，不可用于构造 const foo = () =&gt; &#123; &#125;; const bar = new foo(); // 不要使用箭头函数做为构造函数&#125;&#123; // symbol没有字面量形式，不能对Symbol使用new，他不是一个构造器，也不会创建对象 const sym = Symbol(&#x27;some optional description&#x27;); // 基础类型，识别symbol的首选办法 console.log(typeof sym); // symbol // 提供描述时会只被作为这个符号的字符串表示 console.log(sym.toString()); // Symbol(some optional description) // sym不是Symbol的实例，像字符串不是String的实例一样，所以无法使用instanceof判断，需要装箱 console.log(sym instanceof Symbol); // false console.log(Object(sym) instanceof Symbol); // true // 平时判断直接使用typeof判断即可，无需再次装箱再判断&#125;;&#123; // 单例creator const getSingle = function(fn) &#123; // 符号本身的内部值是不在代码中出现且无法获得的，所以可以作为唯一值 const INSTANCE = Symbol(&#x27;instance&#x27;); // 将返回的结果绑定creator的执行环境this const _this = this; return function() &#123; return getSingle[INSTANCE] || (getSingle[INSTANCE] = fn.apply(_this, arguments)); &#125; &#125;; // 执行环境 const container = &#123; getSingle &#125;; const creator = container.getSingle(function() &#123; return this &#125;); const result1 = creator(); const result2 = creator(); console.log(result1); // container console.log(result1 === result2); // true&#125;;&#123; // 符号作为键值存在于对象中时，不可被枚举，但可以被Object.getOwnPropertySymbols拿出 const obj = &#123; foo: 42, [Symbol(&#x27;foo&#x27;)]: 24, bar: 110 &#125; console.log(Object.getOwnPropertyNames(obj)); // [&quot;foo&quot;, &quot;bar&quot;] console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(foo)] // 内置符号 const arr = [1, 2, 3]; console.log(arr[Symbol.iterator]); // ƒ values() &#123; [native code] &#125;&#125;;&#123; const arr = [&#123; a: 1, b: 2 &#125;, 2, 3]; const it = arr[Symbol.iterator](); const map = new Map(); map.set(&#x27;a&#x27;, 4); map.set(&#x27;b&#x27;, 5); const it2 = map.entries(); // 返回最终值，例如前面的arr的3，done依然是false的，再进行一次迭代done才是true console.log(it.next()); console.log(it2.next());&#125;;&#123; const arr = [1, 2, 3]; const it = arr[Symbol.iterator](); /** * for-of实现原理 * 迭代之前都调用了 it.next()，然后查看一下 res.done， * 如果 res.done 为 true，表达式求值为 false，迭代就不会发生， * 这就是返回最后一个值时，返回的done仍然是true的原因，否则就直接忽略最后一个值了 */ for (let v, res; (res = it.next()) &amp;&amp; !res.done;) &#123; v = res.value; console.log(v); &#125;&#125;;&#123; const task = &#123; actions: [], [Symbol.iterator]() &#123; let steps = this.actions.slice(); return &#123; // 使迭代器成为iterable [Symbol.iterator]() &#123; return this &#125;, next(...args) &#123; if (steps.length &gt; 0) &#123; let res = steps.shift()(...args); return &#123; value: res, done: false &#125;; &#125; else &#123; return &#123; value: undefined, done: true &#125;; &#125; &#125;, return(v) &#123; steps.length = 0; return &#123; value: v, done: true &#125;; &#125; &#125; &#125; &#125;; task.actions.push(function(x, y) &#123; return x + y; &#125;); let it = task[Symbol.iterator](); console.log(it.next(10, 20));&#125;;&#123; // iterator返回的value是yield后面的值 // 每次next都会停在yield的左边，并把yield的内容先返回为value // 使用next赋值可以用作里面表达式的值进行运算 // next总比yield多一 const foo = function* () &#123; yield 1; const num = 100 * (yield 2); return num; &#125; const it = foo(); console.log(it.next(&#x27;111&#x27;)); console.log(it.next(&#x27;222&#x27;)); console.log(it.next(&#x27;333&#x27;)); // 333000, done&#125;;&#123; // Regenerator原理，ES5 // 原来的写法： const foo = function* () &#123; const x = yield 42; console.log(x); &#125; const it = foo(); console.log(it.next()); console.log(it.next(&#x27;111&#x27;)); // facebook Regenerator 实现iterator大概原理： const bar = function() &#123; let state = 0, x; function nextState(v) &#123; switch (state) &#123; case 0: state++; return 42; case 1: state++; x = v; console.log(x); return undefined; &#125; &#125; return &#123; next: function(v) &#123; let ret = nextState(v); return &#123; value: ret, done: state === 2 &#125; &#125; &#125; &#125; // 与原生的iterator同样用法 const it2 = bar(); console.log(it2.next()); console.log(it2.next(&#x27;222&#x27;));&#125;;&#123; class Foo &#123; constructor(a, b) &#123; this.x = a; this.y = b; &#125; getValueXY() &#123; return this.x * this.y; &#125; &#125; class Bar extends Foo &#123; constructor(a, b, c) &#123; super(a, b); this.z = c; &#125; getValueXYZ() &#123; return super.getValueXY() * this.z; &#125; &#125; const bar = new Bar(5, 10, 15); console.log(bar);&#125;;&#123; // 对于map来说，通常会使用对象作为键值，因为普通对象本来就能够使用字符串 let x = &#123; id: 1 &#125;; let y = &#123; id: 2 &#125;; let map = new Map(); map.set(x, 1); map.set(y, 2); // map的keys()，values()，entries()得到的全是iterator，可以使用...进行扩展 const itValues = map.values(); // 方法从一个类似数组或可迭代对象中创建一个新的数组实例，有第二个回调参数 const arr1 = Array.from(itValues); // [1, 2] // 也可以通过扩展运算符处理iterator const arr2 = [...itValues]; // []，arr1已经将iterator迭代完毕 console.log(arr1, arr2, itValues); const itKeys = map.keys(); const arr3 = [...itKeys]; // [&#123;id: 1&#125;, &#123;id: 2&#125;] console.log(arr3);&#125;;&#123; // new Array时传入一个数字参数时是生成一个空数组，其length 属性为这个数字 // Array.of(..)可以修复这个问题 const arrEmpty = new Array(3); console.log(arrEmpty); const arrExist = Array.of(3); console.log(arrExist); // babel默认不支持原生构造函数的继承，需要插件支持，不然执行会找不到方法 class AnotherArray extends Array &#123; sum() &#123; return this.reduce((prev, curr, currIdx) =&gt; &#123; return prev + curr; &#125;, 0); &#125; &#125; const arr = AnotherArray.of(1, 2, 3); console.log(arr.sum());&#125;;&#123; // Array.from可以将iterator转成数组（看上面例子） // 如果把类数组对象作为参数传给Array.from，它的行为方式和slice()或者apply(..)是一样的 const arr = [1, 2, 3]; const arrCopy = Array.from(arr); arrCopy[1] = 4; console.log(arr, arrCopy); // Array.from转换的数组没有空槽位，是真正的undefined值，new Array(4)就有4个空槽位 const arrEmpty = new Array(4); const arrUndefined = Array.from(arrEmpty); console.log(arrEmpty, arrUndefined); // Array.from的第二个参数，映射功能，与Array#map的功能相似 const arrCopyMap = Array.from(arr, (item, index) =&gt; &#123; if (item % 2 === 1) &#123; return item * 2; &#125; else &#123; return item; &#125; &#125;); console.log(arrCopyMap);&#125;;&#123; /** * copyWithin， * 参数是 target（要复制到的索引） * start（开始复制的源索引，包括在内） * end（复制结束的不包含索引） * 任何一个参数是负数，就被当作是相对于数组结束的相对值 * 会修改原数组 */ const arr = [0, 1, 2, 3, 4]; console.log(arr.copyWithin(3, 0, 1)); // [0, 1, 2, 0, 4] [1, 2, 3, 4, 5].copyWithin(2, 1); // 结果是[1, 2, 2, 3, 4]，而不是[1, 2, 2, 2, 2]&#125;;&#123; const arrEmpty = new Array(4); arrEmpty.fill(&#x27;all&#x27;); const arrUndefined = Array.from(new Array(4)); arrUndefined.fill(&#x27;part&#x27;, 1, 3); console.log(arrEmpty, arrUndefined);&#125;;&#123; // some返回的是true/false const arr = [1, 3, 2, 4, 5]; const result = arr.some((item, index, arr) =&gt; &#123; return item === index; &#125;); console.log(result); // true // find返回的是真正的数组值，找不到返回undefined const num = arr.find((item, index) =&gt; &#123; return item === index; &#125;); console.log(num); // 2 // findIndex返回的是数组的索引值，找不到返回-1 const index = arr.findIndex((item, index) =&gt; &#123; return item === 5; &#125;); console.log(index); // 4 // find和findIndex都支持数组值是对象的复杂值 const arrComplex = [ &#123; id: 1, value: 100 &#125;, &#123; id: 2, value: 200 &#125; ]; const obj = arrComplex.find((item, index) =&gt; &#123; return item.id === 2; &#125;); console.log(obj); // &#123;id: 2, value: 200&#125; const num2 = arrComplex.findIndex((item, index) =&gt; &#123; return item.value === 200; &#125;); console.log(num2); // 1&#125;;&#123; // Object.is执行比 === 比较更严格的值比较，具体在于NaN和+0与-0的比较，与===不太相同 const x = NaN, y = +0, z = -0; console.log(Object.is(x, NaN)); // true console.log(Object.is(y, z)); // false x === NaN; // false y === z; // true&#125;;&#123; // Number.isNaN()与window.isNaN()不相同，window.isNaN()判断有问题，会将传入的参数先转为数字 console.log(Number.isNaN(&#x27;test&#x27;)) // false console.log(window.isNaN(&#x27;test&#x27;)) // true&#125;;&#123; /** * new.target能够指向调用new的目标构造器 * 在普通的函数调用中（和作为构造函数来调用相对），new.target的值是undefined * 这使得可以检测一个函数是否是作为构造函数通过new被调用的 */ class Parent &#123; constructor() &#123; if (new.target === Parent) &#123; // 函数有name属性 console.log(`$&#123;new.target.name&#125; instantiated`); &#125; else &#123; // 继承时new.target是一个undefined值，可能是继承执行父元素的构造函数时，属于普通调用导致的 console.log(`Child instantiated`); &#125; &#125; &#125;; class Child extends Parent &#123; &#125;; const parent = new Parent(); const child = new Child();&#125;;&#123; // 定义一个只返回奇数索引值对应的值的迭代器 const arr = [2, 4, 6, 8, 10]; arr[Symbol.iterator] = function* () &#123; let idx = 1; do &#123; yield this[idx]; &#125; while ((idx += 2) &lt; this.length) &#125; for (let v of arr) &#123; console.log(v); &#125;&#125;;","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://sellenite.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"你不知道的JavaScript（中）读书笔记","date":"2019-01-13T05:24:10.000Z","path":"2019/01/13/你不知道的JavaScript（中）读书笔记/","text":"第一部分 类型和语法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549/** * 你不知道的JavaScript(中卷) 第一部分 类型和语法 */&#123; let a = null; let b = &#123; name: &#x27;yuuhei&#x27; &#125;; let c = [1, 3]; console.log(typeof a, typeof b, typeof c);&#125;;&#123; /* 复合条件检测null */ let a = null; console.log(!a &amp;&amp; typeof a === &#x27;object&#x27;); // true&#125;;&#123; /* 函数对象的length是声明参数的个数 */ let foo = function (a, b, c) &#123; &#125;; console.log(foo.length); // 3&#125;;&#123; /* 声明了还没赋值属于undefined */ /* 还没声明属于undeclared（javascript还是会打印undefined） */&#125;;&#123; /* typeof一个var声明了但未定义值的话会打印undefined */ /* typeof一个完全没有声明及定义值的话同样也会打印undefined */&#125;;&#123; let IIFE = 2; /* typeof判断当前作用域变量是否被定义 */ let helper = (typeof IIFE !== &#x27;undefined&#x27;) ? IIFE : function () &#123; /* somethings */ &#125;; /* 使用typeof来检查变量是首选的选择 */ console.log(helper); // 2&#125;;&#123; /* 用依赖注入设计模式来验证当前作用域变量是否被定义 */ let helper = function (IIFE) &#123; let helper2 = IIFE || function () &#123; /* somethings */ &#125;; &#125;;&#125;;&#123; /* 创建稀疏数组，空白的地方会被显式赋值为undefined */ let arr = []; arr[0] = 0; arr[4] = 4; console.log(arr.length); // 5&#125;;&#123; /* 数组也是对象，可以包含字符串键值和属性，但不计入于数组的长度 */ let arr = [1, 3, 5]; arr[&#x27;name&#x27;] = &#x27;yuuhei&#x27;; arr[&#x27;age&#x27;] = 23; console.log(arr, arr.length); // 3&#125;;&#123; /* 注意，如果字符串键值能够转换为十进制数字，会被当作数字索引处理 */ let arr = [1, 3, 5]; arr[&#x27;5&#x27;] = 100; console.log(arr);&#125;;&#123; /* 类数组及数组副本建立 */ // 类数组转换 let foo = function () &#123; let arr = Array.prototype.slice.call(arguments); console.log(arr) &#125; foo() // 数组副本 let arr = [1, 3, 5]; let arrCopy = Array.prototype.slice.call(arr); arr.push(100); arrCopy.push(200); console.log(arr, arrCopy); // ES6的Array.from也能够建立副本 let arr2 = [2, 4, 6]; let arrCopy2 = Array.from(arr2); arr2.push(100); arrCopy2.push(200); console.log(arr, arrCopy2);&#125;;&#123; /* 访问字符串某个下标应该用.charAt()，老版本IE不允许string[index]这样访问 */ /* 以上只能够进行字符串访问，无法进行字符串修改 */ let string = &#x27;foo&#x27;; console.log(string[0]); console.log(string.charAt(2));&#125;;&#123; /* 数字值可用指数表示 */ let a = 5E10; console.log(a);&#125;;&#123; let a = 42.59; /* .toFixed()用于指定小数显示多少个 */ console.log(a.toFixed(4)); /* .toPrecision()用于指定多少个有效数位 */ console.log(a.toPrecision(5));&#125;;&#123; /* ES6，严格模式不再支持0开头的八进制数 */ // let a = 0363; // console.log(a); SyntaxError /* ES6和严格模式下的八进制是用0o前缀表示 */ let a = 0o363; console.log(a); // 243&#125;;&#123; /* 注意0.1+0.2不等于0.3，存在精度问题 */ let a = 0.1 + 0.2; let b = 0.3; console.log(a === b); // false&#125;;&#123; /* NaN不与NaN相等，typeof NaN的值为&#x27;number&#x27; */ console.log(typeof NaN); // number console.log(NaN === NaN); // false&#125;;&#123; /* window有一个全局方法isNaN()，但这个有bug，会将NaN和字符串也会判断为true */ /* ES6的Number.isNaN()修复了这个问题，他会先用typeof判断为number再执行此方法 （上面提到typeof NaN返回的是&#x27;number&#x27;） */ let a = &#x27;foo&#x27;; let b = 10 / &#x27;foo&#x27;; console.log(window.isNaN(a)); // true, bug console.log(window.isNaN(b)); // true console.log(Number.isNaN(a)); // false，修复了 console.log(Number.isNaN(b)); // true /* 判断是否NaN的更简单方法 */ let IsNaN = function (n) &#123; return n !== n; &#125; console.log(IsNaN(b)); // true&#125;;&#123; /* 关于-0，0 === -0是true */ /* 使用JSON.stringify()进行数字转为字符串，-号消失；字符串转为数字，-号保留 */ /* JSON.stringify(-0) 返回&quot;0&quot;，而JSON.parse(&quot;-0&quot;) 返回-0 */ console.log(0 === -0); // true console.log(JSON.stringify(-0), JSON.parse(&#x27;-0&#x27;)); /* 判断是否为负0的方法 */ let isMinZero = function (n) &#123; n = Number(n); return (n === 0) &amp;&amp; (1 / n === -Infinity); &#125; console.log(isMinZero(-0)); // true&#125;;&#123; /* 原生函数 */ // String() // Number() // Object() // Array() // Boolean() // Function() // RegExp() // Error() // Date() // Symbol()&#125;;&#123; /* typeof new String(&#x27;123&#x27;)会返回object */ let a = new String(&#x27;Hello&#x27;); console.log(a); // String &#123;&quot;Hello&quot;&#125; /* 使用String.prototype.toString()能够返回string字符串 */ console.log(a.toString()); // &quot;Hello&quot; console.log(String.prototype.toString.call(a)); // &quot;Hello&quot; /* 与本身构造函数的valueOf()功能相同 */ console.log(a.valueOf()); // &quot;Hello&quot; console.log(String.prototype.valueOf.call(a)); // &quot;Hello&quot; /* Object.prototype是不同的 */ console.log(Object.prototype.toString.call(a)); // [object String] console.log(Object.prototype.valueOf.call(a)); // String &#123;&quot;Hello&quot;&#125;&#125;;&#123; /* 查看一个内部属性[[class]]使用Object.prototype.toString.call() */ let a = new Boolean(false); console.log(Object.prototype.toString.call(a)); // [object Boolean]&#125;;&#123; /* 想要得到封装对象的基本类型值，可以使用valueOf()函数 */ let a = new String(&#x27;Hello&#x27;); console.log(a.valueOf()); /* 隐式拆封 */ let b = a + &quot;&quot;; console.log(b);&#125;;&#123; /* 尝试对一个new String/Boolean/Number进行隐式访问，会造成强制类型转换 会访问对应的构造函数原型链上的valueOf方法 */ let string = new String(&#x27;string1&#x27;); // 隐式访问，实际是调用返回了String.prototype.valueOf的值，强制类型转换 if (string.indexOf(1) !== -1) &#123; console.log(&#x27;new String direct read&#x27;); &#125;&#125;;&#123; /* 当使用表达式+时，其中一个操作数是string（包含强制转换结果）， 则执行字符串拼接，否则执行数字加法 */ console.log([] + 1); // []被强制执行.toString，得到空字符，结果为&quot;1&quot; console.log(&quot;4&quot; + 1); // 41&#125;;&#123; /* 当new Array的时候只传入一个数， 执行的是创建一个数组，长度为10，且全为空单元（非undefined）填充 */ /* 空单元和undefined是有区别的，注意 */ let a = Array(10); // new可以省略，js会自动补加 console.log(a, a.length); /* 清空一个数组可以使用array.length = 0 */ let b = [2, 4, 6]; b.length = 0; console.log(b); /* 创建一个全是undefined（非空单元）填充的数组 */ /* array.length这样强行修改会用空单元填充多余的空位 */ let c = Array.apply(null, &#123; length: 3 &#125;); console.log(c); // [undefined, undefined, undefined] /* 永远不要创建和使用空单元数组 */&#125;;&#123; // String.prototype的各类方法，不修改原字符串 // String#.indexOf // String#.charAt // String#.substr String#.substring String#.slice() // String#.toUpperCase String#.toLowerCase() // String#.trim&#125;;&#123; /* Symbol使用原生构造函数来定义，不用加new */ let myown = Symbol(&#x27;deleteSomething&#x27;); let obj = &#123;&#125;; obj[Symbol(&#x27;deleteSomething&#x27;)] = function () &#123; /* doSomething */ &#125; console.log(obj); console.log(Object.getOwnPropertySymbols(obj)); /* 具有唯一性，很多开发喜欢使用这个用于私有属性代替_function */&#125;;&#123; /* JSON.stringify()在遇到undefined，function，symbol这三个不安全值时， 在对象会将其自动忽略，在数组中返回null，在一般调用会返回undefined */ console.log(JSON.stringify(undefined)); // undefined console.log(JSON.stringify(function () &#123; &#125;)); // undefined // &quot;&#123;&quot;a&quot;: 2&#125;&quot; console.log(JSON.stringify(&#123; a: 2, b: function () &#123; &#125; &#125;)); // &quot;[&quot;yuuhei&quot;, null, null, 4]&quot; console.log(JSON.stringify([&#x27;yuuhei&#x27;, undefined, function () &#123; &#125;, 4]));&#125;;&#123; /* JSON.stringify有一个很实用的replacer，可以对数据进行筛选处理 */ // 可以是数组或函数 let obj = &#123; a: 2, b: &quot;22&quot;, c: [1, 2, 3] &#125; // replacer为数组时的作用 let json1 = JSON.stringify(obj, [&quot;a&quot;, &quot;b&quot;]); // 只序列化key值为a和b的 console.log(json1); // &quot;&#123;&quot;a&quot;:2,&quot;b&quot;:&quot;22&quot;&#125;&quot; // replacer为function时的作用 let json2 = JSON.stringify(obj, function (key, value) &#123; if (key !== &quot;a&quot;) return value; &#125;); console.log(json2); // &quot;&#123;&quot;b&quot;:&quot;22&quot;,&quot;c&quot;:[1,2,3]&#125;&quot; // 第三个参数space，还可以调缩进，自动进行格式化，还可以是填充字符串 let json3 = JSON.stringify(obj, null, 4); console.log(json3); // &#123; // &quot;a&quot;: 2, // &quot;b&quot;: &quot;22&quot;, // &quot;c&quot;: [ // 1, // 2, // 3 // ] // &#125;&#125;;&#123; /* 以下布尔假植在强制转换的时候结果都为false，强制转换是!! */ // undefined, null, fasle, +0, -0, NaN, &quot;&quot; console.log(!!undefined || !!null || !!false || !!0 || !!NaN || !!&quot;&quot;); // false // document.all在某些IE和某些浏览器是为真值，在某些浏览器下为假值，是一个类数组 /* 假值之外都是真值，转换后都为true */&#125;;&#123; /* 显式强制类型转换 */ // 字符串和数字之间的显式转换，不要使用new，并不是创建对象 let a = 22; let b = &quot;3.14&quot;; let c = String(a); let d = Number(b); console.log(c, d); // &quot;22&quot;, 3.14 // 另一种方法的显式转换 let e = a.toString(); // 调用的是Number.prototype.toString let f = +b; console.log(e, f); // &quot;22&quot;, 3.14&#125;;&#123; // 日期显示转换为数字（相当于.getTime()功能） let a = new Date(); console.log(+a, a.getTime()); // 当实例化一个构造函数的时候如果没有参数传入，可以不加() console.log(+new Date); // ES5的Date有一个获取当前时间戳的API，其polyfill就是+new Date() console.log(Date.now());&#125;;&#123; /* parseInt的使用 */ // Number()针对的是字符串，要求所有字符都是数字，否则返回NaN // parseInt()可以忽略不是数字字符的字符串，遇到非数字字符则停止转换，若第一个不是数字则返回NaN let a = &#x27;12aa45&#x27;; let b = &#x27;456&#x27;; let c = &#x27;aa123456&#x27;; console.log(parseInt(a), Number(a)); // 12, NaN console.log(parseInt(b), Number(b)); // 12, 456 console.log(parseInt(c), Number(c)); // NaN, NaN&#125;;&#123; /* parseInt的第二个参数转制问题，将当前数值定义为自定义进制，不用加前缀 然后转换为数字，所有都会被转为十进制 */ // 如果需要在ES5之前的环境运行并且没有polyfill，需要手动加上第二个参数10 // 强制转换为十进制，不然会被转为八进制，避免不必要的坑 let a = &quot;100&quot;; let b = 256; console.log(parseInt(a, 16)); // 256 console.log(parseInt(a, 8)); // 64 console.log(parseInt(a, 2)); // 4 console.log(parseInt(a, 10)); // 100 /* toString()传入参数，可以将当前数值转换为指定进制 */ console.log(b.toString(16)); // 100&#125;;&#123; /* 自定义转换 */ // 十进制数值转为自定义进制： let decimalToOther = function (num, transform) &#123; /* 返回的是字符串，用于展示 */ var num = +num; var transform = +transform; if (transform === 16) &#123; return &#x27;0x&#x27; + num.toString(16); &#125; else if (transform === 8) &#123; return &#x27;0o&#x27; + num.toString(8); &#125; else &#123; return num.toString(transform); &#125; &#125; console.log(decimalToOther(100, 8)); // &quot;0o144&quot; // 其他转制转换为十进制（传入标准格式0X或0o等字符串格式）： let otherToDecimal = function (num) &#123; /* 返回数字 */ var num = num.toLowerCase(); if (num.indexOf(&#x27;0x&#x27;) === 0) &#123; return parseInt(num.replace(/0x/, &#x27;&#x27;), 16); &#125; else if (num.indexOf(&#x27;0o&#x27;) === 0) &#123; return parseInt(num.replace(/0o/, &#x27;&#x27;), 8); &#125; else &#123; return parseInt(num, 10); &#125; &#125; console.log(otherToDecimal(&#x27;0x100&#x27;)); // 256&#125;;&#123; /* boolean显示转换，建议使用!!用来转换 */ let a = &quot;asd&quot;; let b = []; let c = &#123;&#125;; // 注意空数组和空对象都是返回true。是真值，所有的假值上面有提到 console.log(Boolean(a)); // true console.log(!!b); // true console.log(!!c); //true&#125;;&#123; let arr = [2, function () &#123; &#125;, 4, function () &#123; &#125;]; console.log(JSON.stringify(arr)); let json = JSON.stringify(arr, function (key, value) &#123; if (typeof value === &#x27;function&#x27;) &#123; return true; &#125; else &#123; return value &#125; &#125;); console.log(json); // [2,true,4,true]&#125;;&#123; /* || 或 &amp;&amp; 返回的不一定是布尔值 */ // 对于||，如果当前值判断为true，就会返回当前值 console.log(false || &quot;ss&quot; || 110); // &quot;ss&quot; // 对于&amp;&amp;，只要有一个值判断为false，就返回判断为false的那个值， // 否则返回最后一个值 console.log(&quot;55&quot; &amp;&amp; undefined &amp;&amp; 110); // undefined console.log(&quot;55&quot; &amp;&amp; null &amp;&amp; 110); // null console.log(&quot;55&quot; &amp;&amp; function () &#123; &#125; &amp;&amp; 110); // 110 // 所以||会有一个常用作用：传参判断 let func = function (a, b) &#123; a = a || &#x27;Hello&#x27;; b = b || &#x27;World&#x27;; return a + &quot; &quot; + b; &#125; console.log(func(&#x27;Hi&#x27;)); // Hi World console.log(func(&#x27;Hi&#x27;, &quot;&quot;)); // 注意这里传入了假值，结果依然是Hi World console.log(func(&#x27;Hi&#x27;, &quot; &quot;).trim()); // 传入空字符则判断为true，返回Hi console.log(typeof &quot;&quot;) // string，如有需求可以通过这个进行容错 // 所以&amp;&amp;会有一个常用作用：判断参数是否为true，是则执行一个函数 true &amp;&amp; (function () &#123; console.log(&#x27;this is &amp;&amp; function!&#x27;); &#125;)();&#125;;&#123; /* 注意ES6的Symbol只能够通过显式转换为字符串，使用隐式将会报错 */ let symbol = Symbol(&#x27;symbolElement&#x27;); console.log(String(symbol)); // &quot;Symbol(symbolElement)&quot; // symbol + &quot;&quot; 这样隐式转换会报错 // Symbol无法转换为数字，显示和隐式都会出错 // Symbol可以转换为boolean，隐式显式都转换为true console.log(Boolean(symbol)); // true console.log(!!symbol); // true&#125;;&#123; /* 关于==和===的使用准则 */ // 当两边有值为true和false的时候，前往不要使用== // 当两边有值为[]，&quot;&quot;，0时，尽量不要使用== // 使用===是最安全的选择&#125;;&#123; /* ++表达式 */ let a = 43; let b = (a++ , a); console.log(b); // 正确将44赋值给b&#125;;&#123; /* ES6的参数预留值可以理解为使用了let，存在暂时性死区TDZ */ // 下面声明赋值b的时候，同时进行了访问，这样在ES6有些情况会报错 let testTDZ = function (a = 3, b = a + b + 3) &#123; console.log(a, b); // 不报错就输出NaN &#125; // testTDZ();&#125;;&#123; /* 宿主变量 */ let div = document.createElement(&#x27;div&#x27;); console.log(typeof div); // object console.log(Object.prototype.toString.call(div)); // [object HTMLDivElement] console.log(div.tagName); // DIV&#125;;&#123; /* 由于浏览器历史遗留问题，在创建带有id 属性的DOM 元素时也会创建同名的全局变量 */ // &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; console.log(app); // 一个元素的id为app写在html，window全局对象就带有这个属性&#125; 第二部分 异步和性能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426/** * 你不知道的JavaScript(中卷) 第二部分 异步和性能 */// 模拟promise请求const promiseRequest = function(success, delay) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (success) &#123; if (typeof success === &#x27;boolean&#x27;) &#123; resolve(&#x27;promise success&#x27;); &#125; else &#123; resolve(success); &#125; &#125; else &#123; reject(&#x27;promise error&#x27;); &#125; &#125;, delay); &#125;);&#125;// 支持Promise的Generator Runnerconst run = function(gen) &#123; let args = [].slice.call(arguments, 1), it; // 在当前上下文中初始化生成器 it = gen.apply(this, args); // 返回一个promise用于生成器完成 return Promise.resolve().then(function handleNext(value) &#123; // 对下一个yield出的值运行 let next = it.next(value); return (function handleResult(next) &#123; // 生成器运行完毕了吗？ if (next.done) &#123; return next.value; &#125; // 否则继续运行 else &#123; return Promise.resolve(next.value).then( // 成功就恢复异步循环，把决议的值发回生成器 handleNext, // 如果value是被拒绝的 promise， // 就把错误传回生成器进行出错处理 function handleErr(err) &#123; return Promise.resolve( it.throw(err) ).then(handleResult); &#125; ); &#125; &#125;)(next); &#125;);&#125;&#123; // 分时函数，每次计时器处理一段数据，避免一次处理过多数据 const timeChunk = function(array = [], fn = () =&gt; &#123; &#125;, count = 1, interval = 200) &#123; let obj, timer; const start = function() &#123; for (let i = 0; i &lt; Math.min(count, array.length); i++) &#123; obj = array.shift(); fn(obj); &#125; &#125; return function() &#123; timer = setInterval(() =&gt; &#123; if (array.length === 0) &#123; return clearInterval(timer); &#125; start(); &#125;, interval); &#125; &#125; let dataArray = []; let resultArray = []; for (let i = 0; i &lt; 10; i++) &#123; dataArray.push(i); &#125; // 每1秒处理2个item const timeChunkFn = timeChunk(dataArray, function(item) &#123; resultArray.push(item * 2); &#125;, 2, 1000); timeChunkFn();&#125;;&#123; try &#123; // 延时的报错不会被catch到，只有同步的代码或生成器（类似于async）的才能catch到 setTimeout(() =&gt; &#123; // throw undefined &#125;, 100); &#125; catch (err) &#123; // 延时抛错永远不会被catch到，不会执行以下代码 console.log(err); &#125;&#125;;&#123; // generator let a = 100; const foo = function* () &#123; a++; yield; // 暂停 return a; &#125; let iterator = foo(); iterator.next(); let res = iterator.next(); console.log(res); // value, done const bar = function* (num) &#123; // 遇到yield表达式时，会暂停在赋值语句中间，并本质要求提供一个值 // 可以不设定预留值，即(yield)，不设定时默认返回的value是undefined let result = num * (yield &#x27;Hello&#x27;); return result; &#125; let iterator2 = bar(10); let res21 = iterator2.next(); // 函数停在yield表达式的中间，并把yield后的内容暂时作为value值 let res22 = iterator2.next(7); // 传值，赋值语句继续执行 console.log(res21, res22); // value: Hello, value: 70&#125;;&#123; // 仿标准迭代器iterator接口的写法 const iterator = (function() &#123; let nextval; return &#123; // for..of循环需要 [Symbol.iterator]: function() &#123; return this; &#125;, next: function() &#123; if (nextval === undefined) &#123; nextval = 1; &#125; else &#123; nextval = (3 * nextval) + 6 &#125; return &#123; done: false, value: nextval &#125; &#125; &#125; &#125;)(); for (let v of iterator) &#123; console.log(v); if (v &gt; 500) &#123; break; &#125; &#125;&#125;;&#123; // 使用标准生成器generator，执行后就成为iterator // iterator有next，throw和return这三个方法 const generator = function* () &#123; try &#123; let nextval; while (true) &#123; if (nextval === undefined) &#123; nextval = 1; &#125; else &#123; nextval = (3 * nextval) + 6; &#125; yield nextval; &#125; &#125; finally &#123; console.log(&#x27;Clean up&#x27;); &#125; &#125; for (let v of generator()) &#123; console.log(v); if (v &gt; 500) &#123; break; &#125; &#125;&#125;;&#123; // 异步迭代生成器普通版 const callbackRequest = function(success, delay) &#123; setTimeout(() =&gt; &#123; // 请求前会阻断同步代码，请求后才决定iterator的返回 if (success) &#123; it.next(&#x27;callback success&#x27;); &#125; else &#123; it.throw(&#x27;callback error&#x27;); &#125; &#125;, delay); &#125; // 看起来很像async-await const main = function* () &#123; // try-catch本来是无法捕获异步错误的，这里是属于同步代码，迭代器暂停 try &#123; let result = yield callbackRequest(true, 1000); console.log(result); &#125; catch (err) &#123; console.log(err); &#125; &#125; let it = main(); it.next();&#125;;&#123; // 异步迭代生成器配合Promise版 const main = function* () &#123; try &#123; let result = yield promiseRequest(true, 2000); console.log(result); &#125; catch (err) &#123; console.log(err); &#125; &#125; const it = main(); // 此时value的值是一个request里返回的promise const promise = it.next().value; promise.then(res =&gt; &#123; it.next(res); &#125;, err =&gt; &#123; it.throw(err); &#125;);&#125;;&#123; // yield的同步和并行操作比较，根据上个迭代配合promise使用Generator Runner函数 const mainStep = function* () &#123; // 都是同步代码，p3是在6秒后才打印出来 let p1 = yield promiseRequest(true, 1000); let p2 = yield promiseRequest(true, 2000); let p3 = yield promiseRequest(true, 3000); console.log(p3); &#125; run(mainStep); // 生成器的Promise并发 const mainAll = function* () &#123; // 这样写的p1和p2是并行的，首先都进行请求，然后再进行yield，所用时间是2s+3s let p1 = promiseRequest(&#x27;p1 yield&#x27;, 1000); let p2 = promiseRequest(&#x27;p2 yield&#x27;, 2000); // 并行开始，并且两者都完成了才会继续执行p3 let r1 = yield p1; let r2 = yield p2; let p3 = yield promiseRequest(`$&#123;r1&#125; and $&#123;r2&#125;`, 3000); console.log(p3); &#125; run(mainAll); // 当然也可以使用PromiseAll处理并发，换个方式 const mainPromiseAll = function* () &#123; let p1 = promiseRequest(&#x27;p1 promiseAll yield&#x27;, 1000); let p2 = promiseRequest(&#x27;p2 promiseAll yield &#x27;, 2000); let results = yield Promise.all([p1, p2]); let [r1, r2] = results; let p3 = yield promiseRequest(`$&#123;r1&#125; and $&#123;r2&#125;`, 3000); console.log(p3); &#125; run(mainPromiseAll);&#125;;&#123; // 使用现有的Async-Await进行上面的操作 const mainStep = async function() &#123; // 都是同步代码，p3是在6秒后才打印出来 let p1 = await promiseRequest(true, 1000); let p2 = await promiseRequest(true, 2000); let p3 = await promiseRequest(true, 3000); console.log(p3); &#125; mainStep(); const mainAll = async function() &#123; // 这样写的p1和p2是并行的，首先都进行请求，然后再进行await，所用时间是2s+3s let p1 = promiseRequest(&#x27;p1 await&#x27;, 1000); let p2 = promiseRequest(&#x27;p2 await&#x27;, 2000); // 并行开始，并且两者都完成了才会继续执行p3 let r1 = await p1; let r2 = await p2; let p3 = await promiseRequest(`$&#123;r1&#125; and $&#123;r2&#125;`, 3000); console.log(p3); &#125; mainAll(); // 当然也可以使用PromiseAll处理并发，换个方式 const mainPromiseAll = async function() &#123; let p1 = promiseRequest(&#x27;p1 promiseAll await&#x27;, 1000); let p2 = promiseRequest(&#x27;p2 promiseAll await &#x27;, 2000); let results = await Promise.all([p1, p2]); let [r1, r2] = results; let p3 = await promiseRequest(`$&#123;r1&#125; and $&#123;r2&#125;`, 3000); console.log(p3); &#125; mainPromiseAll(); /** * 这里注意，如果再使用Promise.all时，里面所有的promise进行了返回了catch，那么在Promise.all * 里就就算报错了，也会走all的then，而不会走catch，如果想分别报错捕获，就在每个promise里进行 * catch处理并return出去，如果想只有一个报错就执行all的catch，就不要在里面写catch，注意 * */&#125;;&#123; // 生成器调用另一个生成器，依旧依赖Generator Runner const foo = function* () &#123; let r1 = yield promiseRequest(&#x27;p1 another&#x27;, 1000); let r2 = yield promiseRequest(`$&#123;r1&#125; and p2 another`, 2000); return r2; &#125; const bar = function* () &#123; let r3 = yield promiseRequest(&#x27;p3&#x27;, 100); let r2 = yield run(foo); console.log(r2); &#125; run(bar);&#125;;&#123; // 生成器调用另一个生成器，但使用yield委托，异步委托 const foo = function* () &#123; let r1 = yield promiseRequest(&#x27;p1 another&#x27;, 1000); let r2 = yield promiseRequest(`$&#123;r1&#125; and p2 another 委托版`, 2000); return r2; &#125; const bar = function* () &#123; let r3 = yield promiseRequest(&#x27;p3&#x27;, 100); // 注意这里，使用的是yield* let r2 = yield* foo(); console.log(r2); &#125; run(bar);&#125;;// await的Promise.all的错误捕获之一，统一在Promise.all中的catch捕获&#123; const doRequest1 = async () =&gt; &#123; let res = await promiseRequest(false, 1000); return res; &#125; const doRequest2 = async () =&gt; &#123; let res = await promiseRequest(&#x27;await try-catch-2&#x27;, 2000); return res; &#125; // doRequest1报错后接下来的请求都不会再执行，错误提示只提一遍 Promise.all([doRequest1(), doRequest2()]).then(res =&gt; &#123; console.log(res); &#125;).catch(err =&gt; &#123; console.log(err); &#125;);&#125;;// await的Promise.all的错误捕获之二，分别在里面的Promise都进行try-catch处理，Promise.all里的catch就不会再执行&#123; const doRequest1 = async () =&gt; &#123; try &#123; let res = await promiseRequest(false, 1000); return res; &#125; catch (err) &#123; console.log(err); &#125; &#125; const doRequest2 = async () =&gt; &#123; try &#123; let res = await promiseRequest(&#x27;await try-catch-2&#x27;, 2000); return res; &#125; catch (err) &#123; console.log(err); &#125; &#125; // doRequest1报错后接下来的请求也会继续执行，有多少个错误就报多少个错，只要里面每个Promise都进行了错误捕获，然后只会执行then，永远不会执行catch，因为已经捕获过了 Promise.all([doRequest1(), doRequest2()]).then(res =&gt; &#123; console.log(res); &#125;).catch(err =&gt; &#123; console.log(&#x27;do not run here forever&#x27;); &#125;);&#125;;","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://sellenite.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"你不知道的JavaScript（上）读书笔记","date":"2019-01-13T05:23:58.000Z","path":"2019/01/13/你不知道的JavaScript（上）读书笔记/","text":"第一部分 作用域和闭包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240/** * 你不知道的JavaScript(上卷) 第一部分 作用域和闭包 */window.GLOBAL = &#x27;ALL_ELEMENT&#x27;;&#123; /* 提交表单时永远不要使用eval，它可以执行任何传给它的字符串，很容易遭受XSS攻击 */ // eval在严格模式下有自己的作用域 let testEval = function(str, b) &#123; // &quot;use strict&quot;; 使用这句后会报ReferenceError，a is not defined eval(str); // 欺诈行为 // console.log(a, b); &#125; testEval(&quot;var a = 2;&quot;, 4); // 2, 4 顺利改写a&#125;;&#123; /* 永远不要使用with进行对象赋值，操作不当很有可能泄漏都全局变量 */ // with在严格模式下被完全禁止，以下代码为泄漏全局变量的例子，在非严格模式下执行 /* let testWith = function(obj) &#123; with(obj) &#123; _a = &#x27;with revise successfully&#x27;; &#125; &#125; let obj1 = &#123; &quot;_a&quot;: 233 &#125;; let obj2 = &#123; &quot;_b&quot;: 445 &#125;; testWith(obj1); // obj1._a = with revise successfully testWith(obj2); // obj2._a = undefined console.log(window._a); // with revise successfully，由于作用域问题泄漏到全局变量 */&#125;;&#123; /* 回调函数参数是函数表达式，并不是函数声明 */ setTimeout(function timeoutHandler() &#123; console.log(&#x27;global setTimeout&#x27;) &#125;, 300);&#125;;&#123; let a = 233; /* 立即执行函数第一个括号里的内容被当作函数表达式 */ (function() &#123; var a = 1 console.log(&#x27;inner IIFE&#x27;, a); &#125;)(); /* 立即执行函数也可以拥有函数名，也可以传参 */ (function IIFE(a) &#123; console.log(&#x27;global IIFE&#x27;, a); &#125;)(a); /* 以上代码语义上等同于下面，上面的IIFE全局下是无法访问的 */ var IIFE = function(a) &#123; console.log(&#x27;global IIFE2&#x27;, a); &#125;(a); /* UMD，将函数表达式传进IIFE的模式 */ (function(fn) &#123; fn(window); &#125;)(function def(global) &#123; var a = 2; console.log(&#x27;inner UMD&#x27;, a); console.log(&#x27;global UMD&#x27;, global.GLOBAL); &#125;);&#125;;&#123; /* var变量声明提升 */ (function() &#123; console.log(a); // undefined var a = 2; &#125;)(); /* 以上代码等同于下面 */ (function() &#123; var a; console.log(a); var a = 2; &#125;)(); /* 函数声明可以提前，函数表达式的声明会像上面变量一样的提升成undefied */ foo(); function foo() &#123; console.log(&#x27;foo&#x27;); &#125; /* 函数表达式提升成undefined，执行undefined会报TypeError，而不是ReferenceError */ try &#123; bar(); var bar = function() &#123; console.log(&#x27;bar&#x27;); &#125;; &#125; catch (error) &#123; console.log(error); &#125;&#125;;&#123; (function() &#123; /* 基础标准闭包 */ function foo() &#123; var a = 2; return function() &#123; console.log(a); &#125;; &#125; var baz = foo(); baz(); /* 闭包循环 */ for (var i = 0; i &lt; 4; i++) &#123; (function(j) &#123; setTimeout(function timeoutHandler() &#123; console.log(j); &#125;, j * 300); &#125;)(i) &#125; /* 基本模块设计模式 */ function coolModule() &#123; var something = &#x27;cool&#x27;; var another = [1, 2, 3]; function doSomething() &#123; console.log(something); &#125; function doAnother() &#123; console.log(another.join(&#x27;!&#x27;)); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;; &#125; var cool = coolModule(); cool.doAnother(); cool.doSomething(); /* 现代模块依赖加载器，类requireJS模式 */ var MyModules = (function Manager() &#123; var modules = &#123;&#125;; function define(name, deps, impl) &#123; for (var i = 0; i &lt; deps.length; i++) &#123; deps[i] = modules[deps[i]]; &#125; // 最主要函数，使用函数返回值执行 modules[name] = impl.apply(impl, deps); &#125;; function get(name) &#123; return modules[name]; &#125;; return &#123; define: define, get: get &#125;; &#125;)(); MyModules.define(&#x27;foo&#x27;, [], function() &#123; var _this = this; function hello() &#123; console.log(_this); &#125;; return &#123; hello: hello &#125;; &#125;) MyModules.define(&#x27;bar&#x27;, [&#x27;foo&#x27;], function(foo) &#123; function hi() &#123; console.log(&#x27;bar with foo&#x27;); foo.hello(); &#125;; return &#123; hi: hi &#125;; &#125;); var Foo = MyModules.get(&#x27;foo&#x27;); var Bar = MyModules.get(&#x27;bar&#x27;); Bar.hi(); &#125;); (function() &#123; /* Traceur项目try-catch解决ES6以前的级作用域 */ try &#123; throw undefined; &#125; catch (catchValue) &#123; // 外部无法访问或使用这个变量 catchValue = 2; console.log(&#x27;try-catch block&#x27;, catchValue); &#125; /* 显式创建块级作用域 */ &#123; let a = 2; const readonly = &#x27;yuuhei&#x27;; console.log(a, readonly) &#125; /* bind解决setTimeout等时被绑定window为上下文 */ var obj = &#123; count: 1, cool: function() &#123; if (this.count &lt; 5) &#123; setTimeout(function() &#123; this.count++; console.log(&#x27;more awesome: &#x27;, this.count); &#125;.bind(this), this.count * 300); &#125; &#125; &#125; obj.cool(); /* 箭头函数绑定前后上下文 */ var object = &#123; count: 3, cool: function() &#123; if (this.count &lt; 5) &#123; setTimeout(() =&gt; &#123; this.count++; console.log(&#x27;more awesome arrow: &#x27;, this.count); &#125;, this.count * 300); &#125; &#125; &#125; object.cool(); &#125;)();&#125;; 第二部分 this和对象原型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525/** * 你不知道的JavaScript(上卷) 第二部分 this和对象原型 */&#123; (function() &#123; var a = &#x27;ALL&#x27;; /* arguments.callee可以用来引用正在运行的函数，包括匿名函数 */ setTimeout(function() &#123; // 该方法是一种被废弃的方案，严格模式下会报错 console.log(arguments.callee); &#125;, 300); /* 在函数普通模式下直接调用默认绑定的this为全局对象window */ (function() &#123; // 在严格模式下则不会默认绑定，this为undefined use strict一定要写在第一行 &#x27;use strict&#x27;; function foo() &#123; console.log(this); // undefined &#125; foo(); &#125;)(); /* 函数定义在非严格模式下，即使在严格模式下调用依然被默认绑定为window */ function foo() &#123; console.log(this); &#125;; (function() &#123; &#x27;use strict&#x27;; foo(); // window &#125;)(); /* 隐式绑定例子 */ (function() &#123; function foo() &#123; console.log(this.a); &#125;; var obj = &#123; a: 233, foo: foo &#125;; obj.foo() // 2 &#125;)(); /** * 把基本数据类型转换为对应的引用类型的操作称为装箱，把引用类型转换为基本的数据类型称为拆箱 * 装箱的最大作用是将值作为对象来处理 */ (function() &#123; // 简易装箱 function foo() &#123; return this; &#125;; foo.call(true); // Boolean &#123;[[PrimitiveValue]]: true&#125; foo.call(&#x27;123&#x27;); // String &#123;[[PrimitiveValue]]: &quot;123&quot;&#125; let num = foo.call(456); // Number &#123;[[PrimitiveValue]]: 456&#125; // 简易拆箱 num.valueOf(); &#125;)(); &#123; let foo = function() &#123; console.log(this); &#125;; let abc = foo.bind(null); /* 严格模式下，this指向是null，但非严格模式下，this指向是window，注意 */ abc(); &#125; /* 为了避免以上情况，使用DMZ来绑定更安全的this，避免默认绑定规则 */ (function() &#123; function foo(a, b) &#123; console.log(this); // ALL console.log(&#x27;a: &#x27; + a + &#x27;, b: &#x27; + b); &#125; // 创建完全空的对象，DMZ var DMZ = Object.create(null); var bar = foo.bind(DMZ, 2); bar(4); &#125;)(); /* 箭头函数不适用于以上几条规则 */ (function() &#123; function foo() &#123; // 返回一个箭头函数 return (a) =&gt; &#123; // this继承自foo console.log(this.a); &#125; &#125; var obj1 = &#123; a: 2 &#125; var obj2 = &#123; a: 4 &#125; var bar = foo.call(obj1); bar.call(obj2); // 2，这里的call由于使用了箭头强制绑定了上下文，一直是obj1 &#125;)(); /* forEach的第二个参数可以绑定上下文，和bind效果一样 */ (function() &#123; [1, 3, 4].forEach(function(item, index) &#123; console.log(item, this.name); &#125;, &#123; name: &#x27;yuuhei&#x27; &#125;); &#125;)(); &#125;)();&#125;;&#123; let arr = [ 23, 1, 6, 78, 9, 22, 3, 100 ]; let ret = []; arr.every((item) =&gt; &#123; ret.push(item); /* 遍历每一个元素，直至返回false */ return item % 11 !== 0; &#125;); console.log(ret);&#125;;&#123; let arr = [ 23, 1, 6, 78, 9, 22, 3, 100 ]; let ret = []; arr.some((item) =&gt; &#123; ret.push(item); /* 遍历每一个元素，直至返回true */ return item % 9 === 0; &#125;); console.log(ret);&#125;;&#123; let arr = [2, 4, 6]; for (let i of arr) &#123; console.log(i); &#125;&#125;;/* 数组自带迭代器，可以使用for-of遍历数组的值 */&#123; let arr = [1, 2, 3]; let it = arr[Symbol.iterator](); console.log(it.next());&#125;;/* 对象本身没有迭代器，需要模仿后才能使用for-of *//* 由于迭代器的属性就是Symbol.iterator，需要使用键值访问法 */&#123; let obj = &#123; name: &#x27;yuuhei&#x27;, age: &#x27;232&#x27; &#125;; /* 这样定义可以不让Symbol被枚举，直接定义也是可以的 */ Object.defineProperty(obj, Symbol.iterator, &#123; enumerable: false, writable: false, configurable: true, value: function() &#123; var o = this; var index = 0; var keys = Object.keys(o); return &#123; next: function() &#123; return &#123; value: o[keys[index++]], done: (index &gt; keys.length) &#125; &#125; &#125; &#125; &#125;); for (let k of obj) &#123; console.log(k); &#125;&#125;;&#123; let obj = &#123; a: 1, b: 233, c: 445, [Symbol.iterator]: function() &#123; var o = this; var idx = 0; var ks = Object.keys(o); return &#123; next: function() &#123; return &#123; value: o[ks[idx++]], done: (idx &gt; ks.length) &#125; &#125; &#125; &#125; &#125; let it = obj[Symbol.iterator](); console.log(it.next()); console.log(it.next()); console.log(it.next()); console.log(it.next());&#125;;&#123; /* Object.create(obj)会将[[prototype]]关联到指定对象，继承就由于这个原理 */ let obj = &#123; a: 123 &#125; let obj2 = Object.create(obj); console.log(obj2.a)&#125;;&#123; let obj = &#123; age: 23 &#125;; Object.defineProperty(obj, &#x27;name&#x27;, &#123; writable: false, enumerable: false, configurable: false, value: &#x27;yuuhei&#x27; &#125;); console.log(obj); for (let i in obj) &#123; console.log(i) // age &#125;; /* 无论enumerable是什么，in操作符都能够判断key是否在obj中，并且寻找原型链 */ console.log(&#x27;name&#x27; in obj);&#125;;&#123; /* ES6拥有Object.setPrototypeOf进行原型链继承 */ let Foo = function() &#123; &#125;; Foo.prototype.a = 1; let Bar = function() &#123; &#125;; Object.setPrototypeOf(Bar.prototype, Foo.prototype); let bar = new Bar(); console.log(bar.a);&#125;;&#123; /* 组合继承 */ let Foo = function(name) &#123; this.name = name; &#125;; let Bar = function(name, age) &#123; /* 绑定父亲的构造属性 */ Foo.call(this, name); this.age = age; &#125;; /* 将Bar的[[prototype]]关联到Foo的，继承Foo的原型链属性 */ Bar.prototype = Object.create(Foo.prototype); /* 修改过prototype后需要手动修复constructor的指向 */ Bar.prototype.constructor = Bar; Bar.prototype.myName = function() &#123; return this.name; &#125;; let bar = new Bar(&#x27;yuuhei&#x27;, 23); console.log(bar.myName()); /* ES5直接获取一个对象的[[prototype]]的方式 */ console.log(Object.getPrototypeOf(bar) === Bar.prototype); /* 绝大多数浏览器（非标准获取方式）支持 */ console.log(bar.__proto__ === Bar.prototype); /* 继承也可以通过instanceof找到源头 */ console.log(bar instanceof Foo);&#125;;&#123; /* Object.create自带第二个参数可以定义属性描述符 */ let obj = &#123; a: 2 &#125;; let obj2 = Object.create(obj, &#123; b: &#123; writable: false, enumerable: false, configurable: true, value: 3 &#125;, c: &#123; writable: false, enumerable: false, configurable: true, value: 3 &#125; &#125;); // obj2的原型链上连接了obj的原型链 console.log(obj2.a); // 2 console.log(obj2.hasOwnProperty(&#x27;a&#x27;)); // false console.log(obj.hasOwnProperty(&#x27;a&#x27;));&#125;;&#123; /* 神奇的API设计，由于本身内部没有该函数，却能够运行，会变得怪怪的 */ /* 面向委托模式来源于Object.create()这个特性 */ let obj = &#123; cool: function() &#123; console.log(&#x27;cool!&#x27;); &#125; &#125;; let obj2 = Object.create(obj); obj2.cool(); // cool!&#125;;&#123; /* 经典类继承面向对象风格 */ let Foo = function(name) &#123; this.name = name; &#125;; let Bar = function(name, age) &#123; Foo.call(this, name); this.age = age; &#125;; Bar.prototype = Object.create(Foo.prototype); Bar.prototype.constructor = Bar; let bar1 = new Bar(&#x27;yuuhei&#x27;, 22); let bar2 = new Bar(&#x27;Sellenite&#x27;, 24); console.log(bar1, bar2);&#125;;&#123; /* 对象委托关联风格 */ let Foo = &#123; init: function(name) &#123; this.name = name; &#125;, identify: function() &#123; return `I am $&#123;this.name&#125;`; &#125; &#125;; let Bar = Object.create(Foo); Bar.speak = function() &#123; console.log(this.identify()); &#125;; let b1 = Object.create(Bar); let b2 = Object.create(Bar); b1.init(&#x27;yuuhei&#x27;); b2.init(&#x27;Sellenite&#x27;); b1.speak(); b2.speak(); console.log(Bar); // &#123;speak:f()&#125; console.log(b1); // &#123;name: &#x27;yuuhei&#x27;&#125;&#125;;&#123; /* 反词法 */ /* ES6以下的简洁写法会编译成匿名函数，无法进行递归 */ let Foo = &#123; // 最好不要使用this.bar()或Foo.bar()执行递归，因为可用实际情况比较少 bar() &#123; &#125; &#125;; // 以上实际会编译成以下方式 let Foo1 = &#123; bar: function() &#123; &#125; &#125;; // 如果要想使用递归，不要使用简介方式，需要使用具名函数表达式 let Foo2 = &#123; count: 0, bar: function baroooo() &#123; if (this.count &lt; 10) &#123; console.log(&#x27;loading------&gt;&#x27; + this.count); this.count++; /* 具名函数进行自我递归 */ baroooo.call(this); &#125; &#125; &#125;; Foo2.bar();&#125;;&#123; let Foo = function(name) &#123; this.name = name; &#125;; let Bar = function(name, age) &#123; Foo.call(this, name); this.age = age; &#125;; Bar.prototype = Object.create(Foo.prototype); let bar = new Bar(&#x27;yuuhei&#x27;, 23); /* 内省 */ // 首先要纠正错误，Bar instanceof Foo是错的 /* 构造函数之间Foo和Bar的内省 */ Bar.prototype instanceof Foo; // true Object.getPrototypeOf(Bar.prototype) === Foo.prototype; // true Foo.prototype.isPrototypeOf(Bar.prototype); // true /* 实例和构造函数之间的内省 */ bar instanceof Bar; // true bar instanceof Foo; // true Object.getPrototypeOf(bar) === Bar.prototype; /// true Foo.prototype.isPrototypeOf(bar); // true Bar.prototype.isPrototypeOf(bar); // true&#125;;&#123; /* Orbment.prototype.call(this, ...)是伪多态 */ class Orbment &#123; constructor(name) &#123; this.name = name || &#x27;Orbment&#x27;; this.message = null; &#125; setSize(width, height) &#123; this.width = width || 50; this.height = height || 50; this.message = `The $&#123;this.name&#125; `; &#125; getMessage() &#123; return this.message; &#125; &#125; class ENIGMA extends Orbment &#123; constructor(name, width, height) &#123; // super()在constructor必须在this调用前执行 super(name); this.width = width || 50; this.height = height || 50; &#125; setSize(width, height) &#123; // 以前的伪多态写法：Orbment.prototype.setSize.apply(this, [width, height]) // 注意出版书上的super(width, height)在constructor外使用已被禁止，改为替换以下方式实现相对多态 super.setSize(width, height); this.message += `size is width $&#123;this.width&#125; and height $&#123;this.height&#125;`; return this; &#125; &#125; class ARCUS extends Orbment &#123; constructor(name, width, height) &#123; // super()在constructor必须在this调用前执行 super(name); this.width = width || 50; this.height = height || 50; &#125; setSize(width, height) &#123; // 以前的伪多态写法：Orbment.prototype.setSize.apply(this, [width, height]) // 注意出版书上的super(width, height)在constructor外使用已被禁止，改为替换以下方式实现相对多态 super.setSize(width, height); this.message += `size is width $&#123;this.width&#125; and height $&#123;this.height&#125;`; return this; &#125; &#125; let ENIGMA_I = new ENIGMA(&#x27;ENIGMA_I&#x27;); let ENIGMA_I_SIZE_MESSAGE = ENIGMA_I.setSize().getMessage(); let ARCUS_I = new ARCUS(&#x27;ARCUS_I&#x27;); let ARCUS_I_SIZE_MESSAGE = ARCUS_I.setSize(100, 70).getMessage(); console.log(ENIGMA_I_SIZE_MESSAGE); console.log(ARCUS_I_SIZE_MESSAGE);&#125;;&#123; /* class并不是静态，只是一个prototype的语法糖，使用prototype仍可修改 */ class Random &#123; constructor() &#123; this.num = Math.random(); &#125; rand() &#123; console.log(this.num); &#125; &#125; let r1 = new Random(); r1.rand(); Random.prototype.rand = function() &#123; console.log(this.num * 1000); &#125;; let r2 = new Random(); r2.rand();&#125;;","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://sellenite.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"简单实现一个步骤条","date":"2019-01-07T03:52:25.000Z","path":"2019/01/07/简单实现一个步骤条/","text":"代码部分参考ElementUI的步骤条结构，如果作为组件，循环判断每个步骤的状态，加上对应的class即可。这里定义pass、current、future，每个状态都有不同的样式。这里是横版的，竖版的大同小异 特别要注意横线的处理，移位的方法 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div class=&quot;step-bar&quot;&gt; &lt;div class=&quot;list-item pass&quot;&gt; &lt;div class=&quot;head&quot;&gt; &lt;div class=&quot;line-wrapper&quot;&gt; &lt;i class=&quot;line&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class=&quot;icon-wrapper&quot;&gt; &lt;i class=&quot;icon&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;content-wrapper&quot;&gt; &lt;span class=&quot;content&quot;&gt;步骤一&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;list-item current&quot;&gt; &lt;div class=&quot;head&quot;&gt; &lt;div class=&quot;line-wrapper&quot;&gt; &lt;i class=&quot;line&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class=&quot;icon-wrapper&quot;&gt; &lt;i class=&quot;icon&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;content-wrapper&quot;&gt; &lt;span class=&quot;content&quot;&gt;步骤二&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;list-item future&quot;&gt; &lt;div class=&quot;head&quot;&gt; &lt;div class=&quot;line-wrapper&quot;&gt; &lt;i class=&quot;line&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class=&quot;icon-wrapper&quot;&gt; &lt;i class=&quot;icon&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;content-wrapper&quot;&gt; &lt;span class=&quot;content&quot;&gt;步骤三&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788.step-bar &#123; box-sizing: border-box; display: flex; justify-content: space-between;&#125;.list-item &#123; flex: 1; .head &#123; position: relative; &#125; .line-wrapper &#123; position: absolute; height: 1px; background-color: #c0c4cc; /* 实现n个元素但有n-1条线的必要条件，且需要将最后的线删除 */ left: 50%; right: -50%; top: 7px; .line &#123; display: block; width: 100%; height: 100%; &#125; &#125; .icon-wrapper, .content-wrapper &#123; text-align: center; &#125; .content-wrapper &#123; margin-top: 6px; &#125; &amp;:last-of-type &#123; .line-wrapper &#123; display: none; &#125; &#125; .icon &#123; display: inline-block; width: 10px; height: 10px; border-radius: 50%; position: relative; z-index: 1; border: 2px solid #FFF; &#125; &amp;.current &#123; .icon &#123; background-color: #2298fe; &#125; .content &#123; color: #2298fe; &#125; &#125; &amp;.pass &#123; .icon &#123; background-color: #b9defe; &#125; .content &#123; color: #b9defe; &#125; .line &#123; background-color: #b9defe; &#125; &#125; &amp;.future &#123; .icon &#123; background-color: #dfe4e8; &#125; .content &#123; color: #dfe4e8; &#125; &#125;&#125;","tags":[{"name":"组件","slug":"组件","permalink":"https://sellenite.github.io/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"JavaScript高级程序设计笔记","date":"2018-11-01T03:21:09.000Z","path":"2018/11/01/JavaScript高级程序设计笔记/","text":"全局函数isNaN()的问题 isNaN()去执行一个非数字字符串，会返回true，注意。 因为isNaN()的本意是去判断这个参数是否”不是数值”，任何不能被转为数值的值都会导致这个函数返回true，注意，即首先对参数进行一次Number转换，返回为NaN的参数会被判断为NaN 123456alert(isNaN(NaN)); //truealert(isNaN(10)); //false（ 10 是一个数值）alert(isNaN(&quot;10&quot;)); //false（可以被转换成数值 10）alert(isNaN(true)); //false（Boolean可以被转换成数值 1）alert(isNaN(&quot;blue&quot;)); //true（非数字字符串不能转换成数值）alert(isNaN(undefined)); //true（undefined不能转换成数值） 解决方案有两种：利用NaN是唯一一个与自身严格不相等的值： 123function myIsNaN(value) &#123; return value !== value; &#125; 在使用isNaN()之前先检查一下这个值是不是数字类型，这样就避免了隐式转换的问题： 123function myIsNaN2(value) &#123; return typeof value === &#x27;number&#x27; &amp;&amp; isNaN(value); &#125; null进行数值转换为0，undefined进行数值转换为NaNjs将字符串转换为dom元素的方法，利用childNodes1234567function parseDom(arg) &#123; var objE = document.createElement(&quot;div&quot;); objE.innerHTML = arg; return objE.childNodes[0];&#125;;var obj=parseDom(&#x27;&lt;div id=&quot;div_1&quot; class=&quot;div1&quot;&gt;Hello World!&lt;/div&gt;&#x27;); 注意：childNodes返回的是一个类似数组的list。所以如果是一个元素，要使用这个dom需要这样使用obj[0]。如果是多个同级的dom转换，可以这样使用obj[0]、obj[1]… js获取元素的兄弟元素12345678910var siblings = function (el) &#123; var arr = []; var children = el.parentNode.children; for (var i = 0, len = children.length; i &lt; len; i++) &#123; if (children[i] !== el) &#123; arr.push(children[i]); &#125; &#125; return arr;&#125; new原理使用构造函数，要创建新的实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4个步骤： 创建一个新对象； 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）； 执行构造函数中的代码（为这个新对象添加属性）； 返回新对象。 实现代码: 123456789101112131415161718192021var Person = function (name, age) &#123; this.name = name; this.age = age;&#125;var newConstructor = function (Foo, ...args) &#123; // 继承构造函数prototype的属性，有两种写法 // var obj = &#123;&#125;; // obj.__proto__ = Foo.prototype; var obj = Object.create(Foo.prototype); // 执行并绑定this到新对象 var k = Foo.apply(obj, args); // 返回 if (typeof k === &#x27;object&#x27;) &#123; return k; &#125; else &#123; return obj; &#125;&#125;var person = newConstructor(Person, &#x27;yuuhei&#x27;, 23);","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://sellenite.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"JS工作经验总结（2）","date":"2018-10-29T02:21:20.000Z","path":"2018/10/29/JS工作经验总结（2）/","text":"本文主要记录工作时JS问题或经验 new Array()的遍历问题new Array(3)这样得出的稀疏数组不能够进行遍历，需要进行特殊的转义才能够遍历 webkitTransitionEnd监听Transition动画结束事件css3的过渡属性transition，在动画结束时，也存在结束的事件：webkitTransitionEnd; 注意：transition,也仅仅有这一个事件。 1$el.addEventListener(&#x27;webkitTransitionEnd&#x27;, handler, false); css3的动画animation也能够监听事件，分别在开始和结束时都能够监听到animationstart，animationend 阻止冒泡问题stopPropagation()方法既可以阻止事件冒泡，也可以阻止事件捕获 stopImmediatePropagation()和 stopPropagation()的区别在，后者只会阻止冒泡或者是捕获。 但是前者除此之外还会阻止该元素的其他事件发生，但是后者就不会阻止其他事件的发生 arguments的问题arguments不是一个真正的数组，是一个类数组，无法使用shift等数组方法，只能使用Array.prototype.slice.apply(arguments)转换成真正的数组，或者使用[].shift.call(arguments)之类的方法来调用数组的方法 img作为数据统计的问题img经常进行用于数据上报，做用户埋点什么的，消息已读什么的，就是将query放在图片的请求地址上就可以了。需要注意在使用img进行http请求时，img对象需要存储在闭包里，避免函数执行后，里面的变量在http请求完成前被销毁，导致发送不成功，会造成请求丢失的问题例子（使用闭包封装img变量，避免销毁）： 123456789101112131415161718var tracker = (function() &#123; var imgs = []; var url = &#x27;https://www.baidu.com/img/bd_logo1.png&#x27;; return function(id, obj = &#123;&#125;) &#123; var query = &#x27;?id=&#x27; + id; for (var i in obj) &#123; query += &#x27;&amp;&#x27; + i + &#x27;=&#x27; + obj[i]; &#125; var img = new Image(); imgs.push(img); img.src = url + query; &#125;&#125;)();tracker(&#x27;TEST_TRACKER&#x27;, &#123; name: &#x27;yuuhei&#x27;, age: &#x27;24&#x27;&#125;); js数组的push实际是进行复制下面类似v8的实现源码： 123456789Array.prototype.arrayPush = function() &#123; var _length = this.length; var n = arguments.length; for (var i = 0; i &lt; n; i++) &#123; this[_length + i] = arguments[i] &#125; this.length = _length + n; return this.length;&#125; arguments.callee就是执行函数本身，常用是递归flex布局左右分配规则1234567891011121314&lt;div class=&quot;test&quot;&gt; &lt;div class=&quot;left&quot;&gt;左边有预留位置，有空位补充&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右边没预留位置，文字多长容器就多长&lt;/div&gt;&lt;/div&gt;.test &#123; display: flex;&#125;.test .left &#123; flex: 1 1 auto;&#125;.test .right &#123; flex: 0 0 auto;&#125; flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小，占据固定空间。 script也有onload12345678var script = document.createElement(&#x27;script&#x27;);script.onload = function() &#123; for (var i = 0, fn; fn = cache[i++];) &#123; fn(); &#125;&#125;script.src = &#x27;./miniConsole.js&#x27;;document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(script); img懒加载完美版js实现图片加载前显示loading，先设置一个自定义属性，然后img的src先指向loading的位置，然后每个img依次使用new Image()，预加载好自定义属性里的图片地址，待预加载好了的时候，使用onload将img的地址指向真正的src 实例： 1234&lt;div&gt; &lt;img src=&quot;./loading.gif&quot; data-src=&quot;https://www.baidu.com/img/bd_logo1.png&quot; class=&quot;lazy-image&quot; /&gt; &lt;img src=&quot;./loading.gif&quot; data-src=&quot;https://www.baidu.com/img/bd_logo1.png&quot; class=&quot;lazy-image&quot; /&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 节流函数var throttle = function(fn, interval) &#123; var timer, firstTime = true; return function() &#123; var _this = this; if (firstTime) &#123; fn.apply(_this, arguments); firstTime = false; &#125; if (timer) &#123; return false; &#125; timer = setTimeout(function() &#123; clearTimeout(timer); timer = null; fn.apply(_this, arguments); &#125;, interval || 200); &#125;&#125;// 先添加缓存，然后再赋值var lazyImage = function(imageItem) &#123; // .style.cssText会将元素的行内元素整个覆盖 imageItem.style.cssText = &quot;transition: &#x27;&#x27;; opacity: 0;&quot;; var img = new Image(); var realSrc = imageItem.getAttribute(&#x27;data-src&#x27;); img.src = realSrc; img.onload = function() &#123; imageItem.src = realSrc; imageItem.style.cssText = &quot;transition:all 1s; opacity: 1;&quot;; imageItem.onLoad = true; imageItem.removeAttribute(&#x27;data-src&#x27;); &#125;&#125;var renderImage = function(event) &#123; var imageList = document.getElementsByClassName(&#x27;lazy-image&#x27;); // 无序加载（图片加载完的时间不是有序） for (var i = 0, imageItem; imageItem = imageList[i++];) &#123; if (document.documentElement.clientHeight + document.documentElement.scrollTop &gt; imageItem.offsetTop &amp;&amp; !imageItem.onLoad) &#123; lazyImage(imageItem); &#125; &#125;&#125;window.addEventListener(&#x27;load&#x27;, renderImage, false);window.addEventListener(&#x27;scroll&#x27;, throttle(renderImage, 300), false); 倒序遍历： 123for (var l = arr.length - 1; l &gt;= 0; l--) &#123;&#125; 关于es6中的WeakSet和WeakMap：（Weak都是为了对象解决引用内存的问题） WeakMap 只能用Object作为key，不能用基本数据类型比如字符串作为key WeakMap 中的key是弱引用 WeakMap 没有size WeakMap 不支持遍历 没有size和不支持遍历的原因是，由于Weak内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此ES6规定Weak不可遍历 Map 的一个最大弊端就是它会导致作为key的对象增加一个引用，因此导致GC无法回收这个对象，如果大量使用object作为Map的key会导致大量的内存泄露 WeakMap就是为了解决这个问题，在WeakMap中对作为key的对象是一个弱引用，也就是说，GC在计算对象引用数量的时候并不会把弱引用计算进去。这样当一个对象除了WeakMap没有其他引用的时候就会被GC 自定义事件的创造和触发（version &gt;&#x3D; ie9）12345678910111213141516171819202122232425262728// 建立自定义事件创造函数var createEvent = function createEvent (name) &#123; // new CustomEvent可以自定义event对象返回时的属性 return new Event(name, &#123; bubbles: true &#125;);&#125;;try &#123; new Event(&#x27;test&#x27;);&#125; catch (e) &#123; // IE does not support `new Event()` createEvent = function (name) &#123; var evt = document.createEvent(&#x27;Event&#x27;); evt.initEvent(name, true, false); return evt; &#125;;&#125;// 订阅el.addEventListener(&#x27;customEvent&#x27;, fn, false);// 触发var customEvent = createEvent(&#x27;customEvent&#x27;);try &#123; el.dispatchEvent(customEvent);&#125; catch (err) &#123; // Firefox will throw an error on dispatchEvent for a detached element // https://bugzilla.mozilla.org/show_bug.cgi?id=889376&#125; 注意，手动触发事件更好的做法是 IE 下用 fireEvent，标准浏览器下用 dispatchEvent 实现 可以使用array.length &#x3D; 0来清空一个数组客户端的cookies和服务端的sessionhttp是一种无状态的协议，就是收到一个请求，就返回一个响应，而不关心请求者的身份。cookie就是在用户端保存请求信息的机制，每次请求的时候请求头都会携带cookie cookie是一个分号分隔的多个key-value的字段，它也存在于本地的加密文件里，但只有浏览器能够操作它，本地打开是加密后文件 cookie有几个字段： name：代表cookie的名称 domain：cookie生效的域名，有作用域概念的，比如说二级域名能够使用一级域名的cookie，但不能使用其他二级域名，也不能操作所处的三级域名的cookie path：cookie的生效路径，同一域名下又不同路径的cookie，也是无法操作的 expires：cookie的过期时间，如果不设置这个字段的话，就会在浏览器关闭的时候这个cookie就会被删除。expires的值是标准的日期格式，一般使用new Date().toUTCString()的值 HttpOnly：由服务端进行设定，并且用户端无法更改这个cookie，防止XSS恶意修改cookie，HttpOnly并不能绝对防止XSS 删除对应的cookie只有将某条cookie（其他字段一样）的过期时间改成已经过去的时间，即可删除 session机制： session是服务端保存请求信息的机制，记录请求者身份 一般由服务端接到请求后，由服务端生成一个sessionID，然后将这个id写进请求用户端的cookie里，并且设定HttpOnly，这样每次客户端请求的时候，携带sessionID来请求，就能识别用户身份 生成的sessionID并不一定要种在cookie里，也可以放在请求参数里，或者在http的请求头里开辟一个token字段 一般都是在Response的Raw里Set-Cookie可以查看到服务端往客户端写cookie的操作 标准写法： 1document.cookie = &#x27;name=yuuhei;domain=baidu.com;path=/;expires=Mon, 26 Nov 2018 12:11:10 GMT&#x27; 关于使用async&#x2F;await进行请求的使用方法使用了async的函数一般默认返回都是返回一个Promise对象 async&#x2F;await会由于写法的不同产生的请求时机也会不一样，如以下代码： 首先定义一个模拟的请求函数： 12345678910111213141516// 模拟promise请求const promiseRequest = function(success, delay) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (success) &#123; if (typeof success === &#x27;boolean&#x27;) &#123; resolve(&#x27;promise success&#x27;); &#125; else &#123; resolve(success); &#125; &#125; else &#123; reject(&#x27;promise error&#x27;); &#125; &#125;, delay); &#125;);&#125; 接着写执行函数： 12345678910const mainStep = async function() &#123; // 都是同步代码，p3是在6秒后才打印出来 let p1 = await promiseRequest(true, 1000); let p2 = await promiseRequest(true, 2000); let p3 = await promiseRequest(true, 3000); console.log(p3);&#125;mainStep(); 注意以上代码，他们只会p1请求完毕只会，才会再请求p2，p2请求完毕后才会请求p3，这是一个同步的代码，并不是并行的代码，如果需要并行则需要改成以下代码： 1234567891011121314const mainAll = async function() &#123; // 这样写的p1和p2是并行的，首先都进行请求，然后再进行await，所用时间是2s+3s let p1 = promiseRequest(&#x27;p1 await&#x27;, 1000); let p2 = promiseRequest(&#x27;p2 await&#x27;, 2000); // 并行开始，并且两者都完成了才会继续执行p3 let r1 = await p1; let r2 = await p2; let p3 = await promiseRequest(`$&#123;r1&#125; and $&#123;r2&#125;`, 3000); console.log(p3);&#125;mainAll(); 当然也可以使用PromiseAll处理并发，换个方式： 12345678910111213const mainPromiseAll = async function() &#123; let p1 = promiseRequest(&#x27;p1 promiseAll await&#x27;, 1000); let p2 = promiseRequest(&#x27;p2 promiseAll await &#x27;, 2000); let results = await Promise.all([p1, p2]); let [r1, r2] = results; let p3 = await promiseRequest(`$&#123;r1&#125; and $&#123;r2&#125;`, 3000); console.log(p3);&#125;mainPromiseAll(); async&#x2F;await同样可以使用Promise.all进行错误捕获： await的Promise.all的错误捕获之一，统一在Promise.all中的catch捕获 12345678910111213141516const doRequest1 = async () =&gt; &#123; let res = await promiseRequest(false, 1000); return res;&#125;const doRequest2 = async () =&gt; &#123; let res = await promiseRequest(&#x27;await try-catch-2&#x27;, 2000); return res;&#125;// doRequest1报错后接下来的请求都不会再执行，错误提示只提一遍Promise.all([doRequest1(), doRequest2()]).then(res =&gt; &#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(err);&#125;); await的Promise.all的错误捕获之二，分别在里面的Promise都进行try-catch处理，Promise.all里的catch就不会再执行 123456789101112131415161718192021222324const doRequest1 = async () =&gt; &#123; try &#123; let res = await promiseRequest(false, 1000); return res; &#125; catch (err) &#123; console.log(err); &#125;&#125;const doRequest2 = async () =&gt; &#123; try &#123; let res = await promiseRequest(&#x27;await try-catch-2&#x27;, 2000); return res; &#125; catch (err) &#123; console.log(err); &#125;&#125;// doRequest1报错后接下来的请求也会继续执行，有多少个错误就报多少个错，只要里面每个Promise都进行了错误捕获，然后只会执行then，永远不会执行catch，因为已经捕获过了Promise.all([doRequest1(), doRequest2()]).then(res =&gt; &#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(&#x27;do not run here forever&#x27;);&#125;); 不使用Promise.all也可以达到效果的同步代码： 1234567891011121314151617async function doRequest() &#123; let p1 = promiseRequest(true, 1000); let p2 = promiseRequest(true, 2000); let p3 = promiseRequest(true, 3000); try &#123; await p1; await p2; await p3; console.log(&#x27;next&#x27;); &#125; catch (err) &#123; client.alert(err); &#125;&#125;doRequest() 以上代码p1、p2和p3并行完成后才会继续走next后的代码 在请求头使用Token在使用JSON Web Token作为单点登录的验证媒介时，为保证安全性，建议将JWT的信息存放在HTTP的请求头中，并使用https对请求链接进行加密传输 当在进行跨域请求的时候，如自定义请求头，如添加token字段，属于复杂请求，那么HTTP请求会发出一个预检请求，即OPTIONS请求，访问服务器是否允许该请求，如果没有进行设置，服务器会返回403 Forbidden，需要在服务端也要定义好自定义的请求头字段，才能响应响应预检请求，ajax工具可以在beforeSend进行对xhr.setRequestHeader进行设置请求头 数组的indexOf也可以用来判断对象的位置，传入对象引用的内存地址就能够找到12345let obj1 = &#123;a: 1, b: 2&#125;;let obj2 = &#123;a: 3, b: 4&#125;;let arr = [obj1, obj2];arr.indexOf(obj2); // 1 String类型也可以使用slice，用法与Array差不多JS标准快排原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100function quickSort(array) &#123; return quick(array, 0, array.length - 1);&#125;function quick(array, left, right) &#123; let index; if (array.length &gt; 1) &#123; index = partition(array, left, right); if (left &lt; index - 1) &#123; quick(array, left, index - 1); &#125; if (index &lt; right) &#123; quick(array, index, right); &#125; &#125; return array;&#125;// 划分操作函数function partition(array, left, right) &#123; // 用index取中间值而非splice const pivot = array[Math.floor((right + left) / 2)]; let i = left; let j = right; while (i &lt;= j) &#123; while (compare(array[i], pivot) === -1) &#123; i++; &#125; while (compare(array[j], pivot) === 1) &#123; j--; &#125; if (i &lt;= j) &#123; swap(array, i, j); i++; j--; &#125; &#125; return i;&#125;// 比较函数function compare(a, b) &#123; if (a === b) &#123; return 0; &#125; return a &lt; b ? -1 : 1;&#125;// 原地交换函数，而非用临时数组function swap(array, a, b) &#123;; [array[a], array[b]] = [array[b], array[a]];&#125;````阮一峰老师的快排会增加空间复杂度，尽量使用这种教科书式的原理，且v8的sort底层本身就经过优化，比现在大多数排序的优化都好，尽量使用sort。#### 金钱千分符格式化正则```javascriptfunction exchange(num) &#123; num = String(num); if (num.length &lt; 4) &#123; return num; &#125; num = num.replace(/\\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+$)/g, (v) =&gt; &#123; return v + &#x27;,&#x27;; &#125;); return num;&#125;;````#### JS深复制原理实现- 判断类型```javascript/** * 判断数据类型 * @param &#123;All&#125; obj 需要判断的对象 * @return &#123;String&#125; 返回结果字符串 */function typeOf(obj) &#123; const toString = Object.prototype.toString; const map = &#123; &quot;[object Boolean]&quot;: &quot;boolean&quot;, &quot;[object Number]&quot;: &quot;number&quot;, &quot;[object String]&quot;: &quot;string&quot;, &quot;[object Function]&quot;: &quot;function&quot;, &quot;[object Array]&quot;: &quot;array&quot;, &quot;[object Date]&quot;: &quot;date&quot;, &quot;[object RegExp]&quot;: &quot;regExp&quot;, &quot;[object Undefined]&quot;: &quot;undefined&quot;, &quot;[object Null]&quot;: &quot;null&quot;, &quot;[object Object]&quot;: &quot;object&quot; &#125;; return map[toString.call(obj)];&#125; 递归赋值 123456789101112131415161718192021222324252627282930/** * 深复制 * @param &#123;Array/Object&#125; data 需要复制的数据 * @return &#123;Array/Object&#125; 返回新的数据 */function deepCopy(data) &#123; const type = typeOf(data); let ret; // 只有array和object需要递归遍历 if (type === &quot;array&quot;) &#123; ret = []; &#125; else if (type === &quot;object&quot;) &#123; ret = &#123;&#125;; &#125; else &#123; return data; &#125; if (type === &quot;array&quot;) &#123; for (let i = 0; i &lt; data.length; i++) &#123; ret.push(deepCopy(data[i])); &#125; &#125; else if (type === &quot;object&quot;) &#123; for (let key in data) &#123; ret[key] = deepCopy(data[key]); &#125; &#125; return ret;&#125; iOS下调用元素的focus方法，input元素不聚焦问题注意，在iOS有一个兼容问题，就是如果在钩子函数里调用$el.focus()，或异步调用$el.focus()的话，是不成功的。 google有以下解释： iOS将只允许在其他元素上绑定函数来触发focus事件，如果第一个函数调用栈是由非编程触发的事件，调用setTimeout开始一个新的调用堆栈，IOS的安全机制开始阻止你触发input元素的focus事件。在函数里使用异步也是不行的 钩子函数无法触发例子： 12345export default &#123; mounted() &#123; this.$refs.input.focus(); &#125;&#125; 上述代码应该很多人会这么做，需求背景时：点击某个元素，弹框出现，然后自动聚焦在弹框的input上 异步函数无法触发例子： 123456789export default &#123; handleClick() &#123; this.visable = true; // 视图更新后，必须在nextTick回调做事，不然不生效 this.$nextTick(() =&gt; &#123; this.$refs.component.$refs.input.focus(); &#125;) &#125;&#125; 既然钩子函数无法触发，那就使用点击事件，其中visable对应v-show和v-if都是一样的，然后在异步调用focus 以上两个例子在真机上，安卓是可以的，iOS是失效的。 那怎么办，暂时找到的唯一方法：使input元素一直存在于页面中，只是对用户不可见而已（位移移出可视区域），然后调用focus，iOS才能生效 成功例子： 12345678export default &#123; // 必须通过事件触发，click, touchend等 handleClick() &#123; // 将子组件移动到可视区域 // ... this.$refs.component.$refs.input.focus(); &#125;&#125; 在iOS中，所有异步调用setTimeout，Promise，nextTick等，调用focus()均无效 超长String转Number后会有问题注意：Number类型超过16位的数字会变成0，且第16位会加一 在对String进行转换为Number时需要注意长度问题 使用递归格式化用于级联列表的格式从后台返回的树状列表结构，一般是这种形式： 123456789101112131415161718192021222324252627282930313233343536373839404142[ // 从公司开始，所以这个列表只有一个对象，从部门开始才是多个对象 &#123; &quot;id&quot;: &quot;0000&quot;, &quot;name&quot;: &quot;公司名称&quot;, &quot;level&quot;: &quot;0&quot;, &quot;parentId&quot;: &quot;null&quot;, &quot;children&quot;: [ &#123; &quot;id&quot;: &quot;1000&quot;, &quot;name&quot;: &quot;信息技术中心&quot;, &quot;level&quot;: &quot;1&quot;, &quot;parentId&quot;: &quot;1&quot;, &quot;children&quot;: [ &#123; &quot;id&quot;: &quot;10001&quot;, &quot;name&quot;: &quot;系统开发部&quot;, &quot;level&quot;: &quot;1000&quot;, &quot;parentId&quot;: &quot;68610408&quot;, &quot;children&quot;: [ &#123; &quot;id&quot;: &quot;1000101&quot;, &quot;name&quot;: &quot;后端开发组&quot;, &quot;level&quot;: &quot;3&quot;, &quot;parentId&quot;: &quot;10001&quot;, &quot;children&quot;: [] &#125;, &#123; &quot;id&quot;: &quot;1000102&quot;, &quot;name&quot;: &quot;前端开发组&quot;, &quot;level&quot;: &quot;3&quot;, &quot;parentId&quot;: &quot;10001&quot;, &quot;children&quot;: [] &#125; ] &#125; ] &#125;, // ...其他部门 ] &#125;] 而级联组件一般的格式就是如此，但由于后端返回来的字段各种各样，前端也需要进行一个数据的格式化，需要将格式变为以下如此： 123456789101112131415161718192021222324252627282930[ &#123; &quot;value&quot;: &quot;zhinan&quot;, &quot;label&quot;: &quot;指南&quot;, &quot;children&quot;: [ &#123; &quot;value&quot;: &quot;shejiyuanze&quot;, &quot;label&quot;: &quot;设计原则&quot;, &quot;children&quot;: [ &#123; &quot;value&quot;: &quot;yizhi&quot;, &quot;label&quot;: &quot;一致&quot; &#125;, &#123; &quot;value&quot;: &quot;fankui&quot;, &quot;label&quot;: &quot;反馈&quot; &#125;, &#123; &quot;value&quot;: &quot;xiaolv&quot;, &quot;label&quot;: &quot;效率&quot; &#125;, &#123; &quot;value&quot;: &quot;kekong&quot;, &quot;label&quot;: &quot;可控&quot; &#125; ] &#125; ] &#125;] 可以发现，这类数据都有着重复的规律，这种就可以使用递归进行遍历： 12345678910111213141516171819// 递归处理树状结构function formatList(list) &#123; let ret = []; list.forEach((item, index) =&gt; &#123; let obj = &#123;&#125;; obj.label = item.name; obj.value = item.id; for (let key in item) &#123; if (Array.isArray(item[key]) &amp;&amp; item[key].length &gt; 0) &#123; // children与第一层结构一样，可以递归 obj.children = formatList(item[key]); &#125; &#125; ret.push(obj); &#125;); return ret;&#125; 关于document.write的问题document.write写入的内容是叠加的，不是覆盖写入，可以做一些如下操作： 1document.write(&#x27;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/reset.css&quot;&gt;&#x27;) 可以动态加载注入外部的css文件 前端生成的base64图片或文件如何下载前端下载的原理是通过在a标签上定义href和download属性，download在同源里可以设置下载的文件名，然后通过自定义时间触发a标签的点击，就可以进行下载了： 1234567891011// data可以为base64，或后端的文件地址function saveFile(data, filename = &#x27;&#x27;) &#123; let save_link = document.createElement(&#x27;a&#x27;); save_link.href = data; save_link.download = filename; // 同域下才能指定download，否则又后端控制 // 自定义派发时间，相当于点击a标签 let event = document.createEvent(&#x27;MouseEvents&#x27;); event.initMouseEvent(&#x27;click&#x27;, true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null); save_link.dispatchEvent(event);&#125; 前端生成pdf并下载可以通过html2canvas和jsPDF配合生成下载，具体教程可以网上搜","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"}]},{"title":"JS工作经验总结（1）","date":"2018-06-20T14:47:49.000Z","path":"2018/06/20/JS工作经验总结（1）/","text":"本文主要记录工作时JS问题或经验 html里自定义属性的赋值和取出问题给html元素写入data-type这样的格式，可以使用el.dataset.type进行相对应的访问；\\在不兼容dataset的情况下，可以使用更原始的el.getAttribute(name)进行取值，使用el.setAttribute(name, value)进行赋值 document.activeElement的应用（焦点问题）document.activeElement.tagName可获得当前获得焦点的元素，document.activeElement.blur()使当前获得焦点的元素失焦 关闭webApp中的调起的系统键盘window.nativeKeyboradCancel()，在webApp里取消调起系统的键盘，如果有的话 循环遍历父元素的方法以下可以使用while一直遍历父元素： 123456789function getTagName(ele) &#123; var parent = ele.parentElement; var string = &#x27;&#x27;; while (parent !== null) &#123; string += parent.tagName + &#x27; &#x27;; parent = parent.parentElement； &#125; return string;&#125; CSS伪元素问题:empty 选择器匹配没有子元素（包括文本节点）的每个元素\\配合before和after伪元素，可以使用content: attr(placeholder)，将HTML里placeholder的属性写进伪元素里，属性随你定 window.pageYOffset和window.scrollYwindow.pageYOffset是window.scrollY的别名，都是同一种功能 input元素里的属性问题input框的maxlength属性可以限制输入长度，但只有当type为text的时候才可以控制，当type为number等其他时长度不受控制时，还是需要js来控制长度。如&lt;input type=&quot;number&quot; oninput=&quot;if(value.length&gt;5)value=value.slice(0,5)&quot; /&gt;，password类型可以限制长度 注意, type为number时监听oninput不能实时监听小数点，需要输入小数点后面的数后，才能获取到小数点的输入，需要将type改成text onchange和oninput的不同有别于onchange事件，oninput 事件在元素值发生变化是立即触发， onchange 在元素失去焦点时触发。另外一点不同是 onchange 事件也可以作用于 &lt;keygen&gt; 和 &lt;select&gt; 元素 12345&lt;select name=&quot;type&quot; onchange=&quot;show_sub(this.options[this.options.selectedIndex].value)&quot;&gt; &lt;option value=&quot;0&quot;&gt;请选择主类别&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;&lt;/select&gt; string.charCodeAt和string.charAt的不同string.charCodeAt(index) 方法可返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。方法 string.charCodeAt() 与 string.charAt() 方法执行的操作相似，只不过前者返回的是位于指定位置的字符的编码，而后者返回的是字符子串。charCodeAt可以使用该方法配合A-Z进行升降序排序等 better-scroll使用问题（监听滚动）需要根据文档定义传入probeType=&quot;3，用于better-scroll监听swip等操作的scrollY，需要传入这个再选择:listen-scroll，即better-scroll的this.scroll.on(&#39;scroll&#39;, (pos) =&gt; &#123;&#125;)进行监听返回的scrollY async和await的使用方法async和await，await必定是写在async函数里： 123456789async function testSync() &#123; const response = await new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&quot;async await test...&quot;); &#125;, 1000); &#125;); console.log(response);&#125;testSync(); // async await test... 声明式版： const testSync = async() =&gt; &#123;&#125;; Promise.all使用方法及注意事项Promise.all是在会处理完then中的函数后（如果有执行后续then），再统一执行的，如果有返回数据则推进Promise.all的then中的res数组中，且返回顺序是确定的，传入all前的数组的顺序与后续返回的res的数组顺序是一致的；没有返回则里面推进undefined： 12345678910111213141516171819202122232425262728function Promise1() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;success&#x27;); &#125;, 3000); &#125;);&#125;function Promise2() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;success 2&#x27;); &#125;, 5000); &#125;);&#125;var p1 = Promise1var p2 = Promise2var a = p1().then(res =&gt; &#123; return res &#125;)var b = p2().then(res =&gt; &#123; return res &#125;)Promise.all([a, b]).then(res =&gt; &#123; // 5秒之后打印 [&quot;success&quot;, &quot;success 2&quot;] console.log(res);&#125;); 没有后续then版，直接resolve： 123456789101112131415161718var a = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;aaa&#x27;); &#125;, 3000);&#125;);var b = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;bbb&#x27;); &#125;, 1000);&#125;);var p = Promise.all([a, b]);p.then((res) =&gt; &#123; // 3秒后返回结果：[&#x27;aaa&#x27;,&#x27;bbb&#x27;]，数组的内容并不是谁先执行完谁在前面，而是按照之前传入的顺序 console.log(res);&#125;); 注意，如果进行Promise.all的Promise里进行了catch的处理，当一个Promise报错后，会优先处理具体Promise的catch，然后依然会走Promise.all的then，而不会走Promise.all的catch 字符串减法运算问题数字的字符串版，他们之间是可以进行减法运算的，因为减号是作为数值运算，没有二义性(不像+号)，所以 解释器就将”123”和”1”通过 new Number() 转换成了 数值类型，在进行运算。 12var foo = &quot;123&quot; - &quot;1&quot;;console.log(foo); // 结果是122 ~~和|运算符的用法与巧用js中的~~其实是一种利用符号进行的类型转换，转换成数字类型；除此之外还可以进行数字的向下取整。向下取整还有一种方法是进行或0操作 12345678910111213~~true == 1~~false == 0~~&quot;&quot; == 0~~&quot;123&quot; == 123~~undefined ==0~~!undefined == 1~~null == 0~~!null == 1~~1.9 == 1~~1.1 == 11.9 | 0 == 11.1 | 0 == 1 使用正则判断是否存在特殊符号1234containSpecial (s) &#123; let containSpecials = RegExp(/^[A-Za-z0-9\\u4e00-\\u9fa5]+$/); return (!containSpecials.test(s));&#125; Object.assign是可以覆盖更改第一个引用对象的Promise处理异常的情况处理异常分2种： then里的第二个参数，就近捕获的原则（reject）， catch全局异常，所有流程异常都捕获，例如reject一个Error，但如果then的第二个参数没有写，reject就会在catch中被捕获，否则不处理 12345var someAsyncThing = function() &#123; return new Promise((resolve, reject) =&gt; &#123; reject(&#123;a: 1, b: 2&#125;) &#125;);&#125;; 123456// 由于then里没有写处理rejecte的函数，所以会在catch中处理someAsyncThing().then(function() &#123; console.log(&#x27;everything is great&#x27;);&#125;).catch(err =&gt; &#123; alert(err.a) // 1&#125;); Date.parse()的使用Date.parse()可以将特点格式的日期字符串转为输出从 1970&#x2F;01&#x2F;01 到一个具体日期的毫秒数： 123// 可处理格式，不带时分秒也可以var d = Date.parse(&quot;2017/03/19 11:12:30&quot;)var d = Date.parse(&quot;2017.03.19 11:12:30&quot;) Date还有类似于getMonth()和setMonth()的方法，进行特定的时间设定 git处理无法推送或pull下来很多冲突的方法git branch -D xxx （删除本地分支）git checkout xxx （重新拉取远程分支） git取回所有分支的更新并新建分支git fetchgit branch -b xxx(本地) xxx(远端) 关于canvas的几条基础知识 canvas画布的大小，需要用height和width直接设置元素，或setAttribute，使用css的width和height相当于将画布放大和缩小，也可以利用这个原理使在手机上的canvas更清晰，一般是css的属性是canvas画布大小的一半，然后canvas的画布大小也要根据屏幕的clientWidth进行适应 canvas的画布坐标是从左上角开始算起0、0，之后递增坐标数 canvas虚线绘制完后，使用ctx.setLineDash([])，传入空数组，可以切换回实线绘制 ctx.globalCompositeOperation可以设置交替元素的显示方式","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"}]},{"title":"Vue工作经验总结（1）","date":"2018-03-19T15:51:53.000Z","path":"2018/03/19/Vue工作经验总结（1）/","text":"本文主要记录工作时使用Vue时的问题或经验 关于使用v-model传值给组件的语法糖template: 1234&lt;currency-input v-model=&quot;price&quot;&gt;&lt;/currentcy-input&gt;&lt;!-- 上行代码是下行的语法糖 &lt;currency-input :value=&quot;price&quot; @input=&quot;changeInput&quot;&gt;&lt;/currency-input&gt;--&gt; 123456789101112131415161718192021Vue.component(&#x27;currency-input&#x27;, &#123; // 这里emit给父组件的input事件是由于v-model的语法糖所创立的 template: ` &lt;span&gt; &lt;input ref=&quot;input&quot; :value=&quot;value&quot; @input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;&gt; &lt;/span&gt; `, props: [&#x27;value&#x27;], // v-model后在组件里使用props的value来相应&#125;)var demo = new Vue(&#123; el: &#x27;#demo&#x27;, data: &#123; price: 100, &#125; /*methods: &#123; changeInput(val) &#123; this.price = val &#125; &#125;*/&#125;) 这样使用v-model就可以不用像注释里一样，在组件emit一个自定义事件，在外面接住，这样写在里面修改，外面就能接收到传过来的value，并且将其改写，响应data 事件修饰符.native的使用场景关于加了native和不加的区别，使用以下代码说明： 定义自定义组件vButton： 1&lt;button type=&quot;button&quot; @click=&quot;clickHandler&quot;&gt;&lt;/button&gt; 12345678export default &#123; name: &#x27;vButton&#x27;, methods: &#123; clickHandler () &#123; this.$emit(&#x27;vclick&#x27;) // 触发 `vclick` 事件 &#125; &#125;&#125; 引用自定义组件vButton时事件的触发情况： 1&lt;v-button @click=&quot;clickHandler&quot; @vclick=&quot;vClickHandler&quot;&gt;按钮&lt;/v-button&gt; 123456789101112import vButton from &#x27;@/components/Button&#x27;export default &#123; components: &#123; vButton &#125;, methods: &#123; clickHandler () &#123; alert(&#x27;onclick&#x27;) // 此处不会执行 因为组件中未定义 `click` 事件 &#125;, vClickHandler () &#123; alert(&#x27;onvclick&#x27;) // 触发 `vclick` 自定义事件 &#125; &#125;&#125; 如果将上面模版改成： 1&lt;v-button @click.native=&quot;clickHandler&quot; @vclick=&quot;vClickHandler&quot;&gt;按钮&lt;/v-button&gt; 那么两个事件都会执行，.native 修饰符就是用来注册元素的原生事件而不是组件自定义事件的 意思就是当你给一个vue组件绑定事件时候，要加上.native，如果是普通的html元素就不需要。 使用v-if、v-else-if、v-else处理显示注意v-else-if和v-else前一兄弟元素必须有 v-if 或 v-else-if，v-else。链式调用可以更好的处理template显示逻辑 class条件判断绑定问题:class=&#123; active: isActive &#125;的时候左边可以不加引号，也可以加上active这个class，右边是props或data或computed的数据 在template使用引用静态文件（img等）vue，webpack中，template中可以使用~+alias配置名称，js里可以使用import和require引用静态图片地址 父子组件和非父子组件的传值问题父子组件：使用@和$emit传值;\\非父子组件：eventBus或vuex。 filter使用技巧filter可以的到第二，第三，以此类推个参数，在使用filter的时候使用filterA(arg1, agr2, …)传入，第一个参数就是值本身 vux如何通过v-model显示组件的问题vux是通过v-model传入value作为props，然后value用v-if控制组件的显示与否 对象watch问题有三种方法，推荐第二、三种方法，可以拿到oldValue，直接检测对象是拿不到oldValue的： 1234567data() &#123; return &#123; obj: &#123; num: 0 &#125; &#125;&#125; 第一种： 12345678910watch: &#123; /* 监听某个对象属性的写法，必须使用handler和deep */ numObj: &#123; handler(nval, oval) &#123; /* 注意：在变异 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。 */ console.log(nval.num === oval.num); // true &#125;, deep: true &#125;&#125; 第二种： 12345678910111213computed: &#123; // 利用computed返回对象中的一个属性，改变改对象下的属性就能在watch里监听 computedNum() &#123; return this.numObj.num &#125;&#125;watch: &#123; /* 这样监听对象里的属性就可以拿到newValue和oldValue */ computedNum(nval, oval) &#123; console.log(nval, oval); &#125;&#125; 第三种（和第二种一样效果）： 123456watch: &#123; /* 效果与使用computed做中间层一样，有newValue和oldValue */ &#x27;numObj.num&#x27;: function(nval, oval) &#123; console.log(nval, oval) &#125;&#125; 通过data检测数组的注意事项由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] &#x3D; newValue 当你修改数组的长度时，例如：vm.items.length &#x3D; newLength 举个例子： 1234567var vm = new Vue(&#123; data: &#123; items: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] &#125;&#125;)vm.items[1] = &#x27;x&#x27; // 不是响应性的vm.items.length = 2 // 不是响应性的 为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新： 1234// Vue.setVue.set(vm.items, indexOfItem, newValue)// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue) 你也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名（Vue文件里vm代表this）： vm.$set(vm.items, indexOfItem, newValue) 为了解决第二类问题，你可以使用 splice： vm.items.splice(newLength) 通过data检测对象的注意事项还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除： 123456789var vm = new Vue(&#123; data: &#123; a: 1 &#125;&#125;)// `vm.a` 现在是响应式的vm.b = 2// `vm.b` 不是响应式的 对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性。例如，对于： 1234567var vm = new Vue(&#123; data: &#123; userProfile: &#123; name: &#x27;Anika&#x27; &#125; &#125;&#125;) 你可以添加一个新的 age 属性到嵌套的 userProfile 对象： Vue.set(vm.userProfile, &#39;age&#39;, 27) 你还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名： vm.$set(vm.userProfile, &#39;age&#39;, 27) 有时你可能需要为已有对象赋予多个新属性，比如使用 Object.assign() 或 _.extend()。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样： 1234Object.assign(vm.userProfile, &#123; age: 27, favoriteColor: &#x27;Vue Green&#x27;&#125;) 你应该这样做： 1234vm.userProfile = Object.assign(&#123;&#125;, vm.userProfile, &#123; age: 27, favoriteColor: &#x27;Vue Green&#x27;&#125;) template里关于data的渲染和methods的传值1、template中可以使用this，或值直接不用都可以： &#123;&#123;account_No&#125;&#125; 和 &#123;&#123;this.account_No&#125;&#125; 都能够访问到data或computed 2、在传入方法的时候，如果不传参，methods里默认有一个event对象；如果有传参，在template里通过test(&#39;233&#39;, $event)，在methods中接收第二个参数，就可以用到event了 父元素使用v-model语法糖检测子元素传过来的值使用v-model语法糖对封装好的input传值时（例如vux的x-input），或者是使用父子双向绑定的时候（$emit），如果要在父元素里使用watch检测值并且修改，需要在修改的最后一般使用$nextTick或者延时修改，不然会不生效： 子组件修改父组件传过来的值： 1234567891011121314151617&lt;template&gt; &lt;div class=&quot;x-input&quot;&gt; &lt;input :value=&quot;value&quot; @input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;xInput&#x27;, props: &#123; value: &#123; type: String, default: 0 &#125; &#125;&#125;&lt;/script&gt; 父元素检测值并进行二次赋值： 12345678910111213141516171819202122232425262728293031&lt;template&gt; ... &lt;x-input v-model=&quot;test&quot;&gt;&lt;/x-input&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; test: &#x27;123&#x27; &#125; &#125;, watch: &#123; /* 双向绑定过滤非数字判断 */ test(nval, oval) &#123; let num = +nval; let type = Object.prototype.toString.call(num); if(!isNaN(num) &amp;&amp; type === &#x27;[object Number]&#x27;) &#123; // 必须 this.$nextTick(() =&gt; &#123; this.test = nval &#125;) &#125; else &#123; this.$nextTick(() =&gt; &#123; this.test = oval &#125;) &#125; &#125; &#125;&#125;&lt;/script&gt; 以上步骤就可以对v-model传入的值进行过滤判断 .capture事件修饰符的用法给元素添加一个监听器，当该元素发生冒泡时，先触发带有该修饰符的元素，若有多个修饰符，则由外而内触发，就是谁有该事件修饰符，就先触发谁 使用事件event对象和传参时的使用123@click=&quot;test(&#x27;123&#x27;, $event)&quot; -&gt; test(str, event) &#123;event.stopPropagation()&#125;@click=&quot;test&quot; -&gt; test(event) &#123;event.stopPropagation()&#125; vue在iOS9下，for..in遍历data里的数组会执行两遍子组件的emit事件，父组件在调用时可以额外传入参数可以分两种方式，一种是子组件只emit一个参数；另一种是emit多个参数。 子组件只emit一个参数 子组件： 1this.$emit(&#x27;on-change&#x27;, value); 父组件： 1&lt;component-a @on-change=&quot;handleChange($event, anotherVal)&quot;&gt;&lt;component-a&gt; 123456methods: &#123; handleChange(val, anotherVal) &#123; // val是子组件传过来的数值 // anotherVal是父组件额外传入的数值 &#125;&#125; 子组件emit了多个参数 子组件： 1this.$emit(&#x27;on-change&#x27;, value1, value2, value3); 父组件： 1&lt;component-a @on-change=&quot;handleChange(anotherVal, arguments)&quot;&gt;&lt;component-a&gt; 1234567methods: &#123; handleChange(anotherVal, [value1, value2, value3]) &#123; // anotherVal是父组件额外传入的数值 // [value1, value2, value3]就是子组件传过来参数的解构赋值 // 注意父组件写的时候必须写入arguments &#125;&#125; 参考issue：https://github.com/vuejs/vue/issues/5735 1@change=&quot;(val) =&gt; &#123; onDateChange(item, val); &#125;&quot; 组件的props可以定义多个type12345props: &#123; value: &#123; type: [Boolean, String, Number] &#125;&#125; 可以使用this.$parent、this.$children访问父组件、子组件的实例可以使用this.$parent.$options访问实例的自定义属性，例如name等","tags":[{"name":"Vue","slug":"Vue","permalink":"https://sellenite.github.io/tags/Vue/"}]},{"title":"关于table-cell实现的各种布局","date":"2018-03-02T12:43:06.000Z","path":"2018/03/02/关于table-cell实现的各种布局/","text":"display:table-cell指让标签元素以表格单元格的形式呈现，使元素类似于td标签。IE8+及现代版本的浏览器都支持此属性，IE6&#x2F;7不支持（可用其他方法实现类似效果）。同样，display：table-cell属性也会被float，position：absolute等属性破坏效果，应避免同时使用。 设置了display：table-cell的元素： 对宽度高度敏感 对margin值无反应 响应padding属性 内容溢出时会自动撑开父元素 display：table-cell的几种用法 1.大小不固定元素的垂直居中1234567&lt;div class=&quot;content&quot;&gt; &lt;div style=&quot;padding: 50px 40px;background: #cccccc;color: #fff;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;padding: 60px 40px;background: #639146;color: #fff;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;padding: 70px 40px;background: #2B82EE;color: #fff;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;padding: 80px 40px;background: #F57900;color: #fff;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;padding: 90px 40px;background: #BC1D49;color: #fff;&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910.content &#123; display: table-cell; padding: 10px; border: 2px solid #999;&#125;.content div &#123; display: inline-block; vertical-align: middle;&#125; 补充一种多行文本垂直居中的方法： 1234&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;left&quot;&gt;这边很少&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;这边很多字···&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819.wrap &#123; display: table; margin: 0 auto; height: 300px; width: 300px; border: 2px solid #0cf;&#125;.left &#123; display: table-cell; vertical-align: middle; width: 100px;&#125;.right &#123; display: table-cell; vertical-align: middle; width: 200px;&#125; 2.两列自适应布局123456&lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;left-box&quot;&gt; &lt;img src=&quot;img/a1.jpg&quot; width=&quot;70&quot;&gt; &lt;/div&gt; &lt;div class=&quot;right-box&quot;&gt;...&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718.content &#123; display: table; padding: 10px; border: 2px solid #999;&#125;.left-box &#123; float: left; margin-right: 10px;&#125;.right-box &#123; display: table-cell; padding: 10px; width: 3000px; vertical-align: top; border: 1px solid #ccc;&#125; 左边头像部分使用了float左浮动属性，左侧使用 display: table-cell则实现了两列自适应布局。至于.right-box中的width：3000px解释引用别人的： display:table-cell 元素生成的匿名table默认table-layout:auto。宽度将基于单元格内容自动调整。当内容足够多将宽度完全撑开时，再让某个元素（例如关闭按钮）右侧定位就会有问题。所以设置width:3000px的用途是尽可能的宽的意思。 对于IE6&#x2F;7，我们可以使用display： inline-block属性代替。 3.等高布局1234&lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;box1&quot;&gt;我和右边等高&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;table表格中的单元格最大的特点之一就是同一行列表元素都等高。所以，很多时候，我们需要等高布局的时候，就可以借助display:table-cell属性。说到table-cell的布局，不得不说一下“匿名表格元素创建规则”&lt;/div&gt;&lt;/div&gt; 12345678910111213141516.content &#123; display: table; padding: 10px; border: 2px solid #999;&#125;.box1 &#123; display: table-cell; width: 100px; border: 1px solid #ccc;&#125;.box2 &#123; display: table-cell; border: 1px solid #ccc;&#125; 4.和inline-block组合使用12345678&lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;div class=&quot;box&quot;&gt;A&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;div class=&quot;box&quot;&gt;B&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324.content &#123; display: table; padding: 10px; margin: 10px auto; width: 1000px; border: 2px solid #999;&#125; .left &#123; display: table-cell; text-align: left; border: 1px solid #0cf;&#125;.right &#123; display: table-cell; text-align: right; border: 1px solid #fc0;&#125;.box &#123; display: inline-block; width: 100px; height: 100px; border: 1px solid #ccc;&#125; 代码解释：A和B的父元素均设置了display：table-cell属性，所以它们均匀占据设置了display：table的div元素。而A和B元素设置display：inline-block是为了让它们相应text-align的属性设置。 inline-block 是宽高margin设定有效，参与行内格式化上下文，在行内对齐时使用它自己的框底边为基线对齐位置 5.列表布局123456789&lt;div class=&quot;content&quot;&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 12345678910111213141516171819.content &#123; padding: 10px; margin: 10px auto; border: 2px solid #999;&#125;.content ul &#123; display: table; width: 100%; padding: 0;&#125;.content ul li &#123; display: table-cell; height: 100px; line-height: 100px; text-align: center; border: 1px solid #ccc;&#125; 这类布局常用浮动布局（给每个li加上float：left属性）实现，但这样做有明显不足： 需要清除浮动 不支持不定高列表的浮动 display：table-cell可以代替浮动布局，但是其不是最好的方法。其他方法有待进一步学习！ 最后，说说“匿名表格元素创建规则”： CSS2.1表格模型中的元素，可能不会全部包含在除HTML之外的文档语言中。这时，那些“丢失”的元素会被模拟出来，从而使得表格模型能够正常工作。所有的表格元素将会自动在自身周围生成所需的匿名table对象，使其符合table&#x2F;inline-table、table-row、table- cell的三层嵌套关系。 简单来讲，我们为一个元素设置了display：table-cell属性，而不将其父元素设置为display：table-row属性，浏览器会默认创建一个表格行。","tags":[{"name":"CSS","slug":"CSS","permalink":"https://sellenite.github.io/tags/CSS/"}]},{"title":"关于浏览器重排和重绘和一个重绘案例","date":"2018-01-24T11:27:50.000Z","path":"2018/01/24/关于浏览器重排和重绘和一个重绘案例/","text":"什么是重排和重绘浏览器下载完页面中的所有组件——HTML标记、JavaScript、CSS、图片之后会解析生成两个内部数据结构——DOM树和渲染树。 DOM树表示页面结构，渲染树表示DOM节点如何显示。DOM树中的每一个需要显示的节点在渲染树种至少存在一个对应的节点（隐藏的DOM元素disply值为none 在渲染树中没有对应的节点）。渲染树中的节点被称为“帧”或“盒”,符合CSS模型的定义，理解页面元素为一个具有填充，边距，边框和位置的盒子。一旦DOM和渲染树构建完成，浏览器就开始显示（绘制）页面元素。 当DOM的变化影响了元素的几何属性（宽或高），浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。__这个过程称为重排__。完成重排后，浏览器会重新绘制受影响的部分到屏幕，__该过程称为重绘__。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。 并不是所有的DOM变化都会影响几何属性，比如改变一个元素的背景色并不会影响元素的宽和高，这种情况下只会发生重绘。 重排和重绘的代价究竟多大1234567891011121314151617181920212223242526272829303132var times = 15000;// code1 每次过桥+重排+重绘console.time(1);for(var i = 0; i &lt; times; i++) &#123; document.getElementById(&#x27;myDiv1&#x27;).innerHTML += &#x27;a&#x27;;&#125;console.timeEnd(1);// code2 只过桥console.time(2);var str = &#x27;&#x27;;for(var i = 0; i &lt; times; i++) &#123; var tmp = document.getElementById(&#x27;myDiv2&#x27;).innerHTML; str += &#x27;a&#x27;;&#125;document.getElementById(&#x27;myDiv2&#x27;).innerHTML = str;console.timeEnd(2);// code3console.time(3);var _str = &#x27;&#x27;;for(var i = 0; i &lt; times; i++) &#123; _str += &#x27;a&#x27;;&#125;document.getElementById(&#x27;myDiv3&#x27;).innerHTML = _str;console.timeEnd(3);// 1: 2874.619ms// 2: 11.154ms// 3: 1.282ms 重排何时发生很显然，每次重排，必然会导致重绘，那么，重排会在哪些情况下发生： 添加或者删除可见的DOM元素 元素位置改变 元素尺寸改变 元素内容改变（例如：一个文本被另一个不同尺寸的图片替代） 页面渲染初始化（这个无法避免） 浏览器窗口尺寸改变 这些都是显而易见的，或许你已经有过这样的体会，不间断地改变浏览器窗口大小，导致UI反应迟钝（某些低版本IE下甚至直接挂掉），现在你可能恍然大悟，没错，正是一次次的重排重绘导致的！ 渲染树变化的排队和刷新思考下面代码： 1234var ele = document.getElementById(&#x27;myDiv&#x27;);ele.style.borderLeft = &#x27;1px&#x27;;ele.style.borderRight = &#x27;2px&#x27;;ele.style.padding = &#x27;5px&#x27;; 乍一想，元素的样式改变了三次，每次改变都会引起重排和重绘，所以总共有三次重排重绘过程，但是浏览器并不会这么笨，它会把三次修改“保存”起来（大多数浏览器通过队列化修改并批量执行来优化重排过程），一次完成！但是，有些时候你可能会（经常是不知不觉）强制刷新队列并要求计划任务立即执行。获取布局信息的操作会导致队列刷新，比如： offsetTop, offsetLeft, offsetWidth, offsetHeight scrollTop, scrollLeft, scrollWidth, scrollHeight clientTop, clientLeft, clientWidth, clientHeight getComputedStyle() (currentStyle in IE) 将上面的代码稍加修改： 1234567var ele = document.getElementById(&#x27;myDiv&#x27;);ele.style.borderLeft = &#x27;1px&#x27;;ele.style.borderRight = &#x27;2px&#x27;;// here use offsetHeight// ...ele.style.padding = &#x27;5px&#x27;; 因为offsetHeight属性需要返回最新的布局信息，因此浏览器不得不执行渲染队列中的“待处理变化”并触发重排以返回正确的值（即使队列中改变的样式属性和想要获取的属性值并没有什么关系），所以上面的代码，前两次的操作会缓存在渲染队列中待处理，但是一旦offsetHeight属性被请求了，队列就会立即执行，所以总共有两次重排与重绘。所以 尽量不要在布局信息改变时做查询 。 最小化重排和重绘 我们还是看上面的这段代码： 1234var ele = document.getElementById(&#x27;myDiv&#x27;);ele.style.borderLeft = &#x27;1px&#x27;;ele.style.borderRight = &#x27;2px&#x27;;ele.style.padding = &#x27;5px&#x27;; 三个样式属性被改变，每一个都会影响元素的几何结构，虽然大部分现代浏览器都做了优化，只会引起一次重排，但是像上文一样，如果一个及时的属性被请求，那么就会强制刷新队列，而且这段代码四次访问DOM，一个很显然的优化策略就是把它们的操作合成一次，这样只会修改DOM一次： 12345678910var ele = document.getElementById(&#x27;myDiv&#x27;);// 1. 重写styleele.style.cssText = &#x27;border-left: 1px; border-right: 2px; padding: 5px;&#x27;;// 2. add styleele.style.cssText += &#x27;border-;eft: 1px;&#x27;// 3. use classele.className = &#x27;active&#x27;; fragment元素的应用看如下代码，考虑一个问题： 1234&lt;ul id=&#x27;fruit&#x27;&gt; &lt;li&gt; apple &lt;/li&gt; &lt;li&gt; orange &lt;/li&gt;&lt;/ul&gt; 如果代码中要添加内容为peach、watermelon两个选项，你会怎么做？ 12345678var lis = document.getElementById(&#x27;fruit&#x27;);var li = document.createElement(&#x27;li&#x27;);li.innerHTML = &#x27;apple&#x27;;lis.appendChild(li);var li = document.createElement(&#x27;li&#x27;);li.innerHTML = &#x27;watermelon&#x27;;lis.appendChild(li); 很容易想到如上代码，但是很显然，重排了两次，怎么破？前面我们说了，隐藏的元素不在渲染树中，太棒了，我们可以先把id为fruit的ul元素隐藏（display&#x3D;none)，然后添加li元素，最后再显示，但是实际操作中可能会出现闪动，原因这也很容易理解。这时，fragment元素就有了用武之地了。 1234567891011var fragment = document.createDocumentFragment();var li = document.createElement(&#x27;li&#x27;);li.innerHTML = &#x27;apple&#x27;;fragment.appendChild(li);var li = document.createElement(&#x27;li&#x27;);li.innerHTML = &#x27;watermelon&#x27;;fragment.appendChild(li);document.getElementById(&#x27;fruit&#x27;).appendChild(fragment); 文档片段是个轻量级的document对象，它的设计初衷就是为了完成这类任务——更新和移动节点。文档片段的一个便利的语法特性是当你附加一个片断到节点时，实际上被添加的是该片断的子节点，而不是片断本身。只触发了一次重排，而且只访问了一次实时的DOM。 让元素脱离动画流用展开&#x2F;折叠的方式来显示和隐藏部分页面是一种常见的交互模式。它通常包括展开区域的几何动画，并将页面其他部分推向下方。 一般来说，重排只影响渲染树中的一小部分，但也可能影响很大的部分，甚至整个渲染树。浏览器所需要重排的次数越少，应用程序的响应速度就越快。因此当页面顶部的一个动画推移页面整个余下的部分时，会导致一次代价昂贵的大规模重排，让用户感到页面一顿一顿的。渲染树中需要重新计算的节点越多，情况就会越糟。 使用以下步骤可以避免页面中的大部分重排： 使用 绝对位置 定位页面上的动画元素，将其脱离文档流让元素动起来。当它扩大时，会临时覆盖部分页面。但这只是页面一个小区域的重绘过程，不会产生重排并重绘页面的大部分内容。当动画结束时恢复定位，从而只会下移一次文档的其他元素 总结重排和重绘是DOM编程中耗能的主要原因之一，平时涉及DOM编程时可以参考以下几点： 尽量不要在布局信息改变时做查询（会导致渲染队列强制刷新） 同一个DOM的多个属性改变可以写在一起（减少DOM访问，同时把强制渲染队列刷新的风险降为0） 如果要批量添加DOM，可以先让元素脱离文档流，操作完后再带入文档流，这样只会触发一次重排（fragment元素的应用） 将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。 需要重绘的案例display:none和opacity利用纯css实现渐入渐出是会冲突的，给元素设置display:block之后，会引发重排,而transition过度动画存在于重绘中,可通过元素的尺寸查询，强制刷新浏览器的重排和重绘，即可解决transition失效的问题 12345678.layer &#123; transition: opacity 0.3s; display: none;&#125;.layer.active &#123; opacity: 1;&#125; 12345678910111213141516171819/* 渐入效果使用强制重绘 */document.addEventListener(&#x27;click&#x27;, function () &#123; // 引发重排效果 layer.style.display = &#x27;block&#x27;; // 强制刷新浏览器的重排和重绘 layer.offsetHeight; // 强制刷新浏览器的重排和重绘后就可以触发transition了 // 或者可以使用延迟20ms layer.className = &#x27;layer active&#x27;;&#125;);/* 渐出效果使用延时 */layer.addEventListener(&#x27;click&#x27;, function (e) &#123; e.stopPropagation(); layer.className = &#x27;layer&#x27;; setTimeout(function () &#123; layer.style.display = &#x27;none&#x27;; &#125;, 300);&#125;)","tags":[{"name":"CSS","slug":"CSS","permalink":"https://sellenite.github.io/tags/CSS/"}]},{"title":"关于ES6的几个新的关于[[Prototype]]的几个API","date":"2018-01-15T13:19:09.000Z","path":"2018/01/15/关于ES6的几个新的关于-Prototype-的几个API/","text":"Object.create()应用123456789101112/* Object.create(obj)会将[[prototype]]关联到指定对象，组合继承就由于这个原理 *//* 面向委托模式来源于Object.create()这个特性 */let obj = &#123; a: 123, cool: function()&#123; console.log(&#x27;cool!&#x27;) &#125;&#125;let obj2 = Object.create(obj);console.log(obj2.a) // 123console.log(obj2.cool()) // &#x27;cool!&#x27; proto 和 Object.getPrototypeOf() 应用12345678910111213141516171819/* 组合继承 */let Foo = function(name) &#123; this.name = name;&#125;;let Bar = function(name, age) &#123; /* 绑定父亲的构造属性 */ Foo.call(this, name); this.age = age;&#125;;/* 将Bar的[[prototype]]关联到Foo的，继承Foo的原型链属性 */Bar.prototype = Object.create(Foo.prototype);/* ES6直接获取一个对象的[[prototype]]的方式 */console.log(Object.getPrototypeOf(bar) === Bar.prototype);/* 绝大多数浏览器（非标准获取方式）支持 */console.log(bar.__proto__ === Bar.prototype); instanceof 应用123456789101112131415161718function Foo() &#123;&#125;function Bar() &#123; Foo.call(...)&#125;Bar.prototype = Object.create(Foo.prototype)let bar = new Bar()/* 构造函数之间Foo和Bar的instanceof */Bar.prototype instanceof Foo; // true/* 继承可以通过instanceof找到源头 */console.log(bar instanceof Foo); // true/* 注意以下instancof用法是错的，不要混淆了 */Bar instanceof Foo // false instanceof一般用于确定一个值是哪种引用类型，是否存在于参数 object 的原型链上。而不是用于判断对象的构造函数，判断构造函数还是需要使用constructor，实例对象.constructor &#x3D;&#x3D;&#x3D; 构造函数名字来判断 array，function对象instanceof Object会返回true，因为他们的引用都来自Object .prototype.isPrototypeOf() 应用12345678910111213141516171819202122232425262728/* 内省 */let Foo = function(name) &#123; this.name = name;&#125;;let Bar = function(name, age) &#123; Foo.call(this, name); this.age = age;&#125;;Bar.prototype = Object.create(Foo.prototype);let bar = new Bar(&#x27;yuuhei&#x27;, 23);// 首先要纠正错误，Bar instanceof Foo是错的/* 构造函数之间Foo和Bar的内省 */Bar.prototype instanceof Foo; // trueObject.getPrototypeOf(Bar.prototype) === Foo.prototype; // trueFoo.prototype.isPrototypeOf(Bar.prototype); // true/* 实例和构造函数之间的内省 */bar instanceof Bar; // truebar instanceof Foo; // trueObject.getPrototypeOf(bar) === Bar.prototype; /// trueFoo.prototype.isPrototypeOf(bar); // trueBar.prototype.isPrototypeOf(bar); // true Object.setPrototypeOf()继承应用12345678910/* ES6拥有Object.setPrototypeOf进行原型链继承 */let Foo = function() &#123;&#125;;Foo.prototype.a = 1;let Bar = function() &#123;&#125;;Object.setPrototypeOf(Bar.prototype, Foo.prototype);let bar = new Bar();console.log(bar.a); // 1","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"}]},{"title":"JS各种完美继承方案及其应用","date":"2018-01-15T12:55:19.000Z","path":"2018/01/15/JS各种完美继承方案及其应用/","text":"ES5组合继承方案（首选）12345678910111213141516171819202122232425262728var Parent = function (name, age) &#123; this.name = name this.age = age this.say = function () &#123; console.log(&#x27;say from parent constructor&#x27;) &#125;&#125;Parent.prototype.sayALL = function () &#123; console.log(&#x27;sayALL from parent prototype&#x27;)&#125;// 完美继承var Child = function (name, age, type) &#123; // 调用父元素构造函数 Parent.apply(this, [name, age]) this.type = type&#125;// Object.create(..)它会创建一个对象并把这个对象的[[Prototype]]关联到指定的对象Child.prototype = Object.create(Parent.prototype)// 这里直接赋值会造成constructor在实例中能在原型链上被枚举Child.prototype.constructor = Child/* 可选，通过以下方式使constructor不能被枚举 */Object.defineProperty(Child.prototype, &#x27;constructor&#x27;, &#123; writable: false, enumerable: false, configurable: false, value: Child&#125;)var Child = new Child(&#x27;yuuhei&#x27;, &#x27;23&#x27;, &#x27;Child&#x27;) ES5寄生组合继承方案（候选）12345678910111213141516171819202122232425262728293031var Parent = function (name, age) &#123; this.name = name this.age = age this.say = function () &#123; console.log(&#x27;say from parent constructor&#x27;) &#125;&#125;Parent.prototype.sayALL = function () &#123; console.log(&#x27;sayALL from parent prototype&#x27;)&#125;// 完美继承var Child = function (name, age, type) &#123; // 调用父元素构造函数 Parent.apply(this, [name, age]) this.type = type&#125;// 重点var Super = function () &#123;&#125;Super.prototype = Parent.prototype// 这时候Super实例化就没有Parent的构造函数的内容了Child.prototype = new Super()// 这里直接赋值会造成constructor在实例中能在原型链上被枚举Child.prototype.constructor = Child/* 可选，通过以下方式使constructor不能被枚举 */Object.defineProperty(Child.prototype, &#x27;constructor&#x27;, &#123; writable: false, enumerable: false, configurable: false, value: Child&#125;)var Child = new Child(&#x27;yuuhei&#x27;, &#x27;23&#x27;, &#x27;Child&#x27;) ES6的class实现继承方案（首选）123456789101112131415161718192021222324class Parent &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; say() &#123; return &#x27;this is parent&#x27; &#125;&#125;// ES6语法糖继承class Child extends Parent &#123; constructor(name, age, type) &#123; // super必须放在第一行 super(name, age) this.type = type &#125; sayChild() &#123; // 利用super调用父构造函数 return super.say() &#125;&#125;var children = new Child(&#x27;yuuhei&#x27;, 23, &#x27;child&#x27;) class扩展阅读参考（伪多态等）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* Orbment.prototype.call(this, ...)是伪多态 */class Orbment &#123; constructor(name) &#123; this.name = name || &#x27;Orbment&#x27;; this.message = null; &#125; setSize(width, height) &#123; this.width = width || 50; this.height = height || 50; this.message = `The $&#123;this.name&#125; `; &#125; getMessage() &#123; return this.message; &#125;&#125;class ENIGMA extends Orbment &#123; constructor(name, width, height) &#123; // super()在constructor必须在this调用前执行 super(name); this.width = width || 50; this.height = height || 50; &#125; setSize(width, height) &#123; // 以前的伪多态写法：Orbment.prototype.setSize.apply(this, [width, height]) // 注意你不知道的javascript出版书上的super(width, height)在constructor外使用已被禁止，改为替换以下方式实现相对多态 // 对父元素的setSize的基础上进行重写 super.setSize(width, height); this.message += `size is width $&#123;this.width&#125; and height $&#123;this.height&#125;`; return this; &#125;&#125;class ARCUS extends Orbment &#123; constructor(name, width, height) &#123; // super()在constructor必须在this调用前执行 super(name); this.width = width || 50; this.height = height || 50; &#125; setSize(width, height) &#123; // 以前的伪多态写法：Orbment.prototype.setSize.apply(this, [width, height]) // 注意你不知道的javascript出版书上的super(width, height)在constructor外使用已被禁止，改为替换以下方式实现相对多态 // 对父元素的setSize的基础上进行重写 super.setSize(width, height); this.message += `size is width $&#123;this.width&#125; and height $&#123;this.height&#125;`; return this; &#125;&#125;let ENIGMA_I = new ARCUS(&#x27;ENIGMA_I&#x27;);let ENIGMA_I_SIZE_MESSAGE = ENIGMA_I .setSize() .getMessage();let ARCUS_I = new ARCUS(&#x27;ARCUS_I&#x27;);let ARCUS_I_SIZE_MESSAGE = ARCUS_I .setSize(100, 70) .getMessage();console.log(ENIGMA_I_SIZE_MESSAGE);console.log(ARCUS_I_SIZE_MESSAGE);","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"}]},{"title":"移动端常用元素等比缩放原理","date":"2018-01-15T12:47:22.000Z","path":"2018/01/15/移动端常用元素等比缩放原理/","text":"原理使用伪元素进行百分比撑高，假如元素在设计稿的尺寸是100x150，那么伪元素的paddingTop就填充高&#x2F;宽度，也就是150&#x2F;100 * 100%，即可等比缩放。 HTML结构123456&lt;div class=&quot;test&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;div class=&quot;item&quot;&gt;1&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;div class=&quot;item&quot;&gt;2&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;div class=&quot;item&quot;&gt;3&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;div class=&quot;item&quot;&gt;4&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; CSS1234567891011121314151617181920212223242526272829303132/* 元素等比缩放方案 */.test &#123; font-size: 0;&#125;.test .inner &#123; display: inline-block; width: 25%; vertical-align: top; position: relative; background-color: rgba(255, 0, 0, .5);&#125;.test .inner .item &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0;&#125;.test .inner:before &#123; content: &quot;&quot;; display: inline-block; padding-bottom: 100%; width: .1px; vertical-align: top;&#125;.test .inner:nth-child(2n) &#123; background-color: rgba(0, 0, 0, .5);&#125;","tags":[{"name":"CSS","slug":"CSS","permalink":"https://sellenite.github.io/tags/CSS/"},{"name":"移动端","slug":"移动端","permalink":"https://sellenite.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}]},{"title":"前端切图技巧汇总","date":"2018-01-13T04:01:54.000Z","path":"2018/01/13/前端切图技巧汇总/","text":"部署PS环境 下载PS cs6 Extended 64位 正版破解版 视图&#x2F;显示&#x2F;智能参考线以及视图&#x2F;字符，这两个都要选上 窗口&#x2F;信息；窗口&#x2F;字符，两个打开，其他的多余的可不需要，将前面的勾取消 点击信息面板那一个小三角，打开面板选项&#x2F;标尺单位：像素；两个像素模式：RGB颜色和WEB颜色；文档尺寸选上，然后确定 编辑&#x2F;首选项&#x2F;单位与标尺【标尺：像素；文字：像素，其他默认不用改动】这样的做的好处：在PS里打开一个网页，随便点击哪个图片或者某个字符，就可以知道详细的信息 窗口&#x2F;工作区&#x2F;新建工作区&#x2F;名称：web切图，后两个选上，然后点击存储，这样就可以保存下来，防止丢失了。右上角可以更换，窗口-工作区可以复位。这样就可以储存基本布局和快捷键 右边区域需要的窗口有：图层、历史记录、信息、字符。单位全部改成像素 技巧篇 使用markman进行psd设计稿的标注 PS切图尽量使用图层切图。图层切图步骤：首先在图层查找到需要提出来的组（快速选择用ctrl+选择单击），然后对着组右键合并组，然后对着组ctrl+单击，选中图像，这时候psd里会出现虚线，然后ctrl+c复制，文件新建（必须先复制图层，再新建，这样就会默认有图层的尺寸），直接确认，然后ctrl+v粘贴，将另一个多余的图层删去，然后保存。无法合并的图层一般需要栅格化文字或栅格化图层后才能合并 给新建的透明背景添加背景颜色方便移位（如果没有则在右下角垃圾桶图左边的地方有一个新增图层）方法：一个是选中图层后，单击图层选项卡，选择新建填充图层，纯色，然后选择颜色；第二个是选定好左边菜单栏右下角的颜色，然后选中图层，按快捷键ctrl + backspace进行填充对应颜色 如何进行多个图层选中，不用一个一个点：先在需要选中多个图层的附近按着V，点击鼠标看看有没有图层移动，如果有移动的话就点一下图层窗口的锁定。然后在用方框选中后，再用移动工具移动，会发现几个图层都会同时移动了 使用切片工具后，点击ctrl+shift+alt+s弹出保存框，将区域缩放到最小，然后鼠标按着选中区域，这时候再点击右上角的输出格式，就能够全部切片都按照这个格式切出去了，如果是一个个不同的需要点击对应切片，在选中格式即可 有矢量智能对象（AI弄的），需要分割一个个图片，需要对其右键，选择栅格化图层，然后使用选择工具选中在剪切黏贴，这样就可以像其他图层一样使用了 字体图层也需要栅格化后才能合并图层 将一个图层的颜色全部换成想要的颜色：在图层上按着alt+鼠标往上移，建立副本图层，图层选项卡双击图层空隙，选中颜色叠加，改变颜色后隐藏以前的图层即可换颜色 快捷键alt + 滚轮可以放大缩小图像","tags":[{"name":"PS","slug":"PS","permalink":"https://sellenite.github.io/tags/PS/"}]},{"title":"JS简单碰撞原理","date":"2018-01-09T13:52:50.000Z","path":"2018/01/09/JS简单碰撞原理/","text":"先看分析图： 当div1在div2的上边线(t2)以上的区域活动时，始终碰不上 当div1在div2的右边线(r2)以右的区域活动时,始终碰不上 当div1在div2的下边线(b2)以下的区域活动时,始终碰不上 当div1在div2的左边线(r2)以左的区域活动时,始终碰不上 除了以上四种情况，其他情况表示div1和div2碰上了，下面试完整测试代码 由于测试时外面有position为relative，使用offsetTop等会受它的影响，故以client为基准，使用getBoundingClientRect，原理不变： 1234567891011121314151617181920212223/* 传入两个原生dom元素 */function judgeCrash(obj1, obj2) &#123; /* 碰撞判断 */ var first_Rect = obj1.getBoundingClientRect() var second_Rect = obj2.getBoundingClientRect() var firstLeft = first_Rect.left; var firstTop = first_Rect.top; var firstRight = first_Rect.right; var firstBottom = first_Rect.bottom; var secondLeft = second_Rect.left; var secondTop = second_Rect.top; var secondRight = second_Rect.right; var secondBottom = second_Rect.bottom; if (firstLeft &gt; secondRight || firstRight &lt; secondLeft || firstTop &gt; secondBottom || firstBottom &lt; secondTop) &#123; // 没有碰撞 return false; &#125; else &#123; // 有碰撞 return true; &#125;&#125;","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"}]},{"title":"工作时制作移动端的技巧","date":"2017-11-21T01:08:43.000Z","path":"2017/11/21/工作时制作移动端的技巧/","text":"简单的利用JS来判断页面是在手机端还是在PC端打开的方法12345if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) &#123; window.location.href = &quot;https://www.baidu.com/&quot;;&#125; else &#123; window.location.href = &quot;http://news.baidu.com/&quot;;&#125; 在微信浏览器关闭当前页面的方法 需要在微信公众号签名才能够使用 1WeixinJSBridge.call(&#x27;closeWindow&#x27;) 移动端图片模糊的问题 在移动端需要使用PC端两倍尺寸的图片，然后用background-size:50%;来还原本来的尺寸，这样移动端的图片才会清晰，不模糊 移动端调试工具一个移动端真机调试：browser-sync 使用经验 input placeholder问题在chrome 模拟移动端调试时，显示的非常正常，但是在真机上，placeholder里面的内容明显靠上，非常的不美观 在国外网站，对这个属性的兼容性处理，那就是不要设计input的line-height或者设置line-height为normal即可， 试了一下，虽然在谷歌模拟调试里稍微偏上，但是在“真机上”正常垂直居中～ line－heightline-height经常用于文字居中，不同手机显示效果不一样。 有时需要不是用line-height和height相同来进行居中，使用其他方法居中 实现自定义原生控件的样式由于select移动端原生样式很丑，但是原生弹出样式是符合我们设计的原则 解决方法：将原本select 设置为透明，z-index设置高～再用一个比较好看的样式‘假装’在表面 移动端使用innerHtml绘制使用innerHTML绘制大段，之后想获取HTML的ID节点，事实上是获取不到的，这种问题在动态创建DOM会经常发生 这也是一个神器的问题，博主自己写了一个移动端轮播插件，在chrome上浏览非常正常，但到了真机上却显示空白，各种百度，最后才发现这么坑的地方… 解决方案：尝试了很多方法之后，老老实实在页面直接用html结构，如果有更好的方法，也请告诉我。 300ms延迟方案一：禁用缩放在HTML文档头部包含如下meta标签时： 12&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=1&quot;/&gt; 缺点——就是必须通过完全禁用缩放来达到去掉点击延迟的目的，然而完全禁用缩放并不是我们的初衷，我们只是想禁掉默认的双击缩放行为，这样就不用等待300ms来判断当前操作是否是双击。 方案二：更改默认的视口宽度 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;/&gt; 如果设置了上述meta标签，那浏览器就可以认为该网站已经对移动端做过了适配和优化，就无需双击缩放操作了。这个方案相比方案一的好处在于，它没有完全禁用缩放，而只是禁用了浏览器默认的双击缩放行为，但用户仍然可以通过双指缩放操作来缩放页面。 兼容性问题：对于方案一和方案二，Chrome是率先支持的，Firefox紧随其后，然而令Safari头疼的是，它除了双击缩放还有双击滚动操作，如果采用这种两种方案，那势必连双击滚动也要一起禁用。 方案三：引入fastclick插件（最佳） 点击穿透问题常见发生场景： 假如页面上有两个元素A和B。B元素在A元素之上。我们在B元素的touchstart事件上注册了一个回调函数，该回调函数的作用是隐藏B元素。我们发现，当我们点击B元素，B元素被隐藏了，随后，A元素触发了click事件。 这是因为在移动端浏览器，事件执行的顺序是touchstart &gt; touchend &gt; click。 而click事件有300ms的延迟，当touchstart事件把B元素隐藏之后，隔了300ms，浏览器触发了click事件，但是此时B元素不见了，所以该事件被派发到了A元素身上。如果A元素是一个链接，那此时页面就会意外地跳转。 解决思路： 1.不要混用touch和click 2.消耗掉touch之后的click 解决方法： 1.只用touch 把页面内所有click全部换成touch事件（ touchstart 、’touchend’、’tap’），注意：a标签的href也是click，需要换成js的跳转。 2.改动最小——350ms后再隐藏B元素 虚拟键盘导致fixed元素错位fixed元素一定会伴随虚拟键盘的出现，但是虚拟键盘只是“贴”在了viewport上，表面上不会对dom产生“任何”影响，但是这个时候fixed元素表现却变得怪异起来，会错位。 解决原理：虚拟键盘弹出时将fixed元素设置为static，虚拟键盘消失时候设置回来。 解决方案：由于虚拟键盘出现并未抛出事件，而检测scroll或者resize事件，皆会有一定延迟，会出现闪烁现象。则当前获取焦点元素为文本元素，就将fixed元素设置为static。 移动端手势手指放在屏幕上：ontouchstart 手指在屏幕上滑动：ontouchmove 手指离开屏幕：ontouchend 原理： 1.在touchstart事件触发时， 记录手指按下的时间startTime，本次滑动的初始位置initialPos。 2.在touchmove事件触发时， 记录当前位置nowPosition（实时移动元素），滑动距离movePosition（当前位置nowPosition与初始位置initialPos的差值），判断正负数再决定是左还是右移动。 3.在touchend事件触发时， 记录手指离开屏幕的时间endTime，获得手指在屏幕上停留的时间（endTime－startTime），滑动距离movePosition 判断是否滑动：如果停留时间少于300ms，则认为是快速滑动，无论滑动距离是多少，都到下一页滑动距离与‘容器’ 大小进行比较，若超过‘容器’大小的1&#x2F;3，则到下一页 iphone动态生成html元素click失效这个也是神奇的坑，找了很久资料，也没有很原理的解释。解决方法： 为绑定click的元素增加css样式 cursor：pointer； 腾讯移动端字体最佳规范设置123body &#123; font-family: -apple-system, BlinkMacSystemFont, &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, STHeiti, &quot;Microsoft Yahei&quot;, Tahoma, Simsun, sans-serif;&#125; 基础交互设置全局的CSS样式，避免图中的长按弹出菜单与选中文本的行为 1234567a, img &#123; -webkit-touch-callout: none; /* 禁止长按链接与图片弹出菜单 */&#125;html, body &#123; -webkit-user-select: none; /* 禁止选中文本（如无文本选中需求，此为必选项） */ user-select: none;&#125; 移动性能(腾讯移动web开发规范)要考虑Android低端机与2G网络场景下性能发布前必要检查项 所有图片必须有进行过压缩 考虑适度的有损压缩，如转化为80%质量的jpg图片 考虑把大图切成多张小图，常见在banner图过大的场景 加载性能优化, 达到打开足够快 数据离线化，考虑将数据缓存在 localStorage 初始请求资源数 &lt; 4 注意！ 图片使用CSS Sprites 或 DATAURI 外链 CSS 中避免 @import 引入 考虑内嵌小型的静态资源内容 初始请求资源gzip后总体积 &lt; 50kb 静态资源(HTML&#x2F;CSS&#x2F;JS&#x2F;IMAGE)是否优化压缩？ 避免打包大型类库 确保接入层已开启Gzip压缩 尽量使用CSS3代替图片 初始首屏之外的图片资源需延迟加载 注意！ 单页面应用(SPA)考虑延迟加载非首屏业务模块 运行性能优化, 达到操作足够流畅 避免 iOS 300+ms 点击延时问题 注意！ 缓存 DOM 选择与计算 避免触发页面重绘的操作 Debounce连续触发的事件(scroll&#x2F;resize)，避免高频繁触发执行 尽可能使用事件代理，避免批量绑定事件 使用CSS3动画代替JS动画 避免在低端机上使用大量CSS3渐变阴影效果，可考虑降级效果来提升流畅度 HTML结构层级保持足够简单，推荐不超过 5 个层级 尽能少的使用CSS高级选择器与通配选择器 Keep it simple 在线性能检测评定工具使用指南 访问 Google PageSpeed 在线评定网站 在地址栏输入目标URL地址，点击分析按钮开始检测 按 PageSpeed 分析出的建议进行优化，优先解决红色类别的问题 border-1px简单实现原理：使用min-device-pixel-ratio配合伪类呈现的border进行scaleY缩放处理： 123&lt;div class=&quot;box border-1px&quot;&gt; &lt;p&gt;test&lt;/p&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829.border-1px &#123; position: relative;&#125;.border-1px:after &#123; content: &quot;&quot;; display: block; position: absolute; left: 0; right: 0; bottom: 0; width: 100%; border-top: 1px solid #CCC;&#125;/* 重点 */@media (min-device-pixel-ratio: 2), (-webkit-min-device-pixel-ratio: 2) &#123; .border-1px:after &#123; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); &#125;&#125;@media (min-device-pixel-ratio: 1.5), (-webkit-min-device-pixel-ratio: 1.5) &#123; .border-1px:after &#123; -webkit-transform: scaleY(0.7); transform: scaleY(0.7); &#125;&#125;","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"},{"name":"CSS","slug":"CSS","permalink":"https://sellenite.github.io/tags/CSS/"},{"name":"移动端","slug":"移动端","permalink":"https://sellenite.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}]},{"title":"JS函数节流和函数去抖和分时函数","date":"2017-07-21T07:48:06.000Z","path":"2017/07/21/JS函数节流和函数去抖和分时函数/","text":"函数节流throttle.js我们这里说的throttle就是函数节流的意思。再说的通俗一点就是函数调用的频度控制器，是连续执行时间间隔控制。主要应用的场景比如： 鼠标移动，mousemove 事件 DOM 元素动态定位，window对象的resize和scroll 事件 定时器版： 1234567891011121314151617181920212223var throttle = function(fn, interval) &#123; var timer, firstTime = true; return function(...args) &#123; var _this = this; if (firstTime) &#123; fn.apply(_this, args); return firstTime = false; &#125; if (timer) &#123; return false; &#125; timer = setTimeout(function() &#123; clearTimeout(timer); timer = null; fn.apply(_this, args); &#125;, interval || 200); &#125;&#125; 时间戳版 12345678910111213var throttle = function(fn, interval) &#123; var previous = 0; return function(...args) &#123; var now = +new Date(); var _this = this; if (now - previous &gt; interval) &#123; fn.apply(_this, args); previous = now &#125; &#125;&#125; 函数去抖debounce.jsdebounce和throttle很像，debounce是空闲时间必须大于或等于 一定值的时候，才会执行调用方法。debounce是空闲时间的间隔控制。比如我们做autocomplete，这时需要我们很好的控制输入文字时调用方法时间间隔。一般时第一个输入的字符马上开始调用，根据一定的时间间隔重复调用执行的方法。对于变态的输入，比如按住某一个建不放的时候特别有用。debounce主要应用的场景比如： 文本输入keydown 事件，keyup 事件，例如做autocomplete 1234567891011121314var debounce = function(fn, interval) &#123; var timer return function(...args) &#123; var _this = this; if (timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(function() &#123; fn.apply(_this, args); &#125;, interval); &#125;&#125; 用法： 1234567document.addEventListener(&#x27;mousemove&#x27;, debounce(function() &#123; console.log(this)&#125;, 500));document.addEventListener(&#x27;mousemove&#x27;, throttle(function() &#123; console.log(this)&#125;, 500)); 额外性能优化方案：分时函数12345678910111213141516171819202122232425262728293031323334// 分时函数，避免一次加载过多数据，类似好友列表var timeChunk = function(array, fn, count, interval) &#123; var obj, timer var start = function() &#123; for (var i = 0; i &lt; Math.min(count || 1, array.length); i++) &#123; obj = array.shift(); fn(obj) &#125; &#125; return function() &#123; timer = setInterval(function() &#123; if (array.length === 0) &#123; return clearInterval(timer); &#125; start(); &#125;, interval || 200); &#125;&#125;var friendList = [];for (var i = 0; i &lt; 100; i++) &#123; friendList.push(&#123; id: i &#125;);&#125;var renderFriendList = timeChunk(friendList, function(item) &#123; var div = document.createElement(&#x27;div&#x27;); div.innerHTML = item.id; document.body.appendChild(div);&#125;, 10);renderFriendList();","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"}]},{"title":"JS实现Ajax和Jsonp","date":"2017-07-13T12:12:16.000Z","path":"2017/07/13/JS实现Ajax和Jsonp/","text":"一、JS原生AJAXajax：一种请求数据的方式，不需要刷新整个页面； ajax的技术核心是 XMLHttpRequest 对象； ajax 请求过程：创建 XMLHttpRequest 对象、连接服务器、发送请求、接收响应数据； 封装基本ajax函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 普通回调function ajax(options) &#123; options = options || &#123;&#125;; options.data = options.data || &#123;&#125;; // 请求方式，默认是GET options.type = (options.type || &#x27;GET&#x27;).toUpperCase(); // 避免有特殊字符，必须格式化传输数据 options.data = formatParams(options.data); var xhr = null; // 实例化XMLHttpRequest对象 if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else &#123; // IE6及其以下版本 xhr = new ActiveXObjcet(&#x27;Microsoft.XMLHTTP&#x27;); &#125;; // 监听事件，只要 readyState 的值变化，就会调用 readystatechange 事件 xhr.onreadystatechange = function () &#123; // readyState属性表示请求/响应过程的当前活动阶段，4为完成，已经接收到全部响应数据 if (xhr.readyState == 4) &#123; var status = xhr.status; // status：响应的HTTP状态码，以2开头的都是成功 if (status &gt;= 200 &amp;&amp; status &lt; 300) &#123; var response = &#x27;&#x27;; // 判断接受数据的内容类型 var type = xhr.getResponseHeader(&#x27;Content-type&#x27;); if (type.indexOf(&#x27;xml&#x27;) !== -1 &amp;&amp; xhr.responseXML) &#123; response = xhr.responseXML; //Document对象响应 &#125; else if (type === &#x27;application/json&#x27;) &#123; response = JSON.parse(xhr.responseText); //JSON响应 &#125; else &#123; response = xhr.responseText; //字符串响应 &#125;; // 成功回调函数 options.success &amp;&amp; options.success(response); &#125; else &#123; options.error &amp;&amp; options.error(status); &#125; &#125;; &#125;; // 连接和传输数据 if (options.type == &#x27;GET&#x27;) &#123; // 三个参数：请求方式、请求地址(get方式时，传输数据是加在地址后的)、是否异步请求(同步请求的情况极少)； xhr.open(options.type, options.url + &#x27;?&#x27; + options.data, true); xhr.send(null); &#125; else &#123; xhr.open(options.type, options.url, true); //必须，设置提交时的内容类型 xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;); // 传输数据 xhr.send(options.data); &#125; //格式化参数 function formatParams(data) &#123; var arr = []; for (var name in data) &#123; // encodeURIComponent() ：用于对 URI 中的某一部分进行编码 arr.push(encodeURIComponent(name) + &#x27;=&#x27; + encodeURIComponent(data[name])); &#125;; // 添加一个随机数参数，防止缓存 arr.push(&#x27;v=&#x27; + random()); return arr.join(&#x27;&amp;&#x27;); &#125; // 获取随机数 function random() &#123; return Math.floor(Math.random() * 10000 + 500); &#125;&#125; 12345678910// 调用ajax(&#123; url: &#x27;test.php&#x27;, // 请求地址 type: &#x27;POST&#x27;, // 请求类型，默认&quot;GET&quot;，还可以是&quot;POST&quot; data: &#123; &#x27;b&#x27;: &#x27;异步请求&#x27; &#125;, // 传输数据 success: function (res) &#123; // 请求成功的回调函数 console.log(JSON.parse(res)); &#125;, error: function (error) &#123; &#125; // 请求失败的回调函数&#125;); 1、创建1.1、IE7及其以上版本中支持原生的 XHR 对象，因此可以直接用： var oAjax &#x3D; new XMLHttpRequest(); 1.2、IE6及其之前的版本中，XHR对象是通过MSXML库中的一个ActiveX对象实现的。有的书中细化了IE中此类对象的三种不同版本，即MSXML2.XMLHttp、MSXML2.XMLHttp.3.0 和 MSXML2.XMLHttp.6.0；个人感觉太麻烦，可以直接使用下面的语句创建： var oAjax&#x3D;new ActiveXObject(’Microsoft.XMLHTTP’); 2、连接和发送2.1、open()函数的三个参数：请求方式、请求地址、是否异步请求(同步请求的情况极少，至今还没用到过)； 2.2、GET 请求方式是通过URL参数将数据提交到服务器的，POST则是通过将数据作为 send 的参数提交到服务器； 2.3、POST 请求中，在发送数据之前，要设置表单提交的内容类型； 2.4、提交到服务器的参数必须经过 encodeURIComponent() 方法进行编码，实际上在参数列表”key&#x3D;value”的形式中，key 和 value 都需要进行编码，因为会包含特殊字符。每次请求的时候都会在参数列表中拼入一个 “v&#x3D;xx” 的字符串，这样是为了拒绝缓存，每次都直接请求到服务器上。 123encodeURI() ：用于整个 URI 的编码，不会对本身属于 URI 的特殊字符进行编码，如冒号、正斜杠、问号和井号；其对应的解码函数 decodeURI()；encodeURIComponent() ：用于对 URI 中的某一部分进行编码，会对它发现的任何非标准字符进行编码；其对应的解码函数 decodeURIComponent()； 3、接收3.1、接收到响应后，响应的数据会自动填充XHR对象，相关属性如下responseText：响应返回的主体内容，为字符串类型；responseXML：如果响应的内容类型是 “text&#x2F;xml” 或 “application&#x2F;xml”，这个属性中将保存着相应的xml 数据，是 XML 对应的 document 类型；status：响应的HTTP状态码；statusText：HTTP状态的说明； 3.2、XHR对象的readyState属性表示请求&#x2F;响应过程的当前活动阶段，这个属性的值如下 0-未初始化，尚未调用open()方法； 1-启动，调用了open()方法，未调用send()方法； 2-发送，已经调用了send()方法，未接收到响应； 3-接收，已经接收到部分响应数据； 4-完成，已经接收到全部响应数据； 只要 readyState 的值变化，就会调用 readystatechange 事件，(其实为了逻辑上通顺，可以把readystatechange放到send之后，因为send时请求服务器，会进行网络通信，需要时间，在send之后指定readystatechange事件处理程序也是可以的，我一般都是这样用，但为了规范和跨浏览器兼容性，还是在open之前进行指定吧)。 3.3、在readystatechange事件中，先判断响应是否接收完成，然后判断服务器是否成功处理请求，xhr.status 是状态码，状态码以2开头的都是成功，304表示从缓存中获取，上面的代码在每次请求的时候都加入了随机数，所以不会从缓存中取值，故该状态不需判断。 4、ajax请求是不能跨域的！二、JSONP跨域JSONP(JSON with Padding) 是一种跨域请求方式。主要原理是利用了script 标签可以跨域请求的特点，由其 src 属性发送请求到服务器，服务器返回 js 代码，网页端接受响应，然后就直接执行了，这和通过 script 标签引用外部文件的原理是一样的。 JSONP由两部分组成：回调函数和数据，回调函数一般是由网页端控制，作为参数发往服务器端，服务器端把该函数和数据拼成字符串返回。 比如网页端创建一个 script 标签，并给其 src 赋值为 http://www.superfiresun.com/json/?callback=process， 此时网页端就发起一个请求。服务端将要返回的数据拼好最为函数的参数传入，服务端返回的数据格式类似process(&#123;&#39;name&#39;&#39;:&#39;superfiresun&#39;&#125;)，网页端接收到了响应值，因为请求者是 script，所以相当于直接调用 process 方法，并且传入了一个参数。 单看响应返回的数据，JSONP 比 ajax 方式就多了一个回调函数。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * jsonp请求 原理 * 服务端返回类似test(&#123;&quot;q&quot;:&quot;测试&quot;&#125;)这样的执行函数 * 前端只需定义test这个函数处理传入返回的数据即可 * 有些后台还支持定义返回的函数名是什么，但是需要约定好字段传入 */const jsonp = (&#123; url, params, callbackKey, callback, overtime &#125;) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; let script = document.createElement(&#x27;script&#x27;); let head = document.getElementsByTagName(&#x27;head&#x27;)[0]; let arr = []; // 随机数防止缓存 params = &#123; ...params, v: Math.random(), [callbackKey]: callback &#125;; head.appendChild(script); for (let key in params) &#123; arr.push(`$&#123;encodeURIComponent(key)&#125;=$&#123;encodeURIComponent(params[key])&#125;`); &#125; // 回调函数 window[callback] = function(data) &#123; resolve(data); clearTimeout(script.timer); head.removeChild(script); window[callback] = null; &#125; // 发送请求 script.src = `$&#123;url&#125;?$&#123;arr.join(&#x27;&amp;&#x27;)&#125;`; // 前端控制超时处理 if (overtime) &#123; script.timer = setTimeout(() =&gt; &#123; head.removeChild(script); // 删除回调，不能直接赋值null，假如之后请求回来后会执行null()，导致报错 window[callback] = () =&gt; &#123; window[callback] = null; &#125;; reject(&#x27;前端限制时间内请求超时&#x27;); &#125;, overtime); &#125; &#125;);&#125;; 1、因为 script 标签的 src 属性只在第一次设置的时候起作用，导致 script 标签没法重用，所以每次完成操作之后要移除； 2、JSONP这种请求方式中，参数依旧需要编码； 3、如果不设置超时，就无法得知此次请求是成功还是失败； 123456789101112131415// 执行jsonp(&#123; url: &#x27;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&#x27;, // 请求地址 params: &#123; json: 1, wd: &#x27;测试&#x27; &#125;, overtime: 5000, // 超时 callbackKey: &#x27;cb&#x27;, // 后端约定字段 callback: &#x27;test&#x27; // 返回时的执行函数名称&#125;).then(res =&gt; &#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(err);&#125;);","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"}]},{"title":"JS开发datepicker","date":"2017-05-21T02:14:49.000Z","path":"2017/05/21/JS开发datepicker/","text":"基础知识首先，需要知道new Date()这个参数的基本使用： 传入new Date(2017, 4, 20)，的时候，由于月份的索引是从0-11的，所以，传入2017, 4, 20的时候，实际的显示的月份是2017年5月20日 月份和日期位会自动进位和退位，例如月份位小于0大于11，日期位等于小于0和大于本月日期数 拿到当月第一天是这样写的：new Date(year, month-1, 1) 拿到当月最后一天是这样写的：new Date(year, month, 0) .getDay()获取的的是这个日期的星期几，星期一~星期天对应[1, 2, 3, 4, 5, 6, 0] 其次，需要知道js的一些新的API： document.querySelector()获取的是CSS选择器，即传入的参数是’.exampleClass’或’.#exampleID’，需要将字符串传进去，获取的就是第一个匹配的class 如果想获取多个同class的CSS选择器，使用document.querySelectorAll $element.classList.add()可以添加class $element.classList.remove()可以移除特定class $element.dataset.xx可以访问到dom元素里自定义属性data-xx，返回的值就是xx 注意好编码习惯，例如一个dom元素起名就用$开头，如$wrapper 开发思路 日历中，首先需要知道这个月的第一天是星期几，这个月的最后一天的日期，上个月最后一天的日期。 这个日历中，是7*6行，用i做遍历。分析图如下图： 首先要分析上个月的日期，在这个月的日历中会显示多少个。这个月的1号是星期四，那么前面就有3个上个月的。所以上个月日期的数量是这个月第一天的星期-1 其次要计算出真实日期date（1是这个月第一天，那么0就是上个月的最后一天，-1就是上个月的倒数第二天）。公式：i - 上个月日期数 + 1 算完真实日期，那么要计算显示的日期，由于date等于0小于0就是说明上个月的，假设上个月最后一天是31号，date为0，倒数第二天是30号，date为-1，那么上个月显示的日期就是利用上个月的最后一天加上date的值（这里date为负数） 算完上个月的，就要算下个月的日期在这个月日历中显示的。可以看出，当真实日期date大于本月的最后一天的日期时，就说明后面的都是下个月的日期，那么显示的日期就是date减去这个月最后一天的日期 计算日期的代码： datepicker.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687(() =&gt; &#123; var datepicker = &#123;&#125;; datepicker.getMonthData = function (year, month) &#123; // 用于返回数据 var ret = []; // 用于显示哪天高亮 var todayShow = new Date().getDate(); // 获得这个月的第一天 var firstDay = new Date(year, month - 1, 1); // 获得这个月的第一天是星期几，用于判断前面的数 var firstDayWeekDay = firstDay.getDay(); // 如果获得这个是星期天，将getDay的0重置为7 if (firstDayWeekDay === 0) firstDayWeekDay = 7; // 用于日历头部的显示 HeadYear = firstDay.getFullYear(); HeadMonth = firstDay.getMonth() + 1; // 获得这个月的最后一天和日期 var lastDay = new Date(year, month, 0); var lastDate = lastDay.getDate(); // 获得上个月的最后一天 var lastDayOfLastMonth = new Date(year, month - 1, 0); var lastDateOfLastMonth = lastDayOfLastMonth.getDate(); // 用于判断第一行显示多少个上一个月的日期。 // 如果这个月的第一天是星期一，那么上一个月就没有日期显示 // 如果这个月的第一天是星期二，那么上一个月就显示一个日期在星期一的位置 // 因此，上一个月需要显示日期的数量是这个月的第一天的星期几 -1. var preMonthDayCount = firstDayWeekDay - 1; for (var i = 0; i &lt; 7 * 6; i++) &#123; // 利用i获取每一天的真实日期 // 假设上个月有2天在这个日历内，那么这个月的2号就是星期四 // 当i等于3的时候，就是星期四 // 3 - 2 = 1，再加1才是真实日期 // 所以利用i拿到真实日期公式：i - 上个月日期显示的数量 + 1. var date = i - preMonthDayCount + 1; // showDate用于修正真实日期，用于显示 var showDate = date; // showMonth用于统计该日期真实月份 var thisMonth = month; // 统计哪些不是本月的日期，设置实际月份和现实日期（最好将日期写下来研究） if (date &lt;= 0) &#123; // 当这个data数值等于零或小于零时，就说明遍历的这个日期是上一个月的 thisMonth = month - 1; showDate = lastDateOfLastMonth + date; &#125; else if (date &gt; lastDate) &#123; //下个月的，比如这个月有30日，多出2日，date显示是31，32，则是下月的1、2号 thisMonth = month + 1; showDate = showDate - lastDate; &#125; //如果-1的时候变成0，说明上月份是上年12月 if (thisMonth === 0) thisMonth = 12; //如果+1的时候变成13，说下月份是下年1月 if (thisMonth === 13) thisMonth = 1; ret.push( &#123; month: thisMonth, // 每个日期的实际月份 date: date, // 真实日期，有负数情况，date为1时作为本月的1号 showDate: showDate // 显示日期 &#125; ); &#125; console.log(ret); return &#123; year: HeadYear, month: HeadMonth, lastDate, // 传入最后一天的日期，用来判断渲染颜色 days: ret &#125;; &#125;; window.datepicker = datepicker;&#125;)(); 渲染和事件行为代码： main.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267(() =&gt; &#123; var datepicker = window.datepicker; var monthData; var $wrapper; var $input; var isOpen; // 渲染函数 datepicker.buildUi = function (year, month) &#123; // 需要加载完datepicker.js才加载本js monthData = datepicker.getMonthData(year, month); // 拼接&lt;td&gt;&lt;/td&gt;中的内容 var html = &#x27;&lt;div class=&quot;ui-datepicker-header&quot;&gt;&#x27; + &#x27;&lt;a href=&quot;javascript:;&quot; class=&quot;ui-datepicker-btn ui-datepicker-prev-btn&quot;&gt;&amp;lt&lt;/a&gt;&#x27; + &#x27;&lt;a href=&quot;javascript:;&quot; class=&quot;ui-datepicker-btn ui-datepicker-next-btn&quot;&gt;&amp;gt&lt;/a&gt;&#x27; + &#x27;&lt;span class=&quot;ui-datepicker-curr-month&quot;&gt;&#x27; + monthData.year + &#x27;-&#x27; + monthData.month + &#x27;&lt;/span&gt;&#x27; + &#x27;&lt;/div&gt;&#x27; + &#x27;&lt;div class=&quot;ui-datepicker-body&quot;&gt;&#x27; + &#x27;&lt;table&gt;&#x27; + &#x27;&lt;thead&gt;&#x27; + &#x27;&lt;tr&gt;&#x27; + &#x27;&lt;th&gt;一&lt;/th&gt;&#x27; + &#x27;&lt;th&gt;二&lt;/th&gt;&#x27; + &#x27;&lt;th&gt;三&lt;/th&gt;&#x27; + &#x27;&lt;th&gt;四&lt;/th&gt;&#x27; + &#x27;&lt;th&gt;五&lt;/th&gt;&#x27; + &#x27;&lt;th&gt;六&lt;/th&gt;&#x27; + &#x27;&lt;th&gt;日&lt;/th&gt;&#x27; + &#x27;&lt;/tr&gt;&#x27; + &#x27;&lt;/thead&gt;&#x27; + &#x27;&lt;tbody&gt;&#x27;; for (var i = 0; i &lt; monthData.days.length; i++) &#123; // 用于高亮当天的日期 var todayEqual = new Date().getDate(); var monthEqual = new Date().getMonth() + 1; var yearEqual = new Date().getFullYear(); var date = monthData.days[i]; // 一周的第一天 if (i % 7 === 0) html += &#x27;&lt;tr&gt;&#x27;; // 渲染&lt;tr&gt;&lt;/tr&gt;里的内容，利用data-date保存真实日期 if (date.date &lt;= 0) &#123; // 上个月的日期 html += &#x27;&lt;td style=&quot;color: #ccc&quot; data-date=&quot;&#x27; + date.date + &#x27;&quot;&gt;&#x27; + date.showDate + &#x27;&lt;/td&gt;&#x27;; &#125; else if (date.date &gt; monthData.lastDate) &#123; // 下个月的日期 html += &#x27;&lt;td style=&quot;color: #ccc&quot; data-date=&quot;&#x27; + date.date + &#x27;&quot;&gt;&#x27; + date.showDate + &#x27;&lt;/td&gt;&#x27;; &#125; else if (date.date === todayEqual &amp;&amp; monthData.month === monthEqual &amp;&amp; monthData.year === yearEqual) &#123; // 等于今天的日期 html += &#x27;&lt;td style=&quot;background: rgba(0, 0, 0, 0.1)&quot; data-date=&quot;&#x27; + date.date + &#x27;&quot;&gt;&#x27; + date.showDate + &#x27;&lt;/td&gt;&#x27;; &#125; else &#123; // 普通的日期 html += &#x27;&lt;td data-date=&quot;&#x27; + date.date + &#x27;&quot;&gt;&#x27; + date.showDate + &#x27;&lt;/td&gt;&#x27;; &#125; // 一周的最后一天 if (i % 7 === 6) html += &#x27;&lt;/tr&gt;&#x27;; &#125; html += &#x27;&lt;/tbody&gt;&#x27; + &#x27;&lt;/table&gt;&#x27; + &#x27;&lt;/div&gt;&#x27;; return html; &#125;; // 开始渲染 datepicker.render = function (direction, year, month) &#123; // 如果没有传值，证明需要重新获取时间的值 if (!year &amp;&amp; !month) &#123; year = monthData.year; month = monthData.month; &#125; // 判断是否上下页渲染 if (direction === &#x27;prev&#x27;) month-- if (direction === &#x27;next&#x27;) month++ // 超页调整 if (month === 0) &#123; month = 12; year--; &#125; var html = datepicker.buildUi(year, month); // 如果这个元素已经被添加，则直接改变innerHTML if (!$wrapper) &#123; $wrapper = document.createElement(&#x27;div&#x27;); $wrapper.className = &#x27;ui-datepicker-wrapper&#x27;; // 将wrapper注入到body内 document.body.appendChild($wrapper); &#125; // 将渲染结果插入进去，结合了上一页和下一页功能 $wrapper.innerHTML = html; &#125; // datepicker初始化，传入函数 datepicker.init = function (inputClass, year, month) &#123; // 如果没有传入数据，那么就用现在的时间 if (!year || !month) &#123; var today = new Date(); year = today.getFullYear(); month = today.getMonth() + 1; &#125; // 由于是初始渲染而不是上下页渲染，传入一个无用值 datepicker.render(&#x27;no-direction&#x27;, year, month); // inputClass = &#x27;.example&#x27;; $input = document.querySelector(inputClass); isOpen = false; $input.addEventListener(&#x27;click&#x27;, function () &#123; if (isOpen) &#123; $wrapper.classList.remove(&#x27;ui-datepicker-wrapper-show&#x27;); isOpen = false; &#125; else &#123; // 定位到目标元素下方 var left = $input.offsetLeft; var top = $input.offsetTop; var height = $input.offsetHeight; $wrapper.style.top = top + height + 2 + &#x27;px&#x27;; $wrapper.style.left = left + &#x27;px&#x27;; $wrapper.classList.add(&#x27;ui-datepicker-wrapper-show&#x27;); isOpen = true; &#125; &#125;, false); // 使用时间冒泡触发点击事件 $wrapper.addEventListener(&#x27;click&#x27;, function (e) &#123; var $target = e.target; if ($target.classList.contains(&#x27;ui-datepicker-prev-btn&#x27;)) &#123; // 上个月 datepicker.render(&#x27;prev&#x27;); &#125; else if ($target.classList.contains(&#x27;ui-datepicker-next-btn&#x27;)) &#123; // 下个月 datepicker.render(&#x27;next&#x27;); &#125; else if ($target.tagName.toLowerCase() === &#x27;td&#x27;) &#123; // 点击日期，利用最后一个参数可以通过自我判断负数或超过当月日期数，可以自己进退 var date = new Date(monthData.year, monthData.month - 1, $target.dataset.date); $input.value = format(date); $wrapper.classList.remove(&#x27;ui-datepicker-wrapper-show&#x27;); isOpen = false; &#125; &#125;, false); // toolTip悬浮提示今天星期几，日期 $wrapper.addEventListener(&#x27;mouseover&#x27;, function (e) &#123; var $target = e.target; if ($target.tagName.toLowerCase() === &#x27;td&#x27;) &#123; var date = new Date(monthData.year, monthData.month - 1, $target.dataset.date); var datefix = format(date); var day = new Date(monthData.year, monthData.month - 1, $target.dataset.date).getDay(); var dayfix; switch (day) &#123; case 1: dayfix = &#x27;星期一&#x27;; break; case 2: dayfix = &#x27;星期二&#x27;; break; case 3: dayfix = &#x27;星期三&#x27;; break; case 4: dayfix = &#x27;星期四&#x27;; break; case 5: dayfix = &#x27;星期五&#x27;; break; case 6: dayfix = &#x27;星期六&#x27;; break; case 0: dayfix = &#x27;星期日&#x27;; break; &#125; // 创建悬浮元素 var toolTipBox; toolTipBox = document.createElement(&quot;div&quot;); toolTipBox.className = &quot;tooltip-box&quot;; // 添加独有id，用于删去 toolTipBox.id = datefix; // 渲染悬浮层内容 html = &#x27;&lt;p&gt;&#x27; + datefix + &#x27;&lt;/p&gt;&#x27; + &#x27;&lt;p&gt;&#x27; + dayfix + &#x27;&lt;/p&gt;&#x27;; toolTipBox.innerHTML = html; // 渲染 $target.appendChild(toolTipBox); &#125; &#125;, false); // 鼠标离开时移除悬浮层 $wrapper.addEventListener(&#x27;mouseout&#x27;, function (e) &#123; var $target = e.target; var date = new Date(monthData.year, monthData.month - 1, $target.dataset.date); var datefix = format(date); var child = document.getElementById(datefix); if ($target.tagName.toLowerCase() === &#x27;td&#x27;) &#123; $target.removeChild(child); &#125; &#125;, false) &#125;; // 对传出来的时间格式进行格式化 function format(date) &#123; ret = &#x27;&#x27;; // 小于9的时候加0 var padding = function (num) &#123; if (num &lt;= 9) &#123; return &#x27;0&#x27; + num; &#125; return num; &#125; ret += date.getFullYear() + &#x27;-&#x27;; ret += padding(date.getMonth() + 1) + &#x27;-&#x27;; ret += padding(date.getDate()); return ret; &#125; // 点击外部收起日历 document.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123; var target = e.target; if (!$input.contains(target) &amp;&amp; !$wrapper.contains(target) &amp;&amp; target.tagName.toLowerCase() !== &#x27;a&#x27;) &#123; $wrapper.classList.remove(&#x27;ui-datepicker-wrapper-show&#x27;); isOpen = false; &#125; &#125;, false);&#125;)(); CSS代码： style.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687.ui-datepicker-wrapper &#123; width: 240px; font-size: 16px; color: #666; box-shadow: 2px 2px 8px 2px rgba(128, 128, 128, .3); display: none; position: absolute;&#125;.ui-datepicker-wrapper-show &#123; display: block;&#125;.ui-datepicker-wrapper .ui-datepicker-header &#123; padding: 0 20px; height: 50px; line-height: 50px; text-align: center; background: #F0F0F0; border-bottom: 1px solid #CCC; font-weight: bold;&#125;.ui-datepicker-wrapper .ui-datepicker-btn &#123; font-family: serif; font-size: 20px; width: 20px; height: 50px; line-height: 50px; color: #1abc9c; text-align: center; cursor: pointer; text-decoration: none;&#125;.ui-datepicker-wrapper .ui-datepicker-prev-btn &#123; float: left;&#125;.ui-datepicker-wrapper .ui-datepicker-next-btn &#123; float: right;&#125;.ui-datepicker-wrapper .ui-datepicker-body table &#123; width: 100%; border-collapse: collapse;&#125;.ui-datepicker-wrapper .ui-datepicker-body th,.ui-datepicker-wrapper .ui-datepicker-body td &#123; height: 30px; text-align: center;&#125;.ui-datepicker-wrapper .ui-datepicker-body th &#123; font-size: 12px; height: 40px; line-height: 40px;&#125;.ui-datepicker-wrapper .ui-datepicker-body td &#123; border: 1px solid #F0F0F0; font-size: 10px; width: 14%; cursor: pointer;&#125;.ui-datepicker-wrapper .ui-datepicker-body td:hover &#123; background: rgba(0, 0, 0, 0.1);&#125;.tooltip-box &#123; display: block; background: #fff; line-height: 1.6; border: 1px solid #1abc9c; color: #333; padding: 20px; font-size: 12px; border-radius: 5px; overflow: auto; width: 80px; height: 80px; top: 40px; position: absolute; z-index: 10;&#125; html使用方法：先加载datepicker.js，然后加载main.js，在html里创建一个input元素，给这个input元素设置一个classname，然后传入这个css选择器： 1datepicker.init(&#x27;.datepicker&#x27;, 2017, 5); 可以传入年月，这个是真实日期，不用修正，也可以不传 主要实现功能 点击元素打开datepicker 日历渲染 上下月切换 区分本月和不是本月的日期 高亮当天日期 toolTip显示日期具体信息 点击日期输入 点击document收起datepicker","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"},{"name":"组件","slug":"组件","permalink":"https://sellenite.github.io/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"JS正则匹配日期自定义格式化","date":"2017-05-19T02:35:20.000Z","path":"2017/05/19/JS正则匹配日期自定义格式化/","text":"利用改原型编写 123456789101112131415161718192021222324// 对Date的扩展，将 Date 转化为指定格式的String// 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符，// 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字)// 例子：// (new Date()).Format(&quot;yyyy-MM-dd hh:mm:ss.S&quot;) ==&gt; 2006-07-02 08:09:04.423// (new Date()).Format(&quot;yyyy-M-d h:m:s.S&quot;) ==&gt; 2006-7-2 8:9:4.18Date.prototype.Format = function (fmt) &#123; //author: meizz var o = &#123; &quot;M+&quot;: this.getMonth() + 1, //月份 &quot;d+&quot;: this.getDate(), //日 &quot;H+&quot;: this.getHours(), //小时 &quot;m+&quot;: this.getMinutes(), //分 &quot;s+&quot;: this.getSeconds(), //秒 &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), //季度 &quot;S&quot;: this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length))); return fmt;&#125;var time1 = new Date().Format(&quot;yyyy-MM-dd&quot;);var time2 = new Date().Format(&quot;yyyy-MM-dd HH:mm:ss&quot;);","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"}]},{"title":"记忆中CS里好玩的地图描述","date":"2017-05-11T01:01:02.000Z","path":"2017/05/11/记忆中CS里好玩的地图描述/","text":"一个list代表一张地图 雪地，四方格，可以捡枪，调节gravity可以飞天，开局46headshot 像是雪地的布局，不过是在一个白色的墙里的，忘记名字了，到达对面可以买东西 $2000,一个直线图，中间有墙挡着，有枪有炸弹捡 awp的图，有很多石柱，地图很大 CT和T分别在两边，中间有一些荆棘，两边有一些玩具，还有个小水库 一个拿着刀的图，首先上柱子，掉下去，然后跳到一个入口，前面有绿色的水，有个滑板来回移动，可以通过跳在上面过去；还有些跳柱子的关卡，有很多关，失败会回到当前开关点，最后可以捡m249 dust版雪地，地图大一点 有很多炸弹可以捡，中间有个不透明的玻璃围着，挡住对面，是一个像雪地布局的地图 CT和T分别在两个很高的平台上，中间有一个正方形平台，可以买枪，平台下面有水，平台上可以捡散弹和炸弹（好像是） 炸弹图，开局T对着CT的背，有几层级，可以捡炸弹扔对方 csol的血战画廊 csol的发电站 007刀图，可以有各种道具飞上去打开开关捡枪： CT：可以坐一部蓝色的车，到中间的斜坡可以飞上去，可以站在左边或蹲下坐中间，按E开启，到斜坡的时候就按空格飞上去 T：可以坐一个尖尖的车，往旁边轻轻一碰，卡的时候按跳就能飞上楼梯；或者在机关入去的那个捡枪门口往下喷漆，然后坐车卡上去 机关：一边可以召唤滑块，一边导致地下空了，掉进绿色的水，死亡 008刀图还是什么序号，有很多个门和机关，具体不记得了 刀图，在水上，可以通过一些小木头跳到中间一个大木头，四方分别有小木头，有横梁，大木头上面有楼梯，上去可以捡枪，大木头可以打碎 刀图，有一张很多小房子在空中，CT家是一个很长的房子，可以通过机关移动到一个玻璃柱子往上走的房子；T是一个很小的房子，经常开局买炸弹炸CT家的房子，都可以买枪和捡枪，有个房子可以拿m249 全图玻璃，很卡，可以通过打碎玻璃让对面掉下去 cs1.5魔兽模式，可以发射导弹，鼠标指向导弹，第一人称导弹，x机激光，放烟花，终极爆炸弹，飞天，开关是bindme 在天空中，T和CT分别在对角，中间有一个列车车厢，只能够容忍一个人的宽度，车厢外两边有路，可以打碎 T和CT分别在对面，中间有两个水墙挡住，可以捡散弹。然后进去后有一个水组成的建筑物和通道，经过通道后走进去建筑物里可以捡其他枪 boold改版，中间是空心的，透视的，通过自家的一个隐藏玻璃门，打烂后才能进去，进去后透视穿墙打人 在一个很高的楼上，前面是很斜的斜坡，最左边和最右边可以定住人，不滑下去，中间也有斜坡，滑下去后有AWP捡，下面的斜坡是捡AK和M4的 两边悬崖都有飞机，中间一个大飞机，两边小飞机，可以通过飞机的撞击杀死别人，出生点是有很多枪捡，然后爬一小段悬崖选飞机 开机关，一个墙挡住了一个超大的坦克，坦克可以开，四周围有一些小车可以开，将坦克开到一个地方就赢了 护送vip，CT护送vip走，开车的，地图很大，T和CT都是开车的，vip不能买武器，vip也是玩家，只有小枪，去到一个洞里的一个终点就赢了 整个地图都是红的，好像是刀图，然后都赶着跑去顶点上，有个东西会一直让你加血 T和CT分别在对面的房子，一楼可以捡枪，有个小门可以出去，可以通过空中的浮空物跳到对方的房子。一楼可以通过一个90度楼梯爬上二楼，二楼有遮挡物，经常用来对狙 很像雪地那样的四个柱子图，沙漠皮肤，地下全是awp，往前走是小斜坡，走到中间可以跳到柱子上 刀图，掉下来只有1hp 沙漠之鹰训练图","tags":[]},{"title":"JS正则匹配url获取query","date":"2017-04-24T06:49:43.000Z","path":"2017/04/24/JS正则匹配url获取query/","text":"源码： 123456789101112131415161718192021/* 解析url参数 *//* @example ?id=12345&amp;a=b *//* @return Object &#123;id:12345, a:b&#125; */export function urlParse() &#123; let url = window.location.search; let obj = &#123;&#125;; let reg = /[?&amp;][^?&amp;]+=[^?&amp;]+/g; let arr = url.match(reg); // [&#x27;?id=12345&#x27;, &#x27;&amp;a=b&#x27;] arr if (arr) &#123; arr.forEach((item) =&gt; &#123; /* 干掉第一个字符，？和&amp; */ let tempArr = item.substring(1).split(&#x27;=&#x27;); let key = decodeURIComponent(tempArr[0]); let val = decodeURIComponent(tempArr[1]); obj[key] = val; &#125;); &#125; return obj;&#125;; 注意，由于Vue默认的路由是带有#的，就是hash，这样打出来的window.location.search得到的值是空值，所以如果是这种情况，要将上面的.search改成.hash！","tags":[{"name":"JS","slug":"JS","permalink":"https://sellenite.github.io/tags/JS/"}]},{"title":"水平居中方法总结","date":"2017-04-20T03:32:47.000Z","path":"2017/04/20/水平居中方法总结/","text":"若是行内元素, 给其父元素设置 text-align:center,即可实现行内元素水平居中. 若是块级元素且定宽, 该元素设置 margin:0 auto 即可. 若是 display:inline-block, 该元素的父元素设置 text-align:center 即可. 若不论是块级还是行内，而且元素不定宽，可以给元素设置 display: table 然后设置 margin: 0 auto 即可. 若子元素包含 float:left 属性, 为了让子元素水平居中, 则可让父元素宽度设置为fit-content,并且配合margin, 作如下设置: 123456.parent&#123; width: -moz-fit-content; width: -webkit-fit-content; width:fit-content; margin:0 auto;&#125; fit-content是CSS3中给width属性新加的一个属性值,它配合margin可以轻松实现水平居中, 目前只支持Chrome 和 Firefox浏览器. 使用flex 2012年版本布局, 可以轻松的实现水平居中, 子元素设置如下: 1234.son&#123; display: flex; justify-content: center;&#125; 使用CSS3中新增的transform属性, 子元素设置如下: 12345.son&#123; position:absolute; left:50%; transform:translate(-50%,0);&#125; 使用绝对定位方式, 以及负值的margin-left, 子元素设置如下: 123456.son&#123; position:absolute; width:固定; left:50%; margin-left:-0.5宽度;&#125; 使用绝对定位方式, 以及left:0;right:0;margin:0 auto; 子元素设置如下: 1234567.son&#123; position:absolute; width:固定; left:0; right:0; margin:0 auto;&#125;","tags":[{"name":"CSS","slug":"CSS","permalink":"https://sellenite.github.io/tags/CSS/"}]},{"title":"垂直居中方法总结","date":"2017-04-20T03:12:02.000Z","path":"2017/04/20/垂直居中方法总结/","text":"单行文本 若元素是单行文本, 则可设置 line-height 等于父元素高度 使用伪元素和inline-block 若元素是行内块级元素, 基本思想是使用display: inline-block, vertical-align: middle和一个伪元素让内容块处于容器中央. 12345678.parent::after, .son&#123; display:inline-block; vertical-align:middle;&#125;.parent::after&#123; content:&#x27;&#x27;; height:100%;&#125; 这是一种很流行的方法, 也适应IE7. 缺点：某些情况下，例如使用icon-font的时候不会绝对垂直居中，底对齐中间线的样子 利用absolute和margin:auto实现垂直居中123456789101112131415161718.wrapper &#123; position: relative; background: red; height: 200px; width: 200px;&#125;.inner &#123; position: absolute; background: yellow; height: 20px; width: 20px; top: 0; right: 0; bottom: 0; left: 0; margin: auto;&#125; 优点：容易，兼容性好 利用display:table和display:table-cell vertical-align只有在父层为 td 或者 th 时, 才会生效, 对于其他块级元素, 例如 div、p 等, 默认情况是不支持的. 为了使用vertical-align，可以如下设置： 123456789.parent &#123; display: table;&#125;.son &#123; display: table-cell; vertical-align: middle;&#125; 优点： 很多情况下都适用，父元素用了display:table的时候注意设置本身的高和宽，保证里面有空隙让子元素垂直居中 元素高度可以动态改变, 不需再CSS中定义, 如果父元素没有足够空间时, 该元素内容也不会被截断. 缺点 IE6~7, 甚至IE8 beta中无效. 使用Flex进行垂直居中 可用 Flex 2012版, 这是CSS布局未来的趋势. Flexbox是CSS3新增属性, 设计初衷是为了解决像垂直居中这样的常见布局问题. 相关的文章如《弹性盒模型Flex指南》 父元素做如下设置即可保证子元素垂直居中: 1234.parent &#123; display: flex; align-items: center;&#125; 优点 内容块的宽高任意, 优雅的溢出.可用于更复杂高级的布局技术中. 缺点 IE8&#x2F;IE9不支持需要浏览器厂商前缀 使用transform 可用 transform , 设置父元素相对定位(position:relative), 子元素如下css样式: 1234567.son&#123; position:absolute; top:50%; -webkit-transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%); transform: translate(-50%,-50%);&#125; 优点 代码量少 缺点 IE8不支持, 属性需要追加浏览器厂商前缀, 可能干扰其他 transform 效果, 某些情形下会出现文本或元素边界渲染模糊的现象. 元素高度固定 设置父元素相对定位(position:relative), 子元素如下css样式: 123456.son&#123; position:absolute; top:50%; height:固定; margin-top:-0.5高度;&#125; 优点 适用于所有浏览器. 缺点 父元素空间不够时, 子元素可能不可见(当浏览器窗口缩小时,滚动条不出现时).如果子元素设置了overflow:auto, 则高度不够时, 会出现滚动条. 设置父元素相对定位(position:relative), 子元素如下css样式: 1234567.son&#123; position:absolute; height:固定; top:0; bottom:0; margin:auto 0;&#125; 优点 简单 缺点 没有足够空间时, 子元素会被截断, 但不会有滚动条.","tags":[{"name":"CSS","slug":"CSS","permalink":"https://sellenite.github.io/tags/CSS/"}]},{"title":"前端HTML+CSS基础知识","date":"2017-03-24T11:58:52.000Z","path":"2017/03/24/前端HTML-CSS基础知识/","text":"1.行内元素和块级元素?img算什么?行内元素怎么转化为块级元素?行内元素：和有他元素都在一行上，高度、行高及外边距和内边距都不可改变，文字图片的宽度不可改变，只能容纳文本或者其他行内元素；其中img是行元素 块级元素：总是在新行上开始，高度、行高及外边距和内边距都可控制，可以容纳内敛元素和其他元素； 行元素转换为块级元素方式：display：block； 2.将多个元素设置为同一行?清除浮动有几种方式?将多个元素设置为同一行：float，inline-block 清除浮动的方式：方法一：添加新的元素 、应用 clear：both； 方法二：父级div定义 overflow: hidden； 方法三：利用:after和:before来在元素内部插入两个元素块，从面达到清除浮动的效果。 1234567891011.clear&#123; zoom:1;&#125;.clear:after&#123; content:””; clear:both; display:block; height:0; overflow:hidden; visibility:hidden;&#125; 3.什么是盒模型box-sizing？弹性盒模型|盒布局? 在标准模式下的盒模型：盒子总宽度&#x2F;高度&#x3D;width&#x2F;height+padding+border+margin 在怪异模式下的盒模型下，盒子的总宽度和高度是包含内边距padding和边框border宽度在内的，盒子总宽度&#x2F;高度&#x3D;width&#x2F;height + margin &#x3D; 内容区宽度&#x2F;高度 + padding + border + margin; box-sizing有两个值一个是content-box，另一个是border-box。 当设置为box-sizing:content-box时，将采用标准模式解析计算； 当设置为box-sizing:border-box时，将采用IE盒子解析计算。 5.href和src区别? title和althref (Hypertext Reference)指定网络资源的位置（超文本引用），从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系，在 link和a 等元素上使用。 src (Source)属性仅仅嵌入当前资源到当前文档元素定义的位置，是页面必不可少的一部分，是引入。在 img、script、iframe 等元素上使用。 title：既是html标签，又是html属性，title作为属性时，用来为元素提供额外说明信息. alt：alt是html标签的属性，alt属性则是用来指定替换文字，只能用在img、area和input元素中（包括applet元素），用于网页中图片无法正常显示时给用户提供文字说明使其了解图像信息. 6.transform？animation？区别?animation-durationTransform:它和width、left一样，定义了元素很多静态样式实现变形、旋转、缩放、移位及透视等功能，通过一系列功能的组合我们可以实现很炫酷的静态效果（非动画)。 Animation:作用于元素本身而不是样式属性,属于关键帧动画的范畴，它本身被用来替代一些纯粹表现的javascript代码而实现动画,可以通过keyframe显式控制当前帧的属性值. animation-duration：规定完成动画所花费的时间，以秒或毫秒计。 7.nth-of-type | nth-child?举例说明： 1234567&lt;ul&gt; &lt;p&gt;111&lt;/p&gt; &lt;span&gt;222&lt;/span&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; li:nth-of-type(2):表示ul下的第二个li元素li:nth-child(2)：表示既是li元素又是在ul下的第二个元素（找不到）。 建议一般使用nth-of-type，不容易出问题。 8. :before 和 ::before 区别?单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 对于CSS2之前已有的伪元素，比如:before，单冒号和双冒号的写法::before作用是一样的。 9.如何让一个div 上下左右居中?答：有三种方法。 方法1： .div1{ width:400px; height:400px; border:#CCC 1px solid; background:#99f; position:absolute; left:50%; top:50%; transform: translate(-50%,-50%); } 方法2： .div2{ width:400px; height:400px; border:#CCC 1px solid; background:#99f; position: absolute; left:0; top: 0; bottom: 0; right: 0; margin: auto; } 方法3： .div3{ width:400px; height:400px; border:#CCC 1px solid; background:#9f9; position: absolute; left: 50%; top:50%; margin-left:-200px; margin-top: -200px; } 10.css2.0 和css3.0答：css3加强了css2的功能，增加了新的属性和新的标签，并且删除了一些冗余的标签，在布局方面减少了代码量。以前比较复杂的布局现在一个属性就搞定了（columns之类的属性）。在效果方面加入了更多的效果(圆角，动画之类的)，还有在盒子模型和列表模块都进行了改进。不过CSS3兼容性不好，只有一些高级版本的浏览器支持。 11.弹性盒子模型?flex|box区别?(1) 引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的条目进行排列、对齐和分配空白空间。 即便容器中条目的尺寸未知或是动态变化的，弹性盒布局模型也能正常的工作。在该布局模型中，容器会根据布局的需要，调整其中包含的条目的尺寸和顺序来最好地填充所有可用的空间。 当容器的尺寸由于屏幕大小或窗口尺寸发生变化时，其中包含的条目也会被动态地调整。比如当容器尺寸变大时，其中包含的条目会被拉伸以占满多余的空白空间；当容器尺寸变小时，条目会被缩小以防止超出容器的范围。弹性盒布局是与方向无关的。 在传统的布局方式中，block 布局是把块在垂直方向从上到下依次排列的；而 inline 布局则是在水平方向来排列。弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。 (2) flex和box的区别: display：box 是老规范，要兼顾古董机子就加上它； 父级元素有display:box;属性之后。他的子元素里面加上box-flex属性。可以让子元素按照父元素的宽度进行一定比例的分占空间。 flex是最新的，董机老机子不支持的； 父元素设置display:flex后，子元素宽度会随父元素宽度的改变而改变，而display:box不会。 Android UC浏览器只支持display: box语法；而iOS UC浏览器则支持两种方式。 12.viewport 所有属性 ？(1)width :设置layout viewport的宽度，为一个正整数，或字符串’device-width’; (2)initial-scale:设置页面的初始缩放值，为一个数字，可以带小数。 (3)minimum-scale:允许用户的最小缩放值，为一个数字，可以带小数。 (4)maximum-scale:允许用户的最大缩放值，为一个数字，可以带小数。 (5)height:设置layout viewport的高度，这个属性对我们并不重要，很少使用 (6)user-scalable:是否允许用户进行缩放，值为‘no’或者‘yes’。 安卓中还支持：target-densitydpi，表示目标设备的密度等级，作用是决定css中的1px 代表多少物理像素 (7)target-densitydpi:值可以为一个数值或者 high-dpi 、 medium-dpi、 low-dpi、 device-dpi 这几个字符串中的一个 13.如何理解HTML结构的语义化？所谓标签语义化，就是指标签的含义。语义化的主要目的就是让大家直观的认识标签(markup)和属性(attribute)的用途和作用，对搜索引擎友好，有了良好的结构和语义我们的网页内容便自然容易被搜索引擎抓取，这种符合搜索引擎收索规则的做法，网站的推广便可以省下不少的功夫，而且可维护性更高，因为结构清晰,十分易于阅读。这也是搜索引擎优化SEO重要的一步。 14.伪类选择器和伪元素？c3中引入的伪类选择器有？c3中伪元素有?伪类用一个冒号来表示，而伪元素则用两个冒号来表示。 伪类选择器：由于状态是动态变化的，所以一个元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又会失去这个样式。 伪元素选择器：并不是针对真正的元素使用的选择器，而是针对CSS中已经定义好的伪元素使用的选择器； c3中引入的伪类选择器：:root()选择器，根选择器，匹配元素E所在文档的根元素。在HTML文档中，根元素始终是。:root选择器等同于元素。 :not()选择器称为否定选择器，和jQuery中的:not选择器一模一样，可以选择除某个元素之外的所有元素。 :empty()选择器表示的就是空。用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，哪怕是一个空格。 :target()选择器来对页面某个target元素(该元素的id被当做页面中的超链接来使用)指定样式，该样式只在用户点击了页面中的超链接，并且跳转到target元素后起作用。 :first-child()选择器表示的是选择父元素的第一个子元素的元素E。简单点理解就是选择元素中的第一个子元素，记住是子元素，而不是后代元素。 :nth-child()选择某个元素的一个或多个特定的子元素。 :nth-last-child()从某父元素的最后一个子元素开始计算，来选择特定的元素 :nth-of-type(n)选择器和:nth-child(n)选择器非常类似，不同的是它只计算父元素中指定的某种类型的子元素。 :only-child表示的是一个元素是它的父元素的唯一一个子元素。 :first-line为某个元素的第一行文字使用样式。 :first-letter 为某个元素中的文字的首字母或第一个字使用样式。 :before 在某个元素之前插入一些内容。 :after 在某个元素之后插入一些内容。 c3中伪元素：::first-line选择元素的第一行，比如说改变每个段落的第一行文本的样式::before和::after这两个主要用来给元素的前面或后面插入内容，这两个常用”content”配合使用，见过最多的就是清除浮动::selection用来改变浏览网页选中文的默认效果 15.html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 拖拽释放(Drag and drop) API 语义化更好的内容标签(header,nav,footer,aside,article,section) 音频、视频API(audio,video) 画布(Canvas) API 地理(Geolocation) API 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；sessionStorage 的数据在浏览器关闭后自动删除 表单控件，calendar、date、time、email、url、search 新的技术webworker, websocket, Geolocation 移除的元素 纯表现的元素：basefont，big，center，font, s，strike，tt，u；对可用性产生负面影响的元素：frame，frameset，noframes；支持HTML5新标签： IE8&#x2F;IE7&#x2F;IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式： 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架 如何区分： DOCTYPE声明\\新增的结构元素\\功能元素 16.placeholder?如何在ie8上兼容placeholder这个效果方法一：首先判断浏览器是否支持placeholder属性，如果不支持的话，就遍历所有input输入框，获取placeholder属性的值填充进输入框作为提示信息，同时字体设置成灰色。 当输入框获得焦点( focus )同时输入框内文字等于设置的提示信息时，就把输入框内清空； 当输入框失去焦点( blur )同时输入框内文字为空时，再把获取的placeholder属性的值填充进输入框作为提示信息，同时字体设置成灰色； 当输入框内有输入( keydown )时，此时输入框内的提示信息已经由focus事件清除，此时只需要把字体再恢复成黑色即可 此方法的缺点是，不适用于加载完DOM时即获得焦点的输入框，因为在用户的角度，加载完页面时看到的获得焦点的那个输入框，它的提示文字是看不到的。HTML： 1&lt;input type=&quot;text&quot; id=&quot;uname&quot; name=&quot;uname&quot; placeholder=&quot;请输入用户名&quot;/&gt; CSS： 1.phcolor&#123; color:#999;&#125; JS 12345678910111213141516171819202122232425262728293031323334$(function()&#123; //判断浏览器是否支持placeholder属性 supportPlaceholder=&#x27;placeholder&#x27;in document.createElement(&#x27;input&#x27;), placeholder=function(input)&#123; var text = input.attr(&#x27;placeholder&#x27;), defaultValue = input.defaultValue; if(!defaultValue)&#123; input.val(text).addClass(&quot;phcolor&quot;); &#125; input.focus(function()&#123; if(input.val() == text)&#123; $(this).val(&quot;&quot;); &#125; &#125;); input.blur(function()&#123; if(input.val() == &quot;&quot;)&#123; $(this).val(text).addClass(&quot;phcolor&quot;); &#125; &#125;); //输入的字符不为灰色 input.keydown(function()&#123; $(this).removeClass(&quot;phcolor&quot;); &#125;); &#125;; //当浏览器不支持placeholder属性时，调用placeholder函数 if(!supportPlaceholder)&#123; $(&#x27;input&#x27;).each(function()&#123; text = $(this).attr(&quot;placeholder&quot;); if($(this).attr(&quot;type&quot;) == &quot;text&quot;)&#123; placeholder($(this)); &#125; &#125;); &#125;&#125;); 方法二： 此方法的思路是做一张含有提示文字的图片作为input输入框的背景图，初始时获得焦点同时加载背景图； 当输入框不为空时，去掉背景图； 当输入框为空时，加载背景图； 当用户键盘按键且输入框不为空( 输入字符 )时，去掉背景图； 当用户键盘按键且输入框为空( 删除字符 )时，加载背景图。 此方法的缺点是：需要为每一个提示文字不同的input制作背景图片，并且设置input的样式。 CSS： 1.phbg&#123; background:url(img/bg.jpg) 0 0 no-repeat;&#125; JS 123456789101112131415161718192021222324252627$(function()&#123; //判断浏览器是否支持placeholder属性 supportPlaceholder=&#x27;placeholder&#x27; in document.createElement(&#x27;input&#x27;); if(!supportPlaceholder)&#123; //初始状态添加背景图片 $(&quot;#uname&quot;).attr(&quot;class&quot;,&quot;phbg&quot;); //初始状态获得焦点 $(&quot;#uname&quot;).focus; function destyle()&#123; if($(&quot;#uname&quot;).val() != &quot;&quot;)&#123; $(&quot;#uname&quot;).removeClass(&quot;phbg&quot;); &#125;else&#123; $(&quot;#uname&quot;).attr(&quot;class&quot;,&quot;phbg&quot;); &#125; &#125; //当输入框为空时，添加背景图片；有值时去掉背景图片 destyle(); $(&quot;#uname&quot;).keyup(function()&#123; //当输入框有按键输入同时输入框不为空时，去掉背景图片；有按键输入同时为空时（删除字符），添加背景图片 destyle(); &#125;); $(&quot;#uname&quot;).keydown(function()&#123; //keydown事件可以在按键按下的第一时间去掉背景图片 $(&quot;#uname&quot;).removeClass(&quot;phbg&quot;); &#125;); &#125;&#125;); 方法三：使用插件：Placeholders.js 17.常见兼容性问题？ png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理。 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。 IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。） #box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。css&#x2F;&#x2F; .bb{ background-color:#f1ee18; .background-color:#00deff\\9; +background-color:#a200ff; _background-color:#1e0bd1; } IE下,可以使用获取常规属性的方法来获取自定义属性, 也可以使用getAttribute()获取自定义属性; Firefox下,只能使用getAttribute()获取自定义属性. 解决方法:统一通过getAttribute()获取自定义属性。 IE下,event对象有x,y属性,但是没有pageX,pageY属性; Firefox下,event对象有pageX,pageY属性,但是没有x,y属性. * 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {} 怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在可以使用html5推荐的写法：&lt;doctype html&gt; 上下margin重合问题ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。 ie6对png图片格式支持不好(引用一段脚本处理) 18.简述前端优化的方式 旧的雅虎34条|h5新添加的方式 尽量减少HTTP请求次数 减少DNS查找次数 避免跳转 可缓存的AJAX 推迟加载内容 预加载 减少DOM元素数量 根据域名划分页面内容 使iframe的数量最小 不要出现404错误 使用内容分发网络 为文件头指定Expires或Cache-Control Gzip压缩文件内容 配置ETag 尽早刷新输出缓冲 使用GET来完成AJAX请求 把样式表置于顶部 避免使用CSS表达式（Expression） 使用外部JavaScript和CSS 削减JavaScript和CSS 用代替@import 避免使用滤镜 把脚本置于页面底部 剔除重复脚本 19.jquery版本?1.11兼容?Query 2.x系列和 jQuery 1.x拥有同样的API，但是不再支持IE6、7、8。 推荐使用 1.x version，除非你确定IE6、7、8用户不再访问网站。 jquery1.11属于1.x 版本，其兼容IE6、7、8，所以也支持IE9. 20.块级？行内？空元素?行内元素：和有他元素都在一行上，高度、行高及外边距和内边距都不可改变，文字图片的宽度不可改变，只能容纳文本或者其他行内元素 块级元素：总是在新行上开始，高度、行高及外边距和内边距都可控制，可以容纳内敛元素和其他元素； 空元素：在HTML元素中，没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。 就是没有关闭标签的空元素。 21.media属性？screen？All？max-width?min-width?media 属性规定被链接文档将显示在什么设备上。media 属性用于为不同的媒介类型规定不同的样式。Screen计算机默认屏幕，all适用于所有设备，max-width超过最大宽度就不执行，min-width必须大于最小宽度才执行。 22.meta标签的name属性值？name 属性主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。 meta标签的name属性语法格式是：＜meta name&#x3D;”参数” content&#x3D;”具体的参数值”＞。 其中name属性主要有以下几种参数： A 、Keywords(关键字)说明：keywords用来告诉搜索引擎你网页的关键字是什么。 B 、description(网站内容描述) 说明：description用来告诉搜索引擎你的网站主要内容. C 、robots(机器人向导)说明：robots用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。 content的参数有all,none,index,noindex,follow,nofollow,默认是all。 举例：＜meta name&#x3D;”robots” content&#x3D;”none”＞D 、author(作者) 23.一般做手机页面切图有几种方式?响应式布局，弹性布局display：flex，利用js编写设定比例，给根元素设定像素，使用rem为单位。 24.px&#x2F;em&#x2F;rem有什么区别？ 为什么通常给font-size 设置的字体为62.5%相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。 1、em的值并不是固定的； 2、em会继承父级元素的字体大小。使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。 rem是相对于浏览器进行缩放的。1rem默认是16px，在响应式布局中，一个个除来转换成rem，太麻烦，所以重置rem body{font-size&#x3D;62.5% } 此时1rem &#x3D; 10px;若是12px则是1.2rem. 25.sass和scss有什么区别?sass一般怎么样编译的文件扩展名不同，Sass 是以“.sass”后缀为扩展名，而 SCSS 是以“.scss”后缀为扩展名；语法书写方式不同，Sass 是以严格的缩进式语法规则来书写，不带大括号({})和分号(;)，而 SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。 26.如果对css进行优化如何处理？压缩打包，图片整合，避免使用Hack，解决兼容问题，使用简写，让CSS能保证日后的维护。 27.如何对css文件进行压缩合并? gulp ?使用gulp, 首页全局安装gulp。 1、npm install –global gulp 2、其次局部安装gulp。npm install gulp –save-dev 3、在项目根目录下创建一个名为 gulpfile.js 的文件var gulp &#x3D; require(‘gulp’);gulp.task(‘default’, function() {&#x2F;&#x2F; 将你的默认的任务代码放在这}); 4、运行gulp。（默认的名为 default 的任务（task）将会被运行，想要单独执行特定的任务（task），请输入 gulp ） 压缩JS，CSS文件需要引用如下组件：gulp-minify-css: 压缩css 28.组件? 模块化编程？组件化编程: 将js css html包装一起提供方法和效果；模块化化: 将相同的功能抽取出来 存放在一个位置进行编程 29.图片和文字在同一行显示?1 在css中给div添加上“vertical-align:middle”属性。 2 分别把图片和文字放入不同的div中，然后用“margin”属性进行定位，就可以使他们显示在同一行。 3 把图片设置为背景图片。 30.禁止事件冒泡event.stopPropagation() 31.禁止默认事件event.preventDefault() 32.a标签中 active hover link visited 正确的设置顺序是什么?a标签的link、visited、hover、active是有一定顺序的a:linka:visiteda:hovera:active 33.a标签中 如何禁用href 跳转页面 或 定位链接e.preventDefault();href&#x3D;”javascript:void(0); 34.手机端上 图片长时间点击会选中图片，如何处理?onselect&#x3D;function() {return false} 35.video标签的几个个属性方法src：视频的URL poster：视频封面，没有播放时显示的图片 preload：预加载 autoplay：自动播放 loop：循环播放 controls：浏览器自带的控制条 width：视频宽度 height：视频高度 36.常见的视频编码格式有几种?视频格式有几种?视频格式：MPEG-1、MPEG-2和MPEG4 、AVI 、RM、ASF和WMV格式视频编码格式：H.264、MPEG-4、MPEG-2、WMA-HD以及VC-1 37.canvas在标签上设置宽高 和在style中设置宽高有什么区别？canvas标签的width和height是画布实际宽度和高度，绘制的图形都是在这个上面。而style的width和height是canvas在浏览器中被渲染的高度和宽度。如果canvas的width和height没指定或值不正确，就被设置成默认值 。 38.border-image？box-sizing?Border-image : 图形化边框 Box-sizing : 属性允许您以特定的方式定义匹配某个区域的特定元素。 语法 ：box-sizing：content-box | border-box Content-box : padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 ( Element width &#x3D; width + border + padding) 此属性表现为标准模式下的盒模型 . Border-box : padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width &#x3D; width ) 此属性表现为怪异模式下的盒模型。 39.渐进增强和优雅降级渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 “优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。 “渐进增强”观点则认为应关注于内容本身。内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。 那么问题来了。现在产品经理看到IE6,7,8网页效果相对高版本现代浏览器少了很多圆角，阴影（CSS3），要求兼容（使用图片背景，放弃CSS3），你会如何说服他？ 41.animation对应的属性写法：animation: name duration timing-function delay iteration-count direction; 下面是对应的属性的介绍 animation-name 规定需要绑定到选择器的 keyframe 名称。 animation-duration规定完成动画所花费的时间，以秒或毫秒计。 animation-timing-function规定动画的速度曲线。 animation-delay规定在动画开始之前的延迟。 animation-iteration-count 规定动画应该播放的次数。 animation-direction 规定是否应该轮流反向播放动画。 42.transition?css的transition允许css的属性值在一定的时间区间内平滑地过渡。这种效果可以在鼠标单击、获得焦点、被点击或对元素任何改变中触发，并圆滑地以动画效果改变CSS的属性值 注意区别transform，transform是进行2D转换的 如移动，比例化，反过来，旋转，和拉伸元素。 43.h5新特性？1、绘画的 canvas 元素2、用于媒介回放的 video 和 audio 元素3、对本地离线存储的更好的支持4、新的特殊内容元素，比如 article、footer、header、nav、section 5、新的表单控件，比如 calendar、date、time、email、url、search 44.canvas 如何绘制一个三角形|正方形moveto 是移动到某个坐标， lineto 是从当前坐标连线到某个坐标。 这两个函数加起来就是画一条直线。 画线要用“笔”，那么MoveTo()把笔要画的起始位置固定了（x,y）然后要固定终止位置要用到LineTo函数确定终止位置（xend,yend）,这样一条线就画出来了。 每次与前面一个坐标相连 。 stroke() 方法会实际地绘制出通过 moveTo() 和 lineTo() 方法定义的路径。默认颜色是黑色。 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE HTML5&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;画布&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot; style=&quot;border:1px solid #c3c3c3;&quot;&gt; Your browser does not support the canvas element. &lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;);//三角形 var cxt=c.getContext(&quot;2d&quot;); cxt.moveTo(10,10); cxt.lineTo(50,50); cxt.lineTo(10,50); cxt.lineTo(10,10); cxt.stroke();//正方形 var cxt2=c.getContext(&quot;2d&quot;); cxt2.moveTo(60,10); cxt2.lineTo(100,10); cxt2.lineTo(100,50); cxt2.lineTo(60,50); cxt2.lineTo(60,10); cxt2.stroke(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 45.所用bootstap版本？3.0 46.css清除浮动的几种方式？ 父级div定义 height 结尾处加空div标签 clear:both 父级div定义 伪类:after 和 zoom 父级div定义 overflow:hidden 父级div定义 overflow:auto 父级div 也一起浮动 父级div定义 display:table 47.为什么要初始化CSS样式。因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 48.CSS3有哪些新特性？CSS3实现圆角（border-radius），阴影（box-shadow） 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform） transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg); &#x2F;&#x2F;旋转,缩放,定位,倾斜增加了更多的CSS选择器 多背景 rgba 在CSS3中唯一引入的伪元素是::selection.媒体查询，多栏布局 border-image 49.解释下 CSS sprites，以及你要如何在页面或网站中使用它。CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了http2。 50.什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？FOUC - Flash Of Unstyled Content 文档样式闪烁 1&lt;style type=&quot;text/css&quot; media=&quot;all&quot;&gt;@import &quot;../fouc.css&quot;;&lt;/style&gt; 而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。解决方法：只要在之间加入一个或者元素就可以了。 51.a点击出现框，解决方法:123456789101112a,a:hover,a:active,a:visited,a:link,a:focus&#123; -webkit-tap-highlight-color:rgba(0,0,0,0); -webkit-tap-highlight-color: transparent; outline:none;background: none; text-decoration: none;border:none; -webkit-appearance: none; &#125;","tags":[{"name":"CSS","slug":"CSS","permalink":"https://sellenite.github.io/tags/CSS/"}]},{"title":"Falcom 2017 Calendar","date":"2017-03-02T01:07:01.000Z","path":"2017/03/02/Falcom 2017 日历/","text":"Falcom 2017 日历简单做了个Falcom日历轮播，画面太美 Falcom 2017 Calendar","tags":[]}]